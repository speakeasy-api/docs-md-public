(() => {
  var __defProp = Object.defineProperty;
  var __export = (target, all) => {
    for (var name in all)
      __defProp(target, name, { get: all[name], enumerable: true });
  };

  // node_modules/@gleanwork/api-client/dist/esm/index.js
  var esm_exports = {};
  __export(esm_exports, {
    Glean: () => Glean,
    HTTPClient: () => HTTPClient,
    SDK_METADATA: () => SDK_METADATA,
    ServerList: () => ServerList,
    files: () => files_exports,
    serverURLFromOptions: () => serverURLFromOptions
  });

  // node_modules/@gleanwork/api-client/dist/esm/lib/url.js
  var hasOwn = Object.prototype.hasOwnProperty;
  function pathToFunc(pathPattern, options) {
    const paramRE = /\{([a-zA-Z0-9_][a-zA-Z0-9_-]*?)\}/g;
    return function buildURLPath(params = {}) {
      return pathPattern.replace(paramRE, function(_, placeholder) {
        if (!hasOwn.call(params, placeholder)) {
          throw new Error(`Parameter '${placeholder}' is required`);
        }
        const value = params[placeholder];
        if (typeof value !== "string" && typeof value !== "number") {
          throw new Error(`Parameter '${placeholder}' must be a string or number`);
        }
        return options?.charEncoding === "percent" ? encodeURIComponent(`${value}`) : `${value}`;
      });
    };
  }

  // node_modules/@gleanwork/api-client/dist/esm/lib/config.js
  var ServerList = [
    "https://{instance}-be.glean.com"
  ];
  function serverURLFromOptions(options) {
    let serverURL = options.serverURL;
    const serverParams = [
      {
        "instance": options.instance ?? "instance-name"
      }
    ];
    let params = {};
    if (!serverURL) {
      const serverIdx = options.serverIdx ?? 0;
      if (serverIdx < 0 || serverIdx >= ServerList.length) {
        throw new Error(`Invalid server index ${serverIdx}`);
      }
      serverURL = ServerList[serverIdx] || "";
      params = serverParams[serverIdx] || {};
    }
    const u = pathToFunc(serverURL)(params);
    return new URL(u);
  }
  var SDK_METADATA = {
    language: "typescript",
    openapiDocVersion: "0.9.0",
    sdkVersion: "0.11.2",
    genVersion: "2.720.1",
    userAgent: "speakeasy-sdk/typescript 0.11.2 2.720.1 0.9.0 @gleanwork/api-client"
  };

  // node_modules/@gleanwork/api-client/dist/esm/lib/files.js
  var files_exports = {};
  __export(files_exports, {
    getContentTypeFromFileName: () => getContentTypeFromFileName,
    readableStreamToArrayBuffer: () => readableStreamToArrayBuffer
  });
  async function readableStreamToArrayBuffer(readable) {
    const reader = readable.getReader();
    const chunks = [];
    let totalLength = 0;
    let done = false;
    while (!done) {
      const { value, done: doneReading } = await reader.read();
      if (doneReading) {
        done = true;
      } else {
        chunks.push(value);
        totalLength += value.length;
      }
    }
    const concatenatedChunks = new Uint8Array(totalLength);
    let offset = 0;
    for (const chunk of chunks) {
      concatenatedChunks.set(chunk, offset);
      offset += chunk.length;
    }
    return concatenatedChunks.buffer;
  }
  function getContentTypeFromFileName(fileName) {
    if (!fileName)
      return null;
    const ext = fileName.toLowerCase().split(".").pop();
    if (!ext)
      return null;
    const mimeTypes = {
      json: "application/json",
      xml: "application/xml",
      html: "text/html",
      htm: "text/html",
      txt: "text/plain",
      csv: "text/csv",
      pdf: "application/pdf",
      png: "image/png",
      jpg: "image/jpeg",
      jpeg: "image/jpeg",
      gif: "image/gif",
      svg: "image/svg+xml",
      js: "application/javascript",
      css: "text/css",
      zip: "application/zip",
      tar: "application/x-tar",
      gz: "application/gzip",
      mp4: "video/mp4",
      mp3: "audio/mpeg",
      wav: "audio/wav",
      webp: "image/webp",
      ico: "image/x-icon",
      woff: "font/woff",
      woff2: "font/woff2",
      ttf: "font/ttf",
      otf: "font/otf"
    };
    return mimeTypes[ext] || null;
  }

  // node_modules/@gleanwork/api-client/dist/esm/lib/http.js
  var DEFAULT_FETCHER = (input, init) => {
    if (init == null) {
      return fetch(input);
    } else {
      return fetch(input, init);
    }
  };
  var HTTPClient = class _HTTPClient {
    constructor(options = {}) {
      this.options = options;
      this.requestHooks = [];
      this.requestErrorHooks = [];
      this.responseHooks = [];
      this.fetcher = options.fetcher || DEFAULT_FETCHER;
    }
    async request(request) {
      let req = request;
      for (const hook of this.requestHooks) {
        const nextRequest = await hook(req);
        if (nextRequest) {
          req = nextRequest;
        }
      }
      try {
        const res = await this.fetcher(req);
        for (const hook of this.responseHooks) {
          await hook(res, req);
        }
        return res;
      } catch (err) {
        for (const hook of this.requestErrorHooks) {
          await hook(err, req);
        }
        throw err;
      }
    }
    addHook(...args) {
      if (args[0] === "beforeRequest") {
        this.requestHooks.push(args[1]);
      } else if (args[0] === "requestError") {
        this.requestErrorHooks.push(args[1]);
      } else if (args[0] === "response") {
        this.responseHooks.push(args[1]);
      } else {
        throw new Error(`Invalid hook type: ${args[0]}`);
      }
      return this;
    }
    removeHook(...args) {
      let target;
      if (args[0] === "beforeRequest") {
        target = this.requestHooks;
      } else if (args[0] === "requestError") {
        target = this.requestErrorHooks;
      } else if (args[0] === "response") {
        target = this.responseHooks;
      } else {
        throw new Error(`Invalid hook type: ${args[0]}`);
      }
      const index = target.findIndex((v) => v === args[1]);
      if (index >= 0) {
        target.splice(index, 1);
      }
      return this;
    }
    clone() {
      const child = new _HTTPClient(this.options);
      child.requestHooks = this.requestHooks.slice();
      child.requestErrorHooks = this.requestErrorHooks.slice();
      child.responseHooks = this.responseHooks.slice();
      return child;
    }
  };
  var mediaParamSeparator = /\s*;\s*/g;
  function matchContentType(response, pattern) {
    if (pattern === "*") {
      return true;
    }
    let contentType = response.headers.get("content-type")?.trim() || "application/octet-stream";
    contentType = contentType.toLowerCase();
    const wantParts = pattern.toLowerCase().trim().split(mediaParamSeparator);
    const [wantType = "", ...wantParams] = wantParts;
    if (wantType.split("/").length !== 2) {
      return false;
    }
    const gotParts = contentType.split(mediaParamSeparator);
    const [gotType = "", ...gotParams] = gotParts;
    const [type = "", subtype = ""] = gotType.split("/");
    if (!type || !subtype) {
      return false;
    }
    if (wantType !== "*/*" && gotType !== wantType && `${type}/*` !== wantType && `*/${subtype}` !== wantType) {
      return false;
    }
    if (gotParams.length < wantParams.length) {
      return false;
    }
    const params = new Set(gotParams);
    for (const wantParam of wantParams) {
      if (!params.has(wantParam)) {
        return false;
      }
    }
    return true;
  }
  var codeRangeRE = new RegExp("^[0-9]xx$", "i");
  function matchStatusCode(response, codes) {
    const actual = `${response.status}`;
    const expectedCodes = Array.isArray(codes) ? codes : [codes];
    if (!expectedCodes.length) {
      return false;
    }
    return expectedCodes.some((ec) => {
      const code = `${ec}`;
      if (code === "default") {
        return true;
      }
      if (!codeRangeRE.test(`${code}`)) {
        return code === actual;
      }
      const expectFamily = code.charAt(0);
      if (!expectFamily) {
        throw new Error("Invalid status code range");
      }
      const actualFamily = actual.charAt(0);
      if (!actualFamily) {
        throw new Error(`Invalid response status code: ${actual}`);
      }
      return actualFamily === expectFamily;
    });
  }
  function matchResponse(response, code, contentTypePattern) {
    return matchStatusCode(response, code) && matchContentType(response, contentTypePattern);
  }
  function isConnectionError(err) {
    if (typeof err !== "object" || err == null) {
      return false;
    }
    const isBrowserErr = err instanceof TypeError && err.message.toLowerCase().startsWith("failed to fetch");
    const isNodeErr = err instanceof TypeError && err.message.toLowerCase().startsWith("fetch failed");
    const isBunErr = "name" in err && err.name === "ConnectionError";
    const isGenericErr = "code" in err && typeof err.code === "string" && err.code.toLowerCase() === "econnreset";
    return isBrowserErr || isNodeErr || isGenericErr || isBunErr;
  }
  function isTimeoutError(err) {
    if (typeof err !== "object" || err == null) {
      return false;
    }
    const isNative = "name" in err && err.name === "TimeoutError";
    const isLegacyNative = "code" in err && err.code === 23;
    const isGenericErr = "code" in err && typeof err.code === "string" && err.code.toLowerCase() === "econnaborted";
    return isNative || isLegacyNative || isGenericErr;
  }
  function isAbortError(err) {
    if (typeof err !== "object" || err == null) {
      return false;
    }
    const isNative = "name" in err && err.name === "AbortError";
    const isLegacyNative = "code" in err && err.code === 20;
    const isGenericErr = "code" in err && typeof err.code === "string" && err.code.toLowerCase() === "econnaborted";
    return isNative || isLegacyNative || isGenericErr;
  }

  // node_modules/@gleanwork/api-client/dist/esm/hooks/registration.js
  function initHooks(hooks) {
  }

  // node_modules/@gleanwork/api-client/dist/esm/hooks/hooks.js
  var SDKHooks = class {
    constructor() {
      this.sdkInitHooks = [];
      this.beforeCreateRequestHooks = [];
      this.beforeRequestHooks = [];
      this.afterSuccessHooks = [];
      this.afterErrorHooks = [];
      const presetHooks = [];
      for (const hook of presetHooks) {
        if ("sdkInit" in hook) {
          this.registerSDKInitHook(hook);
        }
        if ("beforeCreateRequest" in hook) {
          this.registerBeforeCreateRequestHook(hook);
        }
        if ("beforeRequest" in hook) {
          this.registerBeforeRequestHook(hook);
        }
        if ("afterSuccess" in hook) {
          this.registerAfterSuccessHook(hook);
        }
        if ("afterError" in hook) {
          this.registerAfterErrorHook(hook);
        }
      }
      initHooks(this);
    }
    registerSDKInitHook(hook) {
      this.sdkInitHooks.push(hook);
    }
    registerBeforeCreateRequestHook(hook) {
      this.beforeCreateRequestHooks.push(hook);
    }
    registerBeforeRequestHook(hook) {
      this.beforeRequestHooks.push(hook);
    }
    registerAfterSuccessHook(hook) {
      this.afterSuccessHooks.push(hook);
    }
    registerAfterErrorHook(hook) {
      this.afterErrorHooks.push(hook);
    }
    sdkInit(opts) {
      return this.sdkInitHooks.reduce((opts2, hook) => hook.sdkInit(opts2), opts);
    }
    beforeCreateRequest(hookCtx, input) {
      let inp = input;
      for (const hook of this.beforeCreateRequestHooks) {
        inp = hook.beforeCreateRequest(hookCtx, inp);
      }
      return inp;
    }
    async beforeRequest(hookCtx, request) {
      let req = request;
      for (const hook of this.beforeRequestHooks) {
        req = await hook.beforeRequest(hookCtx, req);
      }
      return req;
    }
    async afterSuccess(hookCtx, response) {
      let res = response;
      for (const hook of this.afterSuccessHooks) {
        res = await hook.afterSuccess(hookCtx, res);
      }
      return res;
    }
    async afterError(hookCtx, response, error) {
      let res = response;
      let err = error;
      for (const hook of this.afterErrorHooks) {
        const result = await hook.afterError(hookCtx, res, err);
        res = result.response;
        err = result.error;
      }
      return { response: res, error: err };
    }
  };

  // node_modules/@gleanwork/api-client/dist/esm/models/errors/httpclienterrors.js
  var HTTPClientError = class extends Error {
    constructor(message, opts) {
      let msg = message;
      if (opts?.cause) {
        msg += `: ${opts.cause}`;
      }
      super(msg, opts);
      this.name = "HTTPClientError";
      if (typeof this.cause === "undefined") {
        this.cause = opts?.cause;
      }
    }
  };
  var UnexpectedClientError = class extends HTTPClientError {
    constructor() {
      super(...arguments);
      this.name = "UnexpectedClientError";
    }
  };
  var InvalidRequestError = class extends HTTPClientError {
    constructor() {
      super(...arguments);
      this.name = "InvalidRequestError";
    }
  };
  var RequestAbortedError = class extends HTTPClientError {
    constructor() {
      super(...arguments);
      this.name = "RequestAbortedError";
    }
  };
  var RequestTimeoutError = class extends HTTPClientError {
    constructor() {
      super(...arguments);
      this.name = "RequestTimeoutError";
    }
  };
  var ConnectionError = class extends HTTPClientError {
    constructor() {
      super(...arguments);
      this.name = "ConnectionError";
    }
  };

  // node_modules/@gleanwork/api-client/dist/esm/types/fp.js
  function OK(value) {
    return { ok: true, value };
  }
  function ERR(error) {
    return { ok: false, error };
  }
  async function unwrapAsync(pr) {
    const r = await pr;
    if (!r.ok) {
      throw r.error;
    }
    return r.value;
  }

  // node_modules/zod/v3/helpers/util.js
  var util;
  (function(util2) {
    util2.assertEqual = (_) => {
    };
    function assertIs(_arg) {
    }
    util2.assertIs = assertIs;
    function assertNever(_x) {
      throw new Error();
    }
    util2.assertNever = assertNever;
    util2.arrayToEnum = (items) => {
      const obj = {};
      for (const item of items) {
        obj[item] = item;
      }
      return obj;
    };
    util2.getValidEnumValues = (obj) => {
      const validKeys = util2.objectKeys(obj).filter((k) => typeof obj[obj[k]] !== "number");
      const filtered = {};
      for (const k of validKeys) {
        filtered[k] = obj[k];
      }
      return util2.objectValues(filtered);
    };
    util2.objectValues = (obj) => {
      return util2.objectKeys(obj).map(function(e) {
        return obj[e];
      });
    };
    util2.objectKeys = typeof Object.keys === "function" ? (obj) => Object.keys(obj) : (object) => {
      const keys = [];
      for (const key in object) {
        if (Object.prototype.hasOwnProperty.call(object, key)) {
          keys.push(key);
        }
      }
      return keys;
    };
    util2.find = (arr, checker) => {
      for (const item of arr) {
        if (checker(item))
          return item;
      }
      return void 0;
    };
    util2.isInteger = typeof Number.isInteger === "function" ? (val) => Number.isInteger(val) : (val) => typeof val === "number" && Number.isFinite(val) && Math.floor(val) === val;
    function joinValues(array, separator = " | ") {
      return array.map((val) => typeof val === "string" ? `'${val}'` : val).join(separator);
    }
    util2.joinValues = joinValues;
    util2.jsonStringifyReplacer = (_, value) => {
      if (typeof value === "bigint") {
        return value.toString();
      }
      return value;
    };
  })(util || (util = {}));
  var objectUtil;
  (function(objectUtil2) {
    objectUtil2.mergeShapes = (first, second) => {
      return {
        ...first,
        ...second
        // second overwrites first
      };
    };
  })(objectUtil || (objectUtil = {}));
  var ZodParsedType = util.arrayToEnum([
    "string",
    "nan",
    "number",
    "integer",
    "float",
    "boolean",
    "date",
    "bigint",
    "symbol",
    "function",
    "undefined",
    "null",
    "array",
    "object",
    "unknown",
    "promise",
    "void",
    "never",
    "map",
    "set"
  ]);
  var getParsedType = (data) => {
    const t = typeof data;
    switch (t) {
      case "undefined":
        return ZodParsedType.undefined;
      case "string":
        return ZodParsedType.string;
      case "number":
        return Number.isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;
      case "boolean":
        return ZodParsedType.boolean;
      case "function":
        return ZodParsedType.function;
      case "bigint":
        return ZodParsedType.bigint;
      case "symbol":
        return ZodParsedType.symbol;
      case "object":
        if (Array.isArray(data)) {
          return ZodParsedType.array;
        }
        if (data === null) {
          return ZodParsedType.null;
        }
        if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
          return ZodParsedType.promise;
        }
        if (typeof Map !== "undefined" && data instanceof Map) {
          return ZodParsedType.map;
        }
        if (typeof Set !== "undefined" && data instanceof Set) {
          return ZodParsedType.set;
        }
        if (typeof Date !== "undefined" && data instanceof Date) {
          return ZodParsedType.date;
        }
        return ZodParsedType.object;
      default:
        return ZodParsedType.unknown;
    }
  };

  // node_modules/zod/v3/ZodError.js
  var ZodIssueCode = util.arrayToEnum([
    "invalid_type",
    "invalid_literal",
    "custom",
    "invalid_union",
    "invalid_union_discriminator",
    "invalid_enum_value",
    "unrecognized_keys",
    "invalid_arguments",
    "invalid_return_type",
    "invalid_date",
    "invalid_string",
    "too_small",
    "too_big",
    "invalid_intersection_types",
    "not_multiple_of",
    "not_finite"
  ]);
  var ZodError = class _ZodError extends Error {
    get errors() {
      return this.issues;
    }
    constructor(issues) {
      super();
      this.issues = [];
      this.addIssue = (sub) => {
        this.issues = [...this.issues, sub];
      };
      this.addIssues = (subs = []) => {
        this.issues = [...this.issues, ...subs];
      };
      const actualProto = new.target.prototype;
      if (Object.setPrototypeOf) {
        Object.setPrototypeOf(this, actualProto);
      } else {
        this.__proto__ = actualProto;
      }
      this.name = "ZodError";
      this.issues = issues;
    }
    format(_mapper) {
      const mapper = _mapper || function(issue) {
        return issue.message;
      };
      const fieldErrors = { _errors: [] };
      const processError = (error) => {
        for (const issue of error.issues) {
          if (issue.code === "invalid_union") {
            issue.unionErrors.map(processError);
          } else if (issue.code === "invalid_return_type") {
            processError(issue.returnTypeError);
          } else if (issue.code === "invalid_arguments") {
            processError(issue.argumentsError);
          } else if (issue.path.length === 0) {
            fieldErrors._errors.push(mapper(issue));
          } else {
            let curr = fieldErrors;
            let i = 0;
            while (i < issue.path.length) {
              const el = issue.path[i];
              const terminal = i === issue.path.length - 1;
              if (!terminal) {
                curr[el] = curr[el] || { _errors: [] };
              } else {
                curr[el] = curr[el] || { _errors: [] };
                curr[el]._errors.push(mapper(issue));
              }
              curr = curr[el];
              i++;
            }
          }
        }
      };
      processError(this);
      return fieldErrors;
    }
    static assert(value) {
      if (!(value instanceof _ZodError)) {
        throw new Error(`Not a ZodError: ${value}`);
      }
    }
    toString() {
      return this.message;
    }
    get message() {
      return JSON.stringify(this.issues, util.jsonStringifyReplacer, 2);
    }
    get isEmpty() {
      return this.issues.length === 0;
    }
    flatten(mapper = (issue) => issue.message) {
      const fieldErrors = {};
      const formErrors = [];
      for (const sub of this.issues) {
        if (sub.path.length > 0) {
          const firstEl = sub.path[0];
          fieldErrors[firstEl] = fieldErrors[firstEl] || [];
          fieldErrors[firstEl].push(mapper(sub));
        } else {
          formErrors.push(mapper(sub));
        }
      }
      return { formErrors, fieldErrors };
    }
    get formErrors() {
      return this.flatten();
    }
  };
  ZodError.create = (issues) => {
    const error = new ZodError(issues);
    return error;
  };

  // node_modules/zod/v3/locales/en.js
  var errorMap = (issue, _ctx) => {
    let message;
    switch (issue.code) {
      case ZodIssueCode.invalid_type:
        if (issue.received === ZodParsedType.undefined) {
          message = "Required";
        } else {
          message = `Expected ${issue.expected}, received ${issue.received}`;
        }
        break;
      case ZodIssueCode.invalid_literal:
        message = `Invalid literal value, expected ${JSON.stringify(issue.expected, util.jsonStringifyReplacer)}`;
        break;
      case ZodIssueCode.unrecognized_keys:
        message = `Unrecognized key(s) in object: ${util.joinValues(issue.keys, ", ")}`;
        break;
      case ZodIssueCode.invalid_union:
        message = `Invalid input`;
        break;
      case ZodIssueCode.invalid_union_discriminator:
        message = `Invalid discriminator value. Expected ${util.joinValues(issue.options)}`;
        break;
      case ZodIssueCode.invalid_enum_value:
        message = `Invalid enum value. Expected ${util.joinValues(issue.options)}, received '${issue.received}'`;
        break;
      case ZodIssueCode.invalid_arguments:
        message = `Invalid function arguments`;
        break;
      case ZodIssueCode.invalid_return_type:
        message = `Invalid function return type`;
        break;
      case ZodIssueCode.invalid_date:
        message = `Invalid date`;
        break;
      case ZodIssueCode.invalid_string:
        if (typeof issue.validation === "object") {
          if ("includes" in issue.validation) {
            message = `Invalid input: must include "${issue.validation.includes}"`;
            if (typeof issue.validation.position === "number") {
              message = `${message} at one or more positions greater than or equal to ${issue.validation.position}`;
            }
          } else if ("startsWith" in issue.validation) {
            message = `Invalid input: must start with "${issue.validation.startsWith}"`;
          } else if ("endsWith" in issue.validation) {
            message = `Invalid input: must end with "${issue.validation.endsWith}"`;
          } else {
            util.assertNever(issue.validation);
          }
        } else if (issue.validation !== "regex") {
          message = `Invalid ${issue.validation}`;
        } else {
          message = "Invalid";
        }
        break;
      case ZodIssueCode.too_small:
        if (issue.type === "array")
          message = `Array must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;
        else if (issue.type === "string")
          message = `String must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;
        else if (issue.type === "number")
          message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;
        else if (issue.type === "bigint")
          message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;
        else if (issue.type === "date")
          message = `Date must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue.minimum))}`;
        else
          message = "Invalid input";
        break;
      case ZodIssueCode.too_big:
        if (issue.type === "array")
          message = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;
        else if (issue.type === "string")
          message = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;
        else if (issue.type === "number")
          message = `Number must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
        else if (issue.type === "bigint")
          message = `BigInt must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
        else if (issue.type === "date")
          message = `Date must be ${issue.exact ? `exactly` : issue.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue.maximum))}`;
        else
          message = "Invalid input";
        break;
      case ZodIssueCode.custom:
        message = `Invalid input`;
        break;
      case ZodIssueCode.invalid_intersection_types:
        message = `Intersection results could not be merged`;
        break;
      case ZodIssueCode.not_multiple_of:
        message = `Number must be a multiple of ${issue.multipleOf}`;
        break;
      case ZodIssueCode.not_finite:
        message = "Number must be finite";
        break;
      default:
        message = _ctx.defaultError;
        util.assertNever(issue);
    }
    return { message };
  };
  var en_default = errorMap;

  // node_modules/zod/v3/errors.js
  var overrideErrorMap = en_default;
  function getErrorMap() {
    return overrideErrorMap;
  }

  // node_modules/zod/v3/helpers/parseUtil.js
  var makeIssue = (params) => {
    const { data, path, errorMaps, issueData } = params;
    const fullPath = [...path, ...issueData.path || []];
    const fullIssue = {
      ...issueData,
      path: fullPath
    };
    if (issueData.message !== void 0) {
      return {
        ...issueData,
        path: fullPath,
        message: issueData.message
      };
    }
    let errorMessage = "";
    const maps = errorMaps.filter((m) => !!m).slice().reverse();
    for (const map of maps) {
      errorMessage = map(fullIssue, { data, defaultError: errorMessage }).message;
    }
    return {
      ...issueData,
      path: fullPath,
      message: errorMessage
    };
  };
  function addIssueToContext(ctx, issueData) {
    const overrideMap = getErrorMap();
    const issue = makeIssue({
      issueData,
      data: ctx.data,
      path: ctx.path,
      errorMaps: [
        ctx.common.contextualErrorMap,
        // contextual error map is first priority
        ctx.schemaErrorMap,
        // then schema-bound map if available
        overrideMap,
        // then global override map
        overrideMap === en_default ? void 0 : en_default
        // then global default map
      ].filter((x) => !!x)
    });
    ctx.common.issues.push(issue);
  }
  var ParseStatus = class _ParseStatus {
    constructor() {
      this.value = "valid";
    }
    dirty() {
      if (this.value === "valid")
        this.value = "dirty";
    }
    abort() {
      if (this.value !== "aborted")
        this.value = "aborted";
    }
    static mergeArray(status, results) {
      const arrayValue = [];
      for (const s of results) {
        if (s.status === "aborted")
          return INVALID;
        if (s.status === "dirty")
          status.dirty();
        arrayValue.push(s.value);
      }
      return { status: status.value, value: arrayValue };
    }
    static async mergeObjectAsync(status, pairs) {
      const syncPairs = [];
      for (const pair of pairs) {
        const key = await pair.key;
        const value = await pair.value;
        syncPairs.push({
          key,
          value
        });
      }
      return _ParseStatus.mergeObjectSync(status, syncPairs);
    }
    static mergeObjectSync(status, pairs) {
      const finalObject = {};
      for (const pair of pairs) {
        const { key, value } = pair;
        if (key.status === "aborted")
          return INVALID;
        if (value.status === "aborted")
          return INVALID;
        if (key.status === "dirty")
          status.dirty();
        if (value.status === "dirty")
          status.dirty();
        if (key.value !== "__proto__" && (typeof value.value !== "undefined" || pair.alwaysSet)) {
          finalObject[key.value] = value.value;
        }
      }
      return { status: status.value, value: finalObject };
    }
  };
  var INVALID = Object.freeze({
    status: "aborted"
  });
  var DIRTY = (value) => ({ status: "dirty", value });
  var OK2 = (value) => ({ status: "valid", value });
  var isAborted = (x) => x.status === "aborted";
  var isDirty = (x) => x.status === "dirty";
  var isValid = (x) => x.status === "valid";
  var isAsync = (x) => typeof Promise !== "undefined" && x instanceof Promise;

  // node_modules/zod/v3/helpers/errorUtil.js
  var errorUtil;
  (function(errorUtil2) {
    errorUtil2.errToObj = (message) => typeof message === "string" ? { message } : message || {};
    errorUtil2.toString = (message) => typeof message === "string" ? message : message?.message;
  })(errorUtil || (errorUtil = {}));

  // node_modules/zod/v3/types.js
  var ParseInputLazyPath = class {
    constructor(parent, value, path, key) {
      this._cachedPath = [];
      this.parent = parent;
      this.data = value;
      this._path = path;
      this._key = key;
    }
    get path() {
      if (!this._cachedPath.length) {
        if (Array.isArray(this._key)) {
          this._cachedPath.push(...this._path, ...this._key);
        } else {
          this._cachedPath.push(...this._path, this._key);
        }
      }
      return this._cachedPath;
    }
  };
  var handleResult = (ctx, result) => {
    if (isValid(result)) {
      return { success: true, data: result.value };
    } else {
      if (!ctx.common.issues.length) {
        throw new Error("Validation failed but no issues detected.");
      }
      return {
        success: false,
        get error() {
          if (this._error)
            return this._error;
          const error = new ZodError(ctx.common.issues);
          this._error = error;
          return this._error;
        }
      };
    }
  };
  function processCreateParams(params) {
    if (!params)
      return {};
    const { errorMap: errorMap2, invalid_type_error, required_error, description } = params;
    if (errorMap2 && (invalid_type_error || required_error)) {
      throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
    }
    if (errorMap2)
      return { errorMap: errorMap2, description };
    const customMap = (iss, ctx) => {
      const { message } = params;
      if (iss.code === "invalid_enum_value") {
        return { message: message ?? ctx.defaultError };
      }
      if (typeof ctx.data === "undefined") {
        return { message: message ?? required_error ?? ctx.defaultError };
      }
      if (iss.code !== "invalid_type")
        return { message: ctx.defaultError };
      return { message: message ?? invalid_type_error ?? ctx.defaultError };
    };
    return { errorMap: customMap, description };
  }
  var ZodType = class {
    get description() {
      return this._def.description;
    }
    _getType(input) {
      return getParsedType(input.data);
    }
    _getOrReturnCtx(input, ctx) {
      return ctx || {
        common: input.parent.common,
        data: input.data,
        parsedType: getParsedType(input.data),
        schemaErrorMap: this._def.errorMap,
        path: input.path,
        parent: input.parent
      };
    }
    _processInputParams(input) {
      return {
        status: new ParseStatus(),
        ctx: {
          common: input.parent.common,
          data: input.data,
          parsedType: getParsedType(input.data),
          schemaErrorMap: this._def.errorMap,
          path: input.path,
          parent: input.parent
        }
      };
    }
    _parseSync(input) {
      const result = this._parse(input);
      if (isAsync(result)) {
        throw new Error("Synchronous parse encountered promise.");
      }
      return result;
    }
    _parseAsync(input) {
      const result = this._parse(input);
      return Promise.resolve(result);
    }
    parse(data, params) {
      const result = this.safeParse(data, params);
      if (result.success)
        return result.data;
      throw result.error;
    }
    safeParse(data, params) {
      const ctx = {
        common: {
          issues: [],
          async: params?.async ?? false,
          contextualErrorMap: params?.errorMap
        },
        path: params?.path || [],
        schemaErrorMap: this._def.errorMap,
        parent: null,
        data,
        parsedType: getParsedType(data)
      };
      const result = this._parseSync({ data, path: ctx.path, parent: ctx });
      return handleResult(ctx, result);
    }
    "~validate"(data) {
      const ctx = {
        common: {
          issues: [],
          async: !!this["~standard"].async
        },
        path: [],
        schemaErrorMap: this._def.errorMap,
        parent: null,
        data,
        parsedType: getParsedType(data)
      };
      if (!this["~standard"].async) {
        try {
          const result = this._parseSync({ data, path: [], parent: ctx });
          return isValid(result) ? {
            value: result.value
          } : {
            issues: ctx.common.issues
          };
        } catch (err) {
          if (err?.message?.toLowerCase()?.includes("encountered")) {
            this["~standard"].async = true;
          }
          ctx.common = {
            issues: [],
            async: true
          };
        }
      }
      return this._parseAsync({ data, path: [], parent: ctx }).then((result) => isValid(result) ? {
        value: result.value
      } : {
        issues: ctx.common.issues
      });
    }
    async parseAsync(data, params) {
      const result = await this.safeParseAsync(data, params);
      if (result.success)
        return result.data;
      throw result.error;
    }
    async safeParseAsync(data, params) {
      const ctx = {
        common: {
          issues: [],
          contextualErrorMap: params?.errorMap,
          async: true
        },
        path: params?.path || [],
        schemaErrorMap: this._def.errorMap,
        parent: null,
        data,
        parsedType: getParsedType(data)
      };
      const maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx });
      const result = await (isAsync(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));
      return handleResult(ctx, result);
    }
    refine(check, message) {
      const getIssueProperties = (val) => {
        if (typeof message === "string" || typeof message === "undefined") {
          return { message };
        } else if (typeof message === "function") {
          return message(val);
        } else {
          return message;
        }
      };
      return this._refinement((val, ctx) => {
        const result = check(val);
        const setError = () => ctx.addIssue({
          code: ZodIssueCode.custom,
          ...getIssueProperties(val)
        });
        if (typeof Promise !== "undefined" && result instanceof Promise) {
          return result.then((data) => {
            if (!data) {
              setError();
              return false;
            } else {
              return true;
            }
          });
        }
        if (!result) {
          setError();
          return false;
        } else {
          return true;
        }
      });
    }
    refinement(check, refinementData) {
      return this._refinement((val, ctx) => {
        if (!check(val)) {
          ctx.addIssue(typeof refinementData === "function" ? refinementData(val, ctx) : refinementData);
          return false;
        } else {
          return true;
        }
      });
    }
    _refinement(refinement) {
      return new ZodEffects({
        schema: this,
        typeName: ZodFirstPartyTypeKind.ZodEffects,
        effect: { type: "refinement", refinement }
      });
    }
    superRefine(refinement) {
      return this._refinement(refinement);
    }
    constructor(def) {
      this.spa = this.safeParseAsync;
      this._def = def;
      this.parse = this.parse.bind(this);
      this.safeParse = this.safeParse.bind(this);
      this.parseAsync = this.parseAsync.bind(this);
      this.safeParseAsync = this.safeParseAsync.bind(this);
      this.spa = this.spa.bind(this);
      this.refine = this.refine.bind(this);
      this.refinement = this.refinement.bind(this);
      this.superRefine = this.superRefine.bind(this);
      this.optional = this.optional.bind(this);
      this.nullable = this.nullable.bind(this);
      this.nullish = this.nullish.bind(this);
      this.array = this.array.bind(this);
      this.promise = this.promise.bind(this);
      this.or = this.or.bind(this);
      this.and = this.and.bind(this);
      this.transform = this.transform.bind(this);
      this.brand = this.brand.bind(this);
      this.default = this.default.bind(this);
      this.catch = this.catch.bind(this);
      this.describe = this.describe.bind(this);
      this.pipe = this.pipe.bind(this);
      this.readonly = this.readonly.bind(this);
      this.isNullable = this.isNullable.bind(this);
      this.isOptional = this.isOptional.bind(this);
      this["~standard"] = {
        version: 1,
        vendor: "zod",
        validate: (data) => this["~validate"](data)
      };
    }
    optional() {
      return ZodOptional.create(this, this._def);
    }
    nullable() {
      return ZodNullable.create(this, this._def);
    }
    nullish() {
      return this.nullable().optional();
    }
    array() {
      return ZodArray.create(this);
    }
    promise() {
      return ZodPromise.create(this, this._def);
    }
    or(option) {
      return ZodUnion.create([this, option], this._def);
    }
    and(incoming) {
      return ZodIntersection.create(this, incoming, this._def);
    }
    transform(transform) {
      return new ZodEffects({
        ...processCreateParams(this._def),
        schema: this,
        typeName: ZodFirstPartyTypeKind.ZodEffects,
        effect: { type: "transform", transform }
      });
    }
    default(def) {
      const defaultValueFunc = typeof def === "function" ? def : () => def;
      return new ZodDefault({
        ...processCreateParams(this._def),
        innerType: this,
        defaultValue: defaultValueFunc,
        typeName: ZodFirstPartyTypeKind.ZodDefault
      });
    }
    brand() {
      return new ZodBranded({
        typeName: ZodFirstPartyTypeKind.ZodBranded,
        type: this,
        ...processCreateParams(this._def)
      });
    }
    catch(def) {
      const catchValueFunc = typeof def === "function" ? def : () => def;
      return new ZodCatch({
        ...processCreateParams(this._def),
        innerType: this,
        catchValue: catchValueFunc,
        typeName: ZodFirstPartyTypeKind.ZodCatch
      });
    }
    describe(description) {
      const This = this.constructor;
      return new This({
        ...this._def,
        description
      });
    }
    pipe(target) {
      return ZodPipeline.create(this, target);
    }
    readonly() {
      return ZodReadonly.create(this);
    }
    isOptional() {
      return this.safeParse(void 0).success;
    }
    isNullable() {
      return this.safeParse(null).success;
    }
  };
  var cuidRegex = /^c[^\s-]{8,}$/i;
  var cuid2Regex = /^[0-9a-z]+$/;
  var ulidRegex = /^[0-9A-HJKMNP-TV-Z]{26}$/i;
  var uuidRegex = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i;
  var nanoidRegex = /^[a-z0-9_-]{21}$/i;
  var jwtRegex = /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/;
  var durationRegex = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/;
  var emailRegex = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;
  var _emojiRegex = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
  var emojiRegex;
  var ipv4Regex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
  var ipv4CidrRegex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/;
  var ipv6Regex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/;
  var ipv6CidrRegex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;
  var base64Regex = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/;
  var base64urlRegex = /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/;
  var dateRegexSource = `((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))`;
  var dateRegex = new RegExp(`^${dateRegexSource}$`);
  function timeRegexSource(args) {
    let secondsRegexSource = `[0-5]\\d`;
    if (args.precision) {
      secondsRegexSource = `${secondsRegexSource}\\.\\d{${args.precision}}`;
    } else if (args.precision == null) {
      secondsRegexSource = `${secondsRegexSource}(\\.\\d+)?`;
    }
    const secondsQuantifier = args.precision ? "+" : "?";
    return `([01]\\d|2[0-3]):[0-5]\\d(:${secondsRegexSource})${secondsQuantifier}`;
  }
  function timeRegex(args) {
    return new RegExp(`^${timeRegexSource(args)}$`);
  }
  function datetimeRegex(args) {
    let regex = `${dateRegexSource}T${timeRegexSource(args)}`;
    const opts = [];
    opts.push(args.local ? `Z?` : `Z`);
    if (args.offset)
      opts.push(`([+-]\\d{2}:?\\d{2})`);
    regex = `${regex}(${opts.join("|")})`;
    return new RegExp(`^${regex}$`);
  }
  function isValidIP(ip, version) {
    if ((version === "v4" || !version) && ipv4Regex.test(ip)) {
      return true;
    }
    if ((version === "v6" || !version) && ipv6Regex.test(ip)) {
      return true;
    }
    return false;
  }
  function isValidJWT(jwt, alg) {
    if (!jwtRegex.test(jwt))
      return false;
    try {
      const [header] = jwt.split(".");
      if (!header)
        return false;
      const base64 = header.replace(/-/g, "+").replace(/_/g, "/").padEnd(header.length + (4 - header.length % 4) % 4, "=");
      const decoded = JSON.parse(atob(base64));
      if (typeof decoded !== "object" || decoded === null)
        return false;
      if ("typ" in decoded && decoded?.typ !== "JWT")
        return false;
      if (!decoded.alg)
        return false;
      if (alg && decoded.alg !== alg)
        return false;
      return true;
    } catch {
      return false;
    }
  }
  function isValidCidr(ip, version) {
    if ((version === "v4" || !version) && ipv4CidrRegex.test(ip)) {
      return true;
    }
    if ((version === "v6" || !version) && ipv6CidrRegex.test(ip)) {
      return true;
    }
    return false;
  }
  var ZodString = class _ZodString extends ZodType {
    _parse(input) {
      if (this._def.coerce) {
        input.data = String(input.data);
      }
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.string) {
        const ctx2 = this._getOrReturnCtx(input);
        addIssueToContext(ctx2, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.string,
          received: ctx2.parsedType
        });
        return INVALID;
      }
      const status = new ParseStatus();
      let ctx = void 0;
      for (const check of this._def.checks) {
        if (check.kind === "min") {
          if (input.data.length < check.value) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              minimum: check.value,
              type: "string",
              inclusive: true,
              exact: false,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "max") {
          if (input.data.length > check.value) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              maximum: check.value,
              type: "string",
              inclusive: true,
              exact: false,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "length") {
          const tooBig = input.data.length > check.value;
          const tooSmall = input.data.length < check.value;
          if (tooBig || tooSmall) {
            ctx = this._getOrReturnCtx(input, ctx);
            if (tooBig) {
              addIssueToContext(ctx, {
                code: ZodIssueCode.too_big,
                maximum: check.value,
                type: "string",
                inclusive: true,
                exact: true,
                message: check.message
              });
            } else if (tooSmall) {
              addIssueToContext(ctx, {
                code: ZodIssueCode.too_small,
                minimum: check.value,
                type: "string",
                inclusive: true,
                exact: true,
                message: check.message
              });
            }
            status.dirty();
          }
        } else if (check.kind === "email") {
          if (!emailRegex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "email",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "emoji") {
          if (!emojiRegex) {
            emojiRegex = new RegExp(_emojiRegex, "u");
          }
          if (!emojiRegex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "emoji",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "uuid") {
          if (!uuidRegex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "uuid",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "nanoid") {
          if (!nanoidRegex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "nanoid",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "cuid") {
          if (!cuidRegex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "cuid",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "cuid2") {
          if (!cuid2Regex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "cuid2",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "ulid") {
          if (!ulidRegex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "ulid",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "url") {
          try {
            new URL(input.data);
          } catch {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "url",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "regex") {
          check.regex.lastIndex = 0;
          const testResult = check.regex.test(input.data);
          if (!testResult) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "regex",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "trim") {
          input.data = input.data.trim();
        } else if (check.kind === "includes") {
          if (!input.data.includes(check.value, check.position)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_string,
              validation: { includes: check.value, position: check.position },
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "toLowerCase") {
          input.data = input.data.toLowerCase();
        } else if (check.kind === "toUpperCase") {
          input.data = input.data.toUpperCase();
        } else if (check.kind === "startsWith") {
          if (!input.data.startsWith(check.value)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_string,
              validation: { startsWith: check.value },
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "endsWith") {
          if (!input.data.endsWith(check.value)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_string,
              validation: { endsWith: check.value },
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "datetime") {
          const regex = datetimeRegex(check);
          if (!regex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_string,
              validation: "datetime",
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "date") {
          const regex = dateRegex;
          if (!regex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_string,
              validation: "date",
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "time") {
          const regex = timeRegex(check);
          if (!regex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_string,
              validation: "time",
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "duration") {
          if (!durationRegex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "duration",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "ip") {
          if (!isValidIP(input.data, check.version)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "ip",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "jwt") {
          if (!isValidJWT(input.data, check.alg)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "jwt",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "cidr") {
          if (!isValidCidr(input.data, check.version)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "cidr",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "base64") {
          if (!base64Regex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "base64",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "base64url") {
          if (!base64urlRegex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "base64url",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else {
          util.assertNever(check);
        }
      }
      return { status: status.value, value: input.data };
    }
    _regex(regex, validation, message) {
      return this.refinement((data) => regex.test(data), {
        validation,
        code: ZodIssueCode.invalid_string,
        ...errorUtil.errToObj(message)
      });
    }
    _addCheck(check) {
      return new _ZodString({
        ...this._def,
        checks: [...this._def.checks, check]
      });
    }
    email(message) {
      return this._addCheck({ kind: "email", ...errorUtil.errToObj(message) });
    }
    url(message) {
      return this._addCheck({ kind: "url", ...errorUtil.errToObj(message) });
    }
    emoji(message) {
      return this._addCheck({ kind: "emoji", ...errorUtil.errToObj(message) });
    }
    uuid(message) {
      return this._addCheck({ kind: "uuid", ...errorUtil.errToObj(message) });
    }
    nanoid(message) {
      return this._addCheck({ kind: "nanoid", ...errorUtil.errToObj(message) });
    }
    cuid(message) {
      return this._addCheck({ kind: "cuid", ...errorUtil.errToObj(message) });
    }
    cuid2(message) {
      return this._addCheck({ kind: "cuid2", ...errorUtil.errToObj(message) });
    }
    ulid(message) {
      return this._addCheck({ kind: "ulid", ...errorUtil.errToObj(message) });
    }
    base64(message) {
      return this._addCheck({ kind: "base64", ...errorUtil.errToObj(message) });
    }
    base64url(message) {
      return this._addCheck({
        kind: "base64url",
        ...errorUtil.errToObj(message)
      });
    }
    jwt(options) {
      return this._addCheck({ kind: "jwt", ...errorUtil.errToObj(options) });
    }
    ip(options) {
      return this._addCheck({ kind: "ip", ...errorUtil.errToObj(options) });
    }
    cidr(options) {
      return this._addCheck({ kind: "cidr", ...errorUtil.errToObj(options) });
    }
    datetime(options) {
      if (typeof options === "string") {
        return this._addCheck({
          kind: "datetime",
          precision: null,
          offset: false,
          local: false,
          message: options
        });
      }
      return this._addCheck({
        kind: "datetime",
        precision: typeof options?.precision === "undefined" ? null : options?.precision,
        offset: options?.offset ?? false,
        local: options?.local ?? false,
        ...errorUtil.errToObj(options?.message)
      });
    }
    date(message) {
      return this._addCheck({ kind: "date", message });
    }
    time(options) {
      if (typeof options === "string") {
        return this._addCheck({
          kind: "time",
          precision: null,
          message: options
        });
      }
      return this._addCheck({
        kind: "time",
        precision: typeof options?.precision === "undefined" ? null : options?.precision,
        ...errorUtil.errToObj(options?.message)
      });
    }
    duration(message) {
      return this._addCheck({ kind: "duration", ...errorUtil.errToObj(message) });
    }
    regex(regex, message) {
      return this._addCheck({
        kind: "regex",
        regex,
        ...errorUtil.errToObj(message)
      });
    }
    includes(value, options) {
      return this._addCheck({
        kind: "includes",
        value,
        position: options?.position,
        ...errorUtil.errToObj(options?.message)
      });
    }
    startsWith(value, message) {
      return this._addCheck({
        kind: "startsWith",
        value,
        ...errorUtil.errToObj(message)
      });
    }
    endsWith(value, message) {
      return this._addCheck({
        kind: "endsWith",
        value,
        ...errorUtil.errToObj(message)
      });
    }
    min(minLength, message) {
      return this._addCheck({
        kind: "min",
        value: minLength,
        ...errorUtil.errToObj(message)
      });
    }
    max(maxLength, message) {
      return this._addCheck({
        kind: "max",
        value: maxLength,
        ...errorUtil.errToObj(message)
      });
    }
    length(len, message) {
      return this._addCheck({
        kind: "length",
        value: len,
        ...errorUtil.errToObj(message)
      });
    }
    /**
     * Equivalent to `.min(1)`
     */
    nonempty(message) {
      return this.min(1, errorUtil.errToObj(message));
    }
    trim() {
      return new _ZodString({
        ...this._def,
        checks: [...this._def.checks, { kind: "trim" }]
      });
    }
    toLowerCase() {
      return new _ZodString({
        ...this._def,
        checks: [...this._def.checks, { kind: "toLowerCase" }]
      });
    }
    toUpperCase() {
      return new _ZodString({
        ...this._def,
        checks: [...this._def.checks, { kind: "toUpperCase" }]
      });
    }
    get isDatetime() {
      return !!this._def.checks.find((ch) => ch.kind === "datetime");
    }
    get isDate() {
      return !!this._def.checks.find((ch) => ch.kind === "date");
    }
    get isTime() {
      return !!this._def.checks.find((ch) => ch.kind === "time");
    }
    get isDuration() {
      return !!this._def.checks.find((ch) => ch.kind === "duration");
    }
    get isEmail() {
      return !!this._def.checks.find((ch) => ch.kind === "email");
    }
    get isURL() {
      return !!this._def.checks.find((ch) => ch.kind === "url");
    }
    get isEmoji() {
      return !!this._def.checks.find((ch) => ch.kind === "emoji");
    }
    get isUUID() {
      return !!this._def.checks.find((ch) => ch.kind === "uuid");
    }
    get isNANOID() {
      return !!this._def.checks.find((ch) => ch.kind === "nanoid");
    }
    get isCUID() {
      return !!this._def.checks.find((ch) => ch.kind === "cuid");
    }
    get isCUID2() {
      return !!this._def.checks.find((ch) => ch.kind === "cuid2");
    }
    get isULID() {
      return !!this._def.checks.find((ch) => ch.kind === "ulid");
    }
    get isIP() {
      return !!this._def.checks.find((ch) => ch.kind === "ip");
    }
    get isCIDR() {
      return !!this._def.checks.find((ch) => ch.kind === "cidr");
    }
    get isBase64() {
      return !!this._def.checks.find((ch) => ch.kind === "base64");
    }
    get isBase64url() {
      return !!this._def.checks.find((ch) => ch.kind === "base64url");
    }
    get minLength() {
      let min = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "min") {
          if (min === null || ch.value > min)
            min = ch.value;
        }
      }
      return min;
    }
    get maxLength() {
      let max = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "max") {
          if (max === null || ch.value < max)
            max = ch.value;
        }
      }
      return max;
    }
  };
  ZodString.create = (params) => {
    return new ZodString({
      checks: [],
      typeName: ZodFirstPartyTypeKind.ZodString,
      coerce: params?.coerce ?? false,
      ...processCreateParams(params)
    });
  };
  function floatSafeRemainder(val, step) {
    const valDecCount = (val.toString().split(".")[1] || "").length;
    const stepDecCount = (step.toString().split(".")[1] || "").length;
    const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
    const valInt = Number.parseInt(val.toFixed(decCount).replace(".", ""));
    const stepInt = Number.parseInt(step.toFixed(decCount).replace(".", ""));
    return valInt % stepInt / 10 ** decCount;
  }
  var ZodNumber = class _ZodNumber extends ZodType {
    constructor() {
      super(...arguments);
      this.min = this.gte;
      this.max = this.lte;
      this.step = this.multipleOf;
    }
    _parse(input) {
      if (this._def.coerce) {
        input.data = Number(input.data);
      }
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.number) {
        const ctx2 = this._getOrReturnCtx(input);
        addIssueToContext(ctx2, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.number,
          received: ctx2.parsedType
        });
        return INVALID;
      }
      let ctx = void 0;
      const status = new ParseStatus();
      for (const check of this._def.checks) {
        if (check.kind === "int") {
          if (!util.isInteger(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_type,
              expected: "integer",
              received: "float",
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "min") {
          const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
          if (tooSmall) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              minimum: check.value,
              type: "number",
              inclusive: check.inclusive,
              exact: false,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "max") {
          const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
          if (tooBig) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              maximum: check.value,
              type: "number",
              inclusive: check.inclusive,
              exact: false,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "multipleOf") {
          if (floatSafeRemainder(input.data, check.value) !== 0) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.not_multiple_of,
              multipleOf: check.value,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "finite") {
          if (!Number.isFinite(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.not_finite,
              message: check.message
            });
            status.dirty();
          }
        } else {
          util.assertNever(check);
        }
      }
      return { status: status.value, value: input.data };
    }
    gte(value, message) {
      return this.setLimit("min", value, true, errorUtil.toString(message));
    }
    gt(value, message) {
      return this.setLimit("min", value, false, errorUtil.toString(message));
    }
    lte(value, message) {
      return this.setLimit("max", value, true, errorUtil.toString(message));
    }
    lt(value, message) {
      return this.setLimit("max", value, false, errorUtil.toString(message));
    }
    setLimit(kind, value, inclusive, message) {
      return new _ZodNumber({
        ...this._def,
        checks: [
          ...this._def.checks,
          {
            kind,
            value,
            inclusive,
            message: errorUtil.toString(message)
          }
        ]
      });
    }
    _addCheck(check) {
      return new _ZodNumber({
        ...this._def,
        checks: [...this._def.checks, check]
      });
    }
    int(message) {
      return this._addCheck({
        kind: "int",
        message: errorUtil.toString(message)
      });
    }
    positive(message) {
      return this._addCheck({
        kind: "min",
        value: 0,
        inclusive: false,
        message: errorUtil.toString(message)
      });
    }
    negative(message) {
      return this._addCheck({
        kind: "max",
        value: 0,
        inclusive: false,
        message: errorUtil.toString(message)
      });
    }
    nonpositive(message) {
      return this._addCheck({
        kind: "max",
        value: 0,
        inclusive: true,
        message: errorUtil.toString(message)
      });
    }
    nonnegative(message) {
      return this._addCheck({
        kind: "min",
        value: 0,
        inclusive: true,
        message: errorUtil.toString(message)
      });
    }
    multipleOf(value, message) {
      return this._addCheck({
        kind: "multipleOf",
        value,
        message: errorUtil.toString(message)
      });
    }
    finite(message) {
      return this._addCheck({
        kind: "finite",
        message: errorUtil.toString(message)
      });
    }
    safe(message) {
      return this._addCheck({
        kind: "min",
        inclusive: true,
        value: Number.MIN_SAFE_INTEGER,
        message: errorUtil.toString(message)
      })._addCheck({
        kind: "max",
        inclusive: true,
        value: Number.MAX_SAFE_INTEGER,
        message: errorUtil.toString(message)
      });
    }
    get minValue() {
      let min = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "min") {
          if (min === null || ch.value > min)
            min = ch.value;
        }
      }
      return min;
    }
    get maxValue() {
      let max = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "max") {
          if (max === null || ch.value < max)
            max = ch.value;
        }
      }
      return max;
    }
    get isInt() {
      return !!this._def.checks.find((ch) => ch.kind === "int" || ch.kind === "multipleOf" && util.isInteger(ch.value));
    }
    get isFinite() {
      let max = null;
      let min = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "finite" || ch.kind === "int" || ch.kind === "multipleOf") {
          return true;
        } else if (ch.kind === "min") {
          if (min === null || ch.value > min)
            min = ch.value;
        } else if (ch.kind === "max") {
          if (max === null || ch.value < max)
            max = ch.value;
        }
      }
      return Number.isFinite(min) && Number.isFinite(max);
    }
  };
  ZodNumber.create = (params) => {
    return new ZodNumber({
      checks: [],
      typeName: ZodFirstPartyTypeKind.ZodNumber,
      coerce: params?.coerce || false,
      ...processCreateParams(params)
    });
  };
  var ZodBigInt = class _ZodBigInt extends ZodType {
    constructor() {
      super(...arguments);
      this.min = this.gte;
      this.max = this.lte;
    }
    _parse(input) {
      if (this._def.coerce) {
        try {
          input.data = BigInt(input.data);
        } catch {
          return this._getInvalidInput(input);
        }
      }
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.bigint) {
        return this._getInvalidInput(input);
      }
      let ctx = void 0;
      const status = new ParseStatus();
      for (const check of this._def.checks) {
        if (check.kind === "min") {
          const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
          if (tooSmall) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              type: "bigint",
              minimum: check.value,
              inclusive: check.inclusive,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "max") {
          const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
          if (tooBig) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              type: "bigint",
              maximum: check.value,
              inclusive: check.inclusive,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "multipleOf") {
          if (input.data % check.value !== BigInt(0)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.not_multiple_of,
              multipleOf: check.value,
              message: check.message
            });
            status.dirty();
          }
        } else {
          util.assertNever(check);
        }
      }
      return { status: status.value, value: input.data };
    }
    _getInvalidInput(input) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.bigint,
        received: ctx.parsedType
      });
      return INVALID;
    }
    gte(value, message) {
      return this.setLimit("min", value, true, errorUtil.toString(message));
    }
    gt(value, message) {
      return this.setLimit("min", value, false, errorUtil.toString(message));
    }
    lte(value, message) {
      return this.setLimit("max", value, true, errorUtil.toString(message));
    }
    lt(value, message) {
      return this.setLimit("max", value, false, errorUtil.toString(message));
    }
    setLimit(kind, value, inclusive, message) {
      return new _ZodBigInt({
        ...this._def,
        checks: [
          ...this._def.checks,
          {
            kind,
            value,
            inclusive,
            message: errorUtil.toString(message)
          }
        ]
      });
    }
    _addCheck(check) {
      return new _ZodBigInt({
        ...this._def,
        checks: [...this._def.checks, check]
      });
    }
    positive(message) {
      return this._addCheck({
        kind: "min",
        value: BigInt(0),
        inclusive: false,
        message: errorUtil.toString(message)
      });
    }
    negative(message) {
      return this._addCheck({
        kind: "max",
        value: BigInt(0),
        inclusive: false,
        message: errorUtil.toString(message)
      });
    }
    nonpositive(message) {
      return this._addCheck({
        kind: "max",
        value: BigInt(0),
        inclusive: true,
        message: errorUtil.toString(message)
      });
    }
    nonnegative(message) {
      return this._addCheck({
        kind: "min",
        value: BigInt(0),
        inclusive: true,
        message: errorUtil.toString(message)
      });
    }
    multipleOf(value, message) {
      return this._addCheck({
        kind: "multipleOf",
        value,
        message: errorUtil.toString(message)
      });
    }
    get minValue() {
      let min = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "min") {
          if (min === null || ch.value > min)
            min = ch.value;
        }
      }
      return min;
    }
    get maxValue() {
      let max = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "max") {
          if (max === null || ch.value < max)
            max = ch.value;
        }
      }
      return max;
    }
  };
  ZodBigInt.create = (params) => {
    return new ZodBigInt({
      checks: [],
      typeName: ZodFirstPartyTypeKind.ZodBigInt,
      coerce: params?.coerce ?? false,
      ...processCreateParams(params)
    });
  };
  var ZodBoolean = class extends ZodType {
    _parse(input) {
      if (this._def.coerce) {
        input.data = Boolean(input.data);
      }
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.boolean) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.boolean,
          received: ctx.parsedType
        });
        return INVALID;
      }
      return OK2(input.data);
    }
  };
  ZodBoolean.create = (params) => {
    return new ZodBoolean({
      typeName: ZodFirstPartyTypeKind.ZodBoolean,
      coerce: params?.coerce || false,
      ...processCreateParams(params)
    });
  };
  var ZodDate = class _ZodDate extends ZodType {
    _parse(input) {
      if (this._def.coerce) {
        input.data = new Date(input.data);
      }
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.date) {
        const ctx2 = this._getOrReturnCtx(input);
        addIssueToContext(ctx2, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.date,
          received: ctx2.parsedType
        });
        return INVALID;
      }
      if (Number.isNaN(input.data.getTime())) {
        const ctx2 = this._getOrReturnCtx(input);
        addIssueToContext(ctx2, {
          code: ZodIssueCode.invalid_date
        });
        return INVALID;
      }
      const status = new ParseStatus();
      let ctx = void 0;
      for (const check of this._def.checks) {
        if (check.kind === "min") {
          if (input.data.getTime() < check.value) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              message: check.message,
              inclusive: true,
              exact: false,
              minimum: check.value,
              type: "date"
            });
            status.dirty();
          }
        } else if (check.kind === "max") {
          if (input.data.getTime() > check.value) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              message: check.message,
              inclusive: true,
              exact: false,
              maximum: check.value,
              type: "date"
            });
            status.dirty();
          }
        } else {
          util.assertNever(check);
        }
      }
      return {
        status: status.value,
        value: new Date(input.data.getTime())
      };
    }
    _addCheck(check) {
      return new _ZodDate({
        ...this._def,
        checks: [...this._def.checks, check]
      });
    }
    min(minDate, message) {
      return this._addCheck({
        kind: "min",
        value: minDate.getTime(),
        message: errorUtil.toString(message)
      });
    }
    max(maxDate, message) {
      return this._addCheck({
        kind: "max",
        value: maxDate.getTime(),
        message: errorUtil.toString(message)
      });
    }
    get minDate() {
      let min = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "min") {
          if (min === null || ch.value > min)
            min = ch.value;
        }
      }
      return min != null ? new Date(min) : null;
    }
    get maxDate() {
      let max = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "max") {
          if (max === null || ch.value < max)
            max = ch.value;
        }
      }
      return max != null ? new Date(max) : null;
    }
  };
  ZodDate.create = (params) => {
    return new ZodDate({
      checks: [],
      coerce: params?.coerce || false,
      typeName: ZodFirstPartyTypeKind.ZodDate,
      ...processCreateParams(params)
    });
  };
  var ZodSymbol = class extends ZodType {
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.symbol) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.symbol,
          received: ctx.parsedType
        });
        return INVALID;
      }
      return OK2(input.data);
    }
  };
  ZodSymbol.create = (params) => {
    return new ZodSymbol({
      typeName: ZodFirstPartyTypeKind.ZodSymbol,
      ...processCreateParams(params)
    });
  };
  var ZodUndefined = class extends ZodType {
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.undefined) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.undefined,
          received: ctx.parsedType
        });
        return INVALID;
      }
      return OK2(input.data);
    }
  };
  ZodUndefined.create = (params) => {
    return new ZodUndefined({
      typeName: ZodFirstPartyTypeKind.ZodUndefined,
      ...processCreateParams(params)
    });
  };
  var ZodNull = class extends ZodType {
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.null) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.null,
          received: ctx.parsedType
        });
        return INVALID;
      }
      return OK2(input.data);
    }
  };
  ZodNull.create = (params) => {
    return new ZodNull({
      typeName: ZodFirstPartyTypeKind.ZodNull,
      ...processCreateParams(params)
    });
  };
  var ZodAny = class extends ZodType {
    constructor() {
      super(...arguments);
      this._any = true;
    }
    _parse(input) {
      return OK2(input.data);
    }
  };
  ZodAny.create = (params) => {
    return new ZodAny({
      typeName: ZodFirstPartyTypeKind.ZodAny,
      ...processCreateParams(params)
    });
  };
  var ZodUnknown = class extends ZodType {
    constructor() {
      super(...arguments);
      this._unknown = true;
    }
    _parse(input) {
      return OK2(input.data);
    }
  };
  ZodUnknown.create = (params) => {
    return new ZodUnknown({
      typeName: ZodFirstPartyTypeKind.ZodUnknown,
      ...processCreateParams(params)
    });
  };
  var ZodNever = class extends ZodType {
    _parse(input) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.never,
        received: ctx.parsedType
      });
      return INVALID;
    }
  };
  ZodNever.create = (params) => {
    return new ZodNever({
      typeName: ZodFirstPartyTypeKind.ZodNever,
      ...processCreateParams(params)
    });
  };
  var ZodVoid = class extends ZodType {
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.undefined) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.void,
          received: ctx.parsedType
        });
        return INVALID;
      }
      return OK2(input.data);
    }
  };
  ZodVoid.create = (params) => {
    return new ZodVoid({
      typeName: ZodFirstPartyTypeKind.ZodVoid,
      ...processCreateParams(params)
    });
  };
  var ZodArray = class _ZodArray extends ZodType {
    _parse(input) {
      const { ctx, status } = this._processInputParams(input);
      const def = this._def;
      if (ctx.parsedType !== ZodParsedType.array) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.array,
          received: ctx.parsedType
        });
        return INVALID;
      }
      if (def.exactLength !== null) {
        const tooBig = ctx.data.length > def.exactLength.value;
        const tooSmall = ctx.data.length < def.exactLength.value;
        if (tooBig || tooSmall) {
          addIssueToContext(ctx, {
            code: tooBig ? ZodIssueCode.too_big : ZodIssueCode.too_small,
            minimum: tooSmall ? def.exactLength.value : void 0,
            maximum: tooBig ? def.exactLength.value : void 0,
            type: "array",
            inclusive: true,
            exact: true,
            message: def.exactLength.message
          });
          status.dirty();
        }
      }
      if (def.minLength !== null) {
        if (ctx.data.length < def.minLength.value) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: def.minLength.value,
            type: "array",
            inclusive: true,
            exact: false,
            message: def.minLength.message
          });
          status.dirty();
        }
      }
      if (def.maxLength !== null) {
        if (ctx.data.length > def.maxLength.value) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: def.maxLength.value,
            type: "array",
            inclusive: true,
            exact: false,
            message: def.maxLength.message
          });
          status.dirty();
        }
      }
      if (ctx.common.async) {
        return Promise.all([...ctx.data].map((item, i) => {
          return def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i));
        })).then((result2) => {
          return ParseStatus.mergeArray(status, result2);
        });
      }
      const result = [...ctx.data].map((item, i) => {
        return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i));
      });
      return ParseStatus.mergeArray(status, result);
    }
    get element() {
      return this._def.type;
    }
    min(minLength, message) {
      return new _ZodArray({
        ...this._def,
        minLength: { value: minLength, message: errorUtil.toString(message) }
      });
    }
    max(maxLength, message) {
      return new _ZodArray({
        ...this._def,
        maxLength: { value: maxLength, message: errorUtil.toString(message) }
      });
    }
    length(len, message) {
      return new _ZodArray({
        ...this._def,
        exactLength: { value: len, message: errorUtil.toString(message) }
      });
    }
    nonempty(message) {
      return this.min(1, message);
    }
  };
  ZodArray.create = (schema, params) => {
    return new ZodArray({
      type: schema,
      minLength: null,
      maxLength: null,
      exactLength: null,
      typeName: ZodFirstPartyTypeKind.ZodArray,
      ...processCreateParams(params)
    });
  };
  function deepPartialify(schema) {
    if (schema instanceof ZodObject) {
      const newShape = {};
      for (const key in schema.shape) {
        const fieldSchema = schema.shape[key];
        newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));
      }
      return new ZodObject({
        ...schema._def,
        shape: () => newShape
      });
    } else if (schema instanceof ZodArray) {
      return new ZodArray({
        ...schema._def,
        type: deepPartialify(schema.element)
      });
    } else if (schema instanceof ZodOptional) {
      return ZodOptional.create(deepPartialify(schema.unwrap()));
    } else if (schema instanceof ZodNullable) {
      return ZodNullable.create(deepPartialify(schema.unwrap()));
    } else if (schema instanceof ZodTuple) {
      return ZodTuple.create(schema.items.map((item) => deepPartialify(item)));
    } else {
      return schema;
    }
  }
  var ZodObject = class _ZodObject extends ZodType {
    constructor() {
      super(...arguments);
      this._cached = null;
      this.nonstrict = this.passthrough;
      this.augment = this.extend;
    }
    _getCached() {
      if (this._cached !== null)
        return this._cached;
      const shape = this._def.shape();
      const keys = util.objectKeys(shape);
      this._cached = { shape, keys };
      return this._cached;
    }
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.object) {
        const ctx2 = this._getOrReturnCtx(input);
        addIssueToContext(ctx2, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.object,
          received: ctx2.parsedType
        });
        return INVALID;
      }
      const { status, ctx } = this._processInputParams(input);
      const { shape, keys: shapeKeys } = this._getCached();
      const extraKeys = [];
      if (!(this._def.catchall instanceof ZodNever && this._def.unknownKeys === "strip")) {
        for (const key in ctx.data) {
          if (!shapeKeys.includes(key)) {
            extraKeys.push(key);
          }
        }
      }
      const pairs = [];
      for (const key of shapeKeys) {
        const keyValidator = shape[key];
        const value = ctx.data[key];
        pairs.push({
          key: { status: "valid", value: key },
          value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),
          alwaysSet: key in ctx.data
        });
      }
      if (this._def.catchall instanceof ZodNever) {
        const unknownKeys = this._def.unknownKeys;
        if (unknownKeys === "passthrough") {
          for (const key of extraKeys) {
            pairs.push({
              key: { status: "valid", value: key },
              value: { status: "valid", value: ctx.data[key] }
            });
          }
        } else if (unknownKeys === "strict") {
          if (extraKeys.length > 0) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.unrecognized_keys,
              keys: extraKeys
            });
            status.dirty();
          }
        } else if (unknownKeys === "strip") {
        } else {
          throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
        }
      } else {
        const catchall = this._def.catchall;
        for (const key of extraKeys) {
          const value = ctx.data[key];
          pairs.push({
            key: { status: "valid", value: key },
            value: catchall._parse(
              new ParseInputLazyPath(ctx, value, ctx.path, key)
              //, ctx.child(key), value, getParsedType(value)
            ),
            alwaysSet: key in ctx.data
          });
        }
      }
      if (ctx.common.async) {
        return Promise.resolve().then(async () => {
          const syncPairs = [];
          for (const pair of pairs) {
            const key = await pair.key;
            const value = await pair.value;
            syncPairs.push({
              key,
              value,
              alwaysSet: pair.alwaysSet
            });
          }
          return syncPairs;
        }).then((syncPairs) => {
          return ParseStatus.mergeObjectSync(status, syncPairs);
        });
      } else {
        return ParseStatus.mergeObjectSync(status, pairs);
      }
    }
    get shape() {
      return this._def.shape();
    }
    strict(message) {
      errorUtil.errToObj;
      return new _ZodObject({
        ...this._def,
        unknownKeys: "strict",
        ...message !== void 0 ? {
          errorMap: (issue, ctx) => {
            const defaultError = this._def.errorMap?.(issue, ctx).message ?? ctx.defaultError;
            if (issue.code === "unrecognized_keys")
              return {
                message: errorUtil.errToObj(message).message ?? defaultError
              };
            return {
              message: defaultError
            };
          }
        } : {}
      });
    }
    strip() {
      return new _ZodObject({
        ...this._def,
        unknownKeys: "strip"
      });
    }
    passthrough() {
      return new _ZodObject({
        ...this._def,
        unknownKeys: "passthrough"
      });
    }
    // const AugmentFactory =
    //   <Def extends ZodObjectDef>(def: Def) =>
    //   <Augmentation extends ZodRawShape>(
    //     augmentation: Augmentation
    //   ): ZodObject<
    //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
    //     Def["unknownKeys"],
    //     Def["catchall"]
    //   > => {
    //     return new ZodObject({
    //       ...def,
    //       shape: () => ({
    //         ...def.shape(),
    //         ...augmentation,
    //       }),
    //     }) as any;
    //   };
    extend(augmentation) {
      return new _ZodObject({
        ...this._def,
        shape: () => ({
          ...this._def.shape(),
          ...augmentation
        })
      });
    }
    /**
     * Prior to zod@1.0.12 there was a bug in the
     * inferred type of merged objects. Please
     * upgrade if you are experiencing issues.
     */
    merge(merging) {
      const merged = new _ZodObject({
        unknownKeys: merging._def.unknownKeys,
        catchall: merging._def.catchall,
        shape: () => ({
          ...this._def.shape(),
          ...merging._def.shape()
        }),
        typeName: ZodFirstPartyTypeKind.ZodObject
      });
      return merged;
    }
    // merge<
    //   Incoming extends AnyZodObject,
    //   Augmentation extends Incoming["shape"],
    //   NewOutput extends {
    //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
    //       ? Augmentation[k]["_output"]
    //       : k extends keyof Output
    //       ? Output[k]
    //       : never;
    //   },
    //   NewInput extends {
    //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
    //       ? Augmentation[k]["_input"]
    //       : k extends keyof Input
    //       ? Input[k]
    //       : never;
    //   }
    // >(
    //   merging: Incoming
    // ): ZodObject<
    //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
    //   Incoming["_def"]["unknownKeys"],
    //   Incoming["_def"]["catchall"],
    //   NewOutput,
    //   NewInput
    // > {
    //   const merged: any = new ZodObject({
    //     unknownKeys: merging._def.unknownKeys,
    //     catchall: merging._def.catchall,
    //     shape: () =>
    //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
    //     typeName: ZodFirstPartyTypeKind.ZodObject,
    //   }) as any;
    //   return merged;
    // }
    setKey(key, schema) {
      return this.augment({ [key]: schema });
    }
    // merge<Incoming extends AnyZodObject>(
    //   merging: Incoming
    // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
    // ZodObject<
    //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
    //   Incoming["_def"]["unknownKeys"],
    //   Incoming["_def"]["catchall"]
    // > {
    //   // const mergedShape = objectUtil.mergeShapes(
    //   //   this._def.shape(),
    //   //   merging._def.shape()
    //   // );
    //   const merged: any = new ZodObject({
    //     unknownKeys: merging._def.unknownKeys,
    //     catchall: merging._def.catchall,
    //     shape: () =>
    //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
    //     typeName: ZodFirstPartyTypeKind.ZodObject,
    //   }) as any;
    //   return merged;
    // }
    catchall(index) {
      return new _ZodObject({
        ...this._def,
        catchall: index
      });
    }
    pick(mask) {
      const shape = {};
      for (const key of util.objectKeys(mask)) {
        if (mask[key] && this.shape[key]) {
          shape[key] = this.shape[key];
        }
      }
      return new _ZodObject({
        ...this._def,
        shape: () => shape
      });
    }
    omit(mask) {
      const shape = {};
      for (const key of util.objectKeys(this.shape)) {
        if (!mask[key]) {
          shape[key] = this.shape[key];
        }
      }
      return new _ZodObject({
        ...this._def,
        shape: () => shape
      });
    }
    /**
     * @deprecated
     */
    deepPartial() {
      return deepPartialify(this);
    }
    partial(mask) {
      const newShape = {};
      for (const key of util.objectKeys(this.shape)) {
        const fieldSchema = this.shape[key];
        if (mask && !mask[key]) {
          newShape[key] = fieldSchema;
        } else {
          newShape[key] = fieldSchema.optional();
        }
      }
      return new _ZodObject({
        ...this._def,
        shape: () => newShape
      });
    }
    required(mask) {
      const newShape = {};
      for (const key of util.objectKeys(this.shape)) {
        if (mask && !mask[key]) {
          newShape[key] = this.shape[key];
        } else {
          const fieldSchema = this.shape[key];
          let newField = fieldSchema;
          while (newField instanceof ZodOptional) {
            newField = newField._def.innerType;
          }
          newShape[key] = newField;
        }
      }
      return new _ZodObject({
        ...this._def,
        shape: () => newShape
      });
    }
    keyof() {
      return createZodEnum(util.objectKeys(this.shape));
    }
  };
  ZodObject.create = (shape, params) => {
    return new ZodObject({
      shape: () => shape,
      unknownKeys: "strip",
      catchall: ZodNever.create(),
      typeName: ZodFirstPartyTypeKind.ZodObject,
      ...processCreateParams(params)
    });
  };
  ZodObject.strictCreate = (shape, params) => {
    return new ZodObject({
      shape: () => shape,
      unknownKeys: "strict",
      catchall: ZodNever.create(),
      typeName: ZodFirstPartyTypeKind.ZodObject,
      ...processCreateParams(params)
    });
  };
  ZodObject.lazycreate = (shape, params) => {
    return new ZodObject({
      shape,
      unknownKeys: "strip",
      catchall: ZodNever.create(),
      typeName: ZodFirstPartyTypeKind.ZodObject,
      ...processCreateParams(params)
    });
  };
  var ZodUnion = class extends ZodType {
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      const options = this._def.options;
      function handleResults(results) {
        for (const result of results) {
          if (result.result.status === "valid") {
            return result.result;
          }
        }
        for (const result of results) {
          if (result.result.status === "dirty") {
            ctx.common.issues.push(...result.ctx.common.issues);
            return result.result;
          }
        }
        const unionErrors = results.map((result) => new ZodError(result.ctx.common.issues));
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_union,
          unionErrors
        });
        return INVALID;
      }
      if (ctx.common.async) {
        return Promise.all(options.map(async (option) => {
          const childCtx = {
            ...ctx,
            common: {
              ...ctx.common,
              issues: []
            },
            parent: null
          };
          return {
            result: await option._parseAsync({
              data: ctx.data,
              path: ctx.path,
              parent: childCtx
            }),
            ctx: childCtx
          };
        })).then(handleResults);
      } else {
        let dirty = void 0;
        const issues = [];
        for (const option of options) {
          const childCtx = {
            ...ctx,
            common: {
              ...ctx.common,
              issues: []
            },
            parent: null
          };
          const result = option._parseSync({
            data: ctx.data,
            path: ctx.path,
            parent: childCtx
          });
          if (result.status === "valid") {
            return result;
          } else if (result.status === "dirty" && !dirty) {
            dirty = { result, ctx: childCtx };
          }
          if (childCtx.common.issues.length) {
            issues.push(childCtx.common.issues);
          }
        }
        if (dirty) {
          ctx.common.issues.push(...dirty.ctx.common.issues);
          return dirty.result;
        }
        const unionErrors = issues.map((issues2) => new ZodError(issues2));
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_union,
          unionErrors
        });
        return INVALID;
      }
    }
    get options() {
      return this._def.options;
    }
  };
  ZodUnion.create = (types, params) => {
    return new ZodUnion({
      options: types,
      typeName: ZodFirstPartyTypeKind.ZodUnion,
      ...processCreateParams(params)
    });
  };
  var getDiscriminator = (type) => {
    if (type instanceof ZodLazy) {
      return getDiscriminator(type.schema);
    } else if (type instanceof ZodEffects) {
      return getDiscriminator(type.innerType());
    } else if (type instanceof ZodLiteral) {
      return [type.value];
    } else if (type instanceof ZodEnum) {
      return type.options;
    } else if (type instanceof ZodNativeEnum) {
      return util.objectValues(type.enum);
    } else if (type instanceof ZodDefault) {
      return getDiscriminator(type._def.innerType);
    } else if (type instanceof ZodUndefined) {
      return [void 0];
    } else if (type instanceof ZodNull) {
      return [null];
    } else if (type instanceof ZodOptional) {
      return [void 0, ...getDiscriminator(type.unwrap())];
    } else if (type instanceof ZodNullable) {
      return [null, ...getDiscriminator(type.unwrap())];
    } else if (type instanceof ZodBranded) {
      return getDiscriminator(type.unwrap());
    } else if (type instanceof ZodReadonly) {
      return getDiscriminator(type.unwrap());
    } else if (type instanceof ZodCatch) {
      return getDiscriminator(type._def.innerType);
    } else {
      return [];
    }
  };
  var ZodDiscriminatedUnion = class _ZodDiscriminatedUnion extends ZodType {
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      if (ctx.parsedType !== ZodParsedType.object) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.object,
          received: ctx.parsedType
        });
        return INVALID;
      }
      const discriminator = this.discriminator;
      const discriminatorValue = ctx.data[discriminator];
      const option = this.optionsMap.get(discriminatorValue);
      if (!option) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_union_discriminator,
          options: Array.from(this.optionsMap.keys()),
          path: [discriminator]
        });
        return INVALID;
      }
      if (ctx.common.async) {
        return option._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
      } else {
        return option._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
      }
    }
    get discriminator() {
      return this._def.discriminator;
    }
    get options() {
      return this._def.options;
    }
    get optionsMap() {
      return this._def.optionsMap;
    }
    /**
     * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
     * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
     * have a different value for each object in the union.
     * @param discriminator the name of the discriminator property
     * @param types an array of object schemas
     * @param params
     */
    static create(discriminator, options, params) {
      const optionsMap = /* @__PURE__ */ new Map();
      for (const type of options) {
        const discriminatorValues = getDiscriminator(type.shape[discriminator]);
        if (!discriminatorValues.length) {
          throw new Error(`A discriminator value for key \`${discriminator}\` could not be extracted from all schema options`);
        }
        for (const value of discriminatorValues) {
          if (optionsMap.has(value)) {
            throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);
          }
          optionsMap.set(value, type);
        }
      }
      return new _ZodDiscriminatedUnion({
        typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,
        discriminator,
        options,
        optionsMap,
        ...processCreateParams(params)
      });
    }
  };
  function mergeValues(a, b) {
    const aType = getParsedType(a);
    const bType = getParsedType(b);
    if (a === b) {
      return { valid: true, data: a };
    } else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {
      const bKeys = util.objectKeys(b);
      const sharedKeys = util.objectKeys(a).filter((key) => bKeys.indexOf(key) !== -1);
      const newObj = { ...a, ...b };
      for (const key of sharedKeys) {
        const sharedValue = mergeValues(a[key], b[key]);
        if (!sharedValue.valid) {
          return { valid: false };
        }
        newObj[key] = sharedValue.data;
      }
      return { valid: true, data: newObj };
    } else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {
      if (a.length !== b.length) {
        return { valid: false };
      }
      const newArray = [];
      for (let index = 0; index < a.length; index++) {
        const itemA = a[index];
        const itemB = b[index];
        const sharedValue = mergeValues(itemA, itemB);
        if (!sharedValue.valid) {
          return { valid: false };
        }
        newArray.push(sharedValue.data);
      }
      return { valid: true, data: newArray };
    } else if (aType === ZodParsedType.date && bType === ZodParsedType.date && +a === +b) {
      return { valid: true, data: a };
    } else {
      return { valid: false };
    }
  }
  var ZodIntersection = class extends ZodType {
    _parse(input) {
      const { status, ctx } = this._processInputParams(input);
      const handleParsed = (parsedLeft, parsedRight) => {
        if (isAborted(parsedLeft) || isAborted(parsedRight)) {
          return INVALID;
        }
        const merged = mergeValues(parsedLeft.value, parsedRight.value);
        if (!merged.valid) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_intersection_types
          });
          return INVALID;
        }
        if (isDirty(parsedLeft) || isDirty(parsedRight)) {
          status.dirty();
        }
        return { status: status.value, value: merged.data };
      };
      if (ctx.common.async) {
        return Promise.all([
          this._def.left._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          }),
          this._def.right._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          })
        ]).then(([left, right]) => handleParsed(left, right));
      } else {
        return handleParsed(this._def.left._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        }), this._def.right._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        }));
      }
    }
  };
  ZodIntersection.create = (left, right, params) => {
    return new ZodIntersection({
      left,
      right,
      typeName: ZodFirstPartyTypeKind.ZodIntersection,
      ...processCreateParams(params)
    });
  };
  var ZodTuple = class _ZodTuple extends ZodType {
    _parse(input) {
      const { status, ctx } = this._processInputParams(input);
      if (ctx.parsedType !== ZodParsedType.array) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.array,
          received: ctx.parsedType
        });
        return INVALID;
      }
      if (ctx.data.length < this._def.items.length) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: this._def.items.length,
          inclusive: true,
          exact: false,
          type: "array"
        });
        return INVALID;
      }
      const rest = this._def.rest;
      if (!rest && ctx.data.length > this._def.items.length) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: this._def.items.length,
          inclusive: true,
          exact: false,
          type: "array"
        });
        status.dirty();
      }
      const items = [...ctx.data].map((item, itemIndex) => {
        const schema = this._def.items[itemIndex] || this._def.rest;
        if (!schema)
          return null;
        return schema._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));
      }).filter((x) => !!x);
      if (ctx.common.async) {
        return Promise.all(items).then((results) => {
          return ParseStatus.mergeArray(status, results);
        });
      } else {
        return ParseStatus.mergeArray(status, items);
      }
    }
    get items() {
      return this._def.items;
    }
    rest(rest) {
      return new _ZodTuple({
        ...this._def,
        rest
      });
    }
  };
  ZodTuple.create = (schemas, params) => {
    if (!Array.isArray(schemas)) {
      throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
    }
    return new ZodTuple({
      items: schemas,
      typeName: ZodFirstPartyTypeKind.ZodTuple,
      rest: null,
      ...processCreateParams(params)
    });
  };
  var ZodRecord = class _ZodRecord extends ZodType {
    get keySchema() {
      return this._def.keyType;
    }
    get valueSchema() {
      return this._def.valueType;
    }
    _parse(input) {
      const { status, ctx } = this._processInputParams(input);
      if (ctx.parsedType !== ZodParsedType.object) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.object,
          received: ctx.parsedType
        });
        return INVALID;
      }
      const pairs = [];
      const keyType = this._def.keyType;
      const valueType = this._def.valueType;
      for (const key in ctx.data) {
        pairs.push({
          key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),
          value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key)),
          alwaysSet: key in ctx.data
        });
      }
      if (ctx.common.async) {
        return ParseStatus.mergeObjectAsync(status, pairs);
      } else {
        return ParseStatus.mergeObjectSync(status, pairs);
      }
    }
    get element() {
      return this._def.valueType;
    }
    static create(first, second, third) {
      if (second instanceof ZodType) {
        return new _ZodRecord({
          keyType: first,
          valueType: second,
          typeName: ZodFirstPartyTypeKind.ZodRecord,
          ...processCreateParams(third)
        });
      }
      return new _ZodRecord({
        keyType: ZodString.create(),
        valueType: first,
        typeName: ZodFirstPartyTypeKind.ZodRecord,
        ...processCreateParams(second)
      });
    }
  };
  var ZodMap = class extends ZodType {
    get keySchema() {
      return this._def.keyType;
    }
    get valueSchema() {
      return this._def.valueType;
    }
    _parse(input) {
      const { status, ctx } = this._processInputParams(input);
      if (ctx.parsedType !== ZodParsedType.map) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.map,
          received: ctx.parsedType
        });
        return INVALID;
      }
      const keyType = this._def.keyType;
      const valueType = this._def.valueType;
      const pairs = [...ctx.data.entries()].map(([key, value], index) => {
        return {
          key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [index, "key"])),
          value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [index, "value"]))
        };
      });
      if (ctx.common.async) {
        const finalMap = /* @__PURE__ */ new Map();
        return Promise.resolve().then(async () => {
          for (const pair of pairs) {
            const key = await pair.key;
            const value = await pair.value;
            if (key.status === "aborted" || value.status === "aborted") {
              return INVALID;
            }
            if (key.status === "dirty" || value.status === "dirty") {
              status.dirty();
            }
            finalMap.set(key.value, value.value);
          }
          return { status: status.value, value: finalMap };
        });
      } else {
        const finalMap = /* @__PURE__ */ new Map();
        for (const pair of pairs) {
          const key = pair.key;
          const value = pair.value;
          if (key.status === "aborted" || value.status === "aborted") {
            return INVALID;
          }
          if (key.status === "dirty" || value.status === "dirty") {
            status.dirty();
          }
          finalMap.set(key.value, value.value);
        }
        return { status: status.value, value: finalMap };
      }
    }
  };
  ZodMap.create = (keyType, valueType, params) => {
    return new ZodMap({
      valueType,
      keyType,
      typeName: ZodFirstPartyTypeKind.ZodMap,
      ...processCreateParams(params)
    });
  };
  var ZodSet = class _ZodSet extends ZodType {
    _parse(input) {
      const { status, ctx } = this._processInputParams(input);
      if (ctx.parsedType !== ZodParsedType.set) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.set,
          received: ctx.parsedType
        });
        return INVALID;
      }
      const def = this._def;
      if (def.minSize !== null) {
        if (ctx.data.size < def.minSize.value) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: def.minSize.value,
            type: "set",
            inclusive: true,
            exact: false,
            message: def.minSize.message
          });
          status.dirty();
        }
      }
      if (def.maxSize !== null) {
        if (ctx.data.size > def.maxSize.value) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: def.maxSize.value,
            type: "set",
            inclusive: true,
            exact: false,
            message: def.maxSize.message
          });
          status.dirty();
        }
      }
      const valueType = this._def.valueType;
      function finalizeSet(elements2) {
        const parsedSet = /* @__PURE__ */ new Set();
        for (const element of elements2) {
          if (element.status === "aborted")
            return INVALID;
          if (element.status === "dirty")
            status.dirty();
          parsedSet.add(element.value);
        }
        return { status: status.value, value: parsedSet };
      }
      const elements = [...ctx.data.values()].map((item, i) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i)));
      if (ctx.common.async) {
        return Promise.all(elements).then((elements2) => finalizeSet(elements2));
      } else {
        return finalizeSet(elements);
      }
    }
    min(minSize, message) {
      return new _ZodSet({
        ...this._def,
        minSize: { value: minSize, message: errorUtil.toString(message) }
      });
    }
    max(maxSize, message) {
      return new _ZodSet({
        ...this._def,
        maxSize: { value: maxSize, message: errorUtil.toString(message) }
      });
    }
    size(size, message) {
      return this.min(size, message).max(size, message);
    }
    nonempty(message) {
      return this.min(1, message);
    }
  };
  ZodSet.create = (valueType, params) => {
    return new ZodSet({
      valueType,
      minSize: null,
      maxSize: null,
      typeName: ZodFirstPartyTypeKind.ZodSet,
      ...processCreateParams(params)
    });
  };
  var ZodFunction = class _ZodFunction extends ZodType {
    constructor() {
      super(...arguments);
      this.validate = this.implement;
    }
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      if (ctx.parsedType !== ZodParsedType.function) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.function,
          received: ctx.parsedType
        });
        return INVALID;
      }
      function makeArgsIssue(args, error) {
        return makeIssue({
          data: args,
          path: ctx.path,
          errorMaps: [ctx.common.contextualErrorMap, ctx.schemaErrorMap, getErrorMap(), en_default].filter((x) => !!x),
          issueData: {
            code: ZodIssueCode.invalid_arguments,
            argumentsError: error
          }
        });
      }
      function makeReturnsIssue(returns, error) {
        return makeIssue({
          data: returns,
          path: ctx.path,
          errorMaps: [ctx.common.contextualErrorMap, ctx.schemaErrorMap, getErrorMap(), en_default].filter((x) => !!x),
          issueData: {
            code: ZodIssueCode.invalid_return_type,
            returnTypeError: error
          }
        });
      }
      const params = { errorMap: ctx.common.contextualErrorMap };
      const fn = ctx.data;
      if (this._def.returns instanceof ZodPromise) {
        const me = this;
        return OK2(async function(...args) {
          const error = new ZodError([]);
          const parsedArgs = await me._def.args.parseAsync(args, params).catch((e) => {
            error.addIssue(makeArgsIssue(args, e));
            throw error;
          });
          const result = await Reflect.apply(fn, this, parsedArgs);
          const parsedReturns = await me._def.returns._def.type.parseAsync(result, params).catch((e) => {
            error.addIssue(makeReturnsIssue(result, e));
            throw error;
          });
          return parsedReturns;
        });
      } else {
        const me = this;
        return OK2(function(...args) {
          const parsedArgs = me._def.args.safeParse(args, params);
          if (!parsedArgs.success) {
            throw new ZodError([makeArgsIssue(args, parsedArgs.error)]);
          }
          const result = Reflect.apply(fn, this, parsedArgs.data);
          const parsedReturns = me._def.returns.safeParse(result, params);
          if (!parsedReturns.success) {
            throw new ZodError([makeReturnsIssue(result, parsedReturns.error)]);
          }
          return parsedReturns.data;
        });
      }
    }
    parameters() {
      return this._def.args;
    }
    returnType() {
      return this._def.returns;
    }
    args(...items) {
      return new _ZodFunction({
        ...this._def,
        args: ZodTuple.create(items).rest(ZodUnknown.create())
      });
    }
    returns(returnType) {
      return new _ZodFunction({
        ...this._def,
        returns: returnType
      });
    }
    implement(func) {
      const validatedFunc = this.parse(func);
      return validatedFunc;
    }
    strictImplement(func) {
      const validatedFunc = this.parse(func);
      return validatedFunc;
    }
    static create(args, returns, params) {
      return new _ZodFunction({
        args: args ? args : ZodTuple.create([]).rest(ZodUnknown.create()),
        returns: returns || ZodUnknown.create(),
        typeName: ZodFirstPartyTypeKind.ZodFunction,
        ...processCreateParams(params)
      });
    }
  };
  var ZodLazy = class extends ZodType {
    get schema() {
      return this._def.getter();
    }
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      const lazySchema = this._def.getter();
      return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });
    }
  };
  ZodLazy.create = (getter, params) => {
    return new ZodLazy({
      getter,
      typeName: ZodFirstPartyTypeKind.ZodLazy,
      ...processCreateParams(params)
    });
  };
  var ZodLiteral = class extends ZodType {
    _parse(input) {
      if (input.data !== this._def.value) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
          received: ctx.data,
          code: ZodIssueCode.invalid_literal,
          expected: this._def.value
        });
        return INVALID;
      }
      return { status: "valid", value: input.data };
    }
    get value() {
      return this._def.value;
    }
  };
  ZodLiteral.create = (value, params) => {
    return new ZodLiteral({
      value,
      typeName: ZodFirstPartyTypeKind.ZodLiteral,
      ...processCreateParams(params)
    });
  };
  function createZodEnum(values, params) {
    return new ZodEnum({
      values,
      typeName: ZodFirstPartyTypeKind.ZodEnum,
      ...processCreateParams(params)
    });
  }
  var ZodEnum = class _ZodEnum extends ZodType {
    _parse(input) {
      if (typeof input.data !== "string") {
        const ctx = this._getOrReturnCtx(input);
        const expectedValues = this._def.values;
        addIssueToContext(ctx, {
          expected: util.joinValues(expectedValues),
          received: ctx.parsedType,
          code: ZodIssueCode.invalid_type
        });
        return INVALID;
      }
      if (!this._cache) {
        this._cache = new Set(this._def.values);
      }
      if (!this._cache.has(input.data)) {
        const ctx = this._getOrReturnCtx(input);
        const expectedValues = this._def.values;
        addIssueToContext(ctx, {
          received: ctx.data,
          code: ZodIssueCode.invalid_enum_value,
          options: expectedValues
        });
        return INVALID;
      }
      return OK2(input.data);
    }
    get options() {
      return this._def.values;
    }
    get enum() {
      const enumValues = {};
      for (const val of this._def.values) {
        enumValues[val] = val;
      }
      return enumValues;
    }
    get Values() {
      const enumValues = {};
      for (const val of this._def.values) {
        enumValues[val] = val;
      }
      return enumValues;
    }
    get Enum() {
      const enumValues = {};
      for (const val of this._def.values) {
        enumValues[val] = val;
      }
      return enumValues;
    }
    extract(values, newDef = this._def) {
      return _ZodEnum.create(values, {
        ...this._def,
        ...newDef
      });
    }
    exclude(values, newDef = this._def) {
      return _ZodEnum.create(this.options.filter((opt) => !values.includes(opt)), {
        ...this._def,
        ...newDef
      });
    }
  };
  ZodEnum.create = createZodEnum;
  var ZodNativeEnum = class extends ZodType {
    _parse(input) {
      const nativeEnumValues = util.getValidEnumValues(this._def.values);
      const ctx = this._getOrReturnCtx(input);
      if (ctx.parsedType !== ZodParsedType.string && ctx.parsedType !== ZodParsedType.number) {
        const expectedValues = util.objectValues(nativeEnumValues);
        addIssueToContext(ctx, {
          expected: util.joinValues(expectedValues),
          received: ctx.parsedType,
          code: ZodIssueCode.invalid_type
        });
        return INVALID;
      }
      if (!this._cache) {
        this._cache = new Set(util.getValidEnumValues(this._def.values));
      }
      if (!this._cache.has(input.data)) {
        const expectedValues = util.objectValues(nativeEnumValues);
        addIssueToContext(ctx, {
          received: ctx.data,
          code: ZodIssueCode.invalid_enum_value,
          options: expectedValues
        });
        return INVALID;
      }
      return OK2(input.data);
    }
    get enum() {
      return this._def.values;
    }
  };
  ZodNativeEnum.create = (values, params) => {
    return new ZodNativeEnum({
      values,
      typeName: ZodFirstPartyTypeKind.ZodNativeEnum,
      ...processCreateParams(params)
    });
  };
  var ZodPromise = class extends ZodType {
    unwrap() {
      return this._def.type;
    }
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      if (ctx.parsedType !== ZodParsedType.promise && ctx.common.async === false) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.promise,
          received: ctx.parsedType
        });
        return INVALID;
      }
      const promisified = ctx.parsedType === ZodParsedType.promise ? ctx.data : Promise.resolve(ctx.data);
      return OK2(promisified.then((data) => {
        return this._def.type.parseAsync(data, {
          path: ctx.path,
          errorMap: ctx.common.contextualErrorMap
        });
      }));
    }
  };
  ZodPromise.create = (schema, params) => {
    return new ZodPromise({
      type: schema,
      typeName: ZodFirstPartyTypeKind.ZodPromise,
      ...processCreateParams(params)
    });
  };
  var ZodEffects = class extends ZodType {
    innerType() {
      return this._def.schema;
    }
    sourceType() {
      return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
    }
    _parse(input) {
      const { status, ctx } = this._processInputParams(input);
      const effect = this._def.effect || null;
      const checkCtx = {
        addIssue: (arg) => {
          addIssueToContext(ctx, arg);
          if (arg.fatal) {
            status.abort();
          } else {
            status.dirty();
          }
        },
        get path() {
          return ctx.path;
        }
      };
      checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
      if (effect.type === "preprocess") {
        const processed = effect.transform(ctx.data, checkCtx);
        if (ctx.common.async) {
          return Promise.resolve(processed).then(async (processed2) => {
            if (status.value === "aborted")
              return INVALID;
            const result = await this._def.schema._parseAsync({
              data: processed2,
              path: ctx.path,
              parent: ctx
            });
            if (result.status === "aborted")
              return INVALID;
            if (result.status === "dirty")
              return DIRTY(result.value);
            if (status.value === "dirty")
              return DIRTY(result.value);
            return result;
          });
        } else {
          if (status.value === "aborted")
            return INVALID;
          const result = this._def.schema._parseSync({
            data: processed,
            path: ctx.path,
            parent: ctx
          });
          if (result.status === "aborted")
            return INVALID;
          if (result.status === "dirty")
            return DIRTY(result.value);
          if (status.value === "dirty")
            return DIRTY(result.value);
          return result;
        }
      }
      if (effect.type === "refinement") {
        const executeRefinement = (acc) => {
          const result = effect.refinement(acc, checkCtx);
          if (ctx.common.async) {
            return Promise.resolve(result);
          }
          if (result instanceof Promise) {
            throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
          }
          return acc;
        };
        if (ctx.common.async === false) {
          const inner = this._def.schema._parseSync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          });
          if (inner.status === "aborted")
            return INVALID;
          if (inner.status === "dirty")
            status.dirty();
          executeRefinement(inner.value);
          return { status: status.value, value: inner.value };
        } else {
          return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((inner) => {
            if (inner.status === "aborted")
              return INVALID;
            if (inner.status === "dirty")
              status.dirty();
            return executeRefinement(inner.value).then(() => {
              return { status: status.value, value: inner.value };
            });
          });
        }
      }
      if (effect.type === "transform") {
        if (ctx.common.async === false) {
          const base = this._def.schema._parseSync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          });
          if (!isValid(base))
            return INVALID;
          const result = effect.transform(base.value, checkCtx);
          if (result instanceof Promise) {
            throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);
          }
          return { status: status.value, value: result };
        } else {
          return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((base) => {
            if (!isValid(base))
              return INVALID;
            return Promise.resolve(effect.transform(base.value, checkCtx)).then((result) => ({
              status: status.value,
              value: result
            }));
          });
        }
      }
      util.assertNever(effect);
    }
  };
  ZodEffects.create = (schema, effect, params) => {
    return new ZodEffects({
      schema,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect,
      ...processCreateParams(params)
    });
  };
  ZodEffects.createWithPreprocess = (preprocess, schema, params) => {
    return new ZodEffects({
      schema,
      effect: { type: "preprocess", transform: preprocess },
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      ...processCreateParams(params)
    });
  };
  var ZodOptional = class extends ZodType {
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType === ZodParsedType.undefined) {
        return OK2(void 0);
      }
      return this._def.innerType._parse(input);
    }
    unwrap() {
      return this._def.innerType;
    }
  };
  ZodOptional.create = (type, params) => {
    return new ZodOptional({
      innerType: type,
      typeName: ZodFirstPartyTypeKind.ZodOptional,
      ...processCreateParams(params)
    });
  };
  var ZodNullable = class extends ZodType {
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType === ZodParsedType.null) {
        return OK2(null);
      }
      return this._def.innerType._parse(input);
    }
    unwrap() {
      return this._def.innerType;
    }
  };
  ZodNullable.create = (type, params) => {
    return new ZodNullable({
      innerType: type,
      typeName: ZodFirstPartyTypeKind.ZodNullable,
      ...processCreateParams(params)
    });
  };
  var ZodDefault = class extends ZodType {
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      let data = ctx.data;
      if (ctx.parsedType === ZodParsedType.undefined) {
        data = this._def.defaultValue();
      }
      return this._def.innerType._parse({
        data,
        path: ctx.path,
        parent: ctx
      });
    }
    removeDefault() {
      return this._def.innerType;
    }
  };
  ZodDefault.create = (type, params) => {
    return new ZodDefault({
      innerType: type,
      typeName: ZodFirstPartyTypeKind.ZodDefault,
      defaultValue: typeof params.default === "function" ? params.default : () => params.default,
      ...processCreateParams(params)
    });
  };
  var ZodCatch = class extends ZodType {
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      const newCtx = {
        ...ctx,
        common: {
          ...ctx.common,
          issues: []
        }
      };
      const result = this._def.innerType._parse({
        data: newCtx.data,
        path: newCtx.path,
        parent: {
          ...newCtx
        }
      });
      if (isAsync(result)) {
        return result.then((result2) => {
          return {
            status: "valid",
            value: result2.status === "valid" ? result2.value : this._def.catchValue({
              get error() {
                return new ZodError(newCtx.common.issues);
              },
              input: newCtx.data
            })
          };
        });
      } else {
        return {
          status: "valid",
          value: result.status === "valid" ? result.value : this._def.catchValue({
            get error() {
              return new ZodError(newCtx.common.issues);
            },
            input: newCtx.data
          })
        };
      }
    }
    removeCatch() {
      return this._def.innerType;
    }
  };
  ZodCatch.create = (type, params) => {
    return new ZodCatch({
      innerType: type,
      typeName: ZodFirstPartyTypeKind.ZodCatch,
      catchValue: typeof params.catch === "function" ? params.catch : () => params.catch,
      ...processCreateParams(params)
    });
  };
  var ZodNaN = class extends ZodType {
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.nan) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.nan,
          received: ctx.parsedType
        });
        return INVALID;
      }
      return { status: "valid", value: input.data };
    }
  };
  ZodNaN.create = (params) => {
    return new ZodNaN({
      typeName: ZodFirstPartyTypeKind.ZodNaN,
      ...processCreateParams(params)
    });
  };
  var BRAND = Symbol("zod_brand");
  var ZodBranded = class extends ZodType {
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      const data = ctx.data;
      return this._def.type._parse({
        data,
        path: ctx.path,
        parent: ctx
      });
    }
    unwrap() {
      return this._def.type;
    }
  };
  var ZodPipeline = class _ZodPipeline extends ZodType {
    _parse(input) {
      const { status, ctx } = this._processInputParams(input);
      if (ctx.common.async) {
        const handleAsync = async () => {
          const inResult = await this._def.in._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          });
          if (inResult.status === "aborted")
            return INVALID;
          if (inResult.status === "dirty") {
            status.dirty();
            return DIRTY(inResult.value);
          } else {
            return this._def.out._parseAsync({
              data: inResult.value,
              path: ctx.path,
              parent: ctx
            });
          }
        };
        return handleAsync();
      } else {
        const inResult = this._def.in._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inResult.status === "aborted")
          return INVALID;
        if (inResult.status === "dirty") {
          status.dirty();
          return {
            status: "dirty",
            value: inResult.value
          };
        } else {
          return this._def.out._parseSync({
            data: inResult.value,
            path: ctx.path,
            parent: ctx
          });
        }
      }
    }
    static create(a, b) {
      return new _ZodPipeline({
        in: a,
        out: b,
        typeName: ZodFirstPartyTypeKind.ZodPipeline
      });
    }
  };
  var ZodReadonly = class extends ZodType {
    _parse(input) {
      const result = this._def.innerType._parse(input);
      const freeze = (data) => {
        if (isValid(data)) {
          data.value = Object.freeze(data.value);
        }
        return data;
      };
      return isAsync(result) ? result.then((data) => freeze(data)) : freeze(result);
    }
    unwrap() {
      return this._def.innerType;
    }
  };
  ZodReadonly.create = (type, params) => {
    return new ZodReadonly({
      innerType: type,
      typeName: ZodFirstPartyTypeKind.ZodReadonly,
      ...processCreateParams(params)
    });
  };
  function cleanParams(params, data) {
    const p = typeof params === "function" ? params(data) : typeof params === "string" ? { message: params } : params;
    const p2 = typeof p === "string" ? { message: p } : p;
    return p2;
  }
  function custom(check, _params = {}, fatal) {
    if (check)
      return ZodAny.create().superRefine((data, ctx) => {
        const r = check(data);
        if (r instanceof Promise) {
          return r.then((r2) => {
            if (!r2) {
              const params = cleanParams(_params, data);
              const _fatal = params.fatal ?? fatal ?? true;
              ctx.addIssue({ code: "custom", ...params, fatal: _fatal });
            }
          });
        }
        if (!r) {
          const params = cleanParams(_params, data);
          const _fatal = params.fatal ?? fatal ?? true;
          ctx.addIssue({ code: "custom", ...params, fatal: _fatal });
        }
        return;
      });
    return ZodAny.create();
  }
  var late = {
    object: ZodObject.lazycreate
  };
  var ZodFirstPartyTypeKind;
  (function(ZodFirstPartyTypeKind2) {
    ZodFirstPartyTypeKind2["ZodString"] = "ZodString";
    ZodFirstPartyTypeKind2["ZodNumber"] = "ZodNumber";
    ZodFirstPartyTypeKind2["ZodNaN"] = "ZodNaN";
    ZodFirstPartyTypeKind2["ZodBigInt"] = "ZodBigInt";
    ZodFirstPartyTypeKind2["ZodBoolean"] = "ZodBoolean";
    ZodFirstPartyTypeKind2["ZodDate"] = "ZodDate";
    ZodFirstPartyTypeKind2["ZodSymbol"] = "ZodSymbol";
    ZodFirstPartyTypeKind2["ZodUndefined"] = "ZodUndefined";
    ZodFirstPartyTypeKind2["ZodNull"] = "ZodNull";
    ZodFirstPartyTypeKind2["ZodAny"] = "ZodAny";
    ZodFirstPartyTypeKind2["ZodUnknown"] = "ZodUnknown";
    ZodFirstPartyTypeKind2["ZodNever"] = "ZodNever";
    ZodFirstPartyTypeKind2["ZodVoid"] = "ZodVoid";
    ZodFirstPartyTypeKind2["ZodArray"] = "ZodArray";
    ZodFirstPartyTypeKind2["ZodObject"] = "ZodObject";
    ZodFirstPartyTypeKind2["ZodUnion"] = "ZodUnion";
    ZodFirstPartyTypeKind2["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
    ZodFirstPartyTypeKind2["ZodIntersection"] = "ZodIntersection";
    ZodFirstPartyTypeKind2["ZodTuple"] = "ZodTuple";
    ZodFirstPartyTypeKind2["ZodRecord"] = "ZodRecord";
    ZodFirstPartyTypeKind2["ZodMap"] = "ZodMap";
    ZodFirstPartyTypeKind2["ZodSet"] = "ZodSet";
    ZodFirstPartyTypeKind2["ZodFunction"] = "ZodFunction";
    ZodFirstPartyTypeKind2["ZodLazy"] = "ZodLazy";
    ZodFirstPartyTypeKind2["ZodLiteral"] = "ZodLiteral";
    ZodFirstPartyTypeKind2["ZodEnum"] = "ZodEnum";
    ZodFirstPartyTypeKind2["ZodEffects"] = "ZodEffects";
    ZodFirstPartyTypeKind2["ZodNativeEnum"] = "ZodNativeEnum";
    ZodFirstPartyTypeKind2["ZodOptional"] = "ZodOptional";
    ZodFirstPartyTypeKind2["ZodNullable"] = "ZodNullable";
    ZodFirstPartyTypeKind2["ZodDefault"] = "ZodDefault";
    ZodFirstPartyTypeKind2["ZodCatch"] = "ZodCatch";
    ZodFirstPartyTypeKind2["ZodPromise"] = "ZodPromise";
    ZodFirstPartyTypeKind2["ZodBranded"] = "ZodBranded";
    ZodFirstPartyTypeKind2["ZodPipeline"] = "ZodPipeline";
    ZodFirstPartyTypeKind2["ZodReadonly"] = "ZodReadonly";
  })(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));
  var instanceOfType = (cls, params = {
    message: `Input not instance of ${cls.name}`
  }) => custom((data) => data instanceof cls, params);
  var stringType = ZodString.create;
  var numberType = ZodNumber.create;
  var nanType = ZodNaN.create;
  var bigIntType = ZodBigInt.create;
  var booleanType = ZodBoolean.create;
  var dateType = ZodDate.create;
  var symbolType = ZodSymbol.create;
  var undefinedType = ZodUndefined.create;
  var nullType = ZodNull.create;
  var anyType = ZodAny.create;
  var unknownType = ZodUnknown.create;
  var neverType = ZodNever.create;
  var voidType = ZodVoid.create;
  var arrayType = ZodArray.create;
  var objectType = ZodObject.create;
  var strictObjectType = ZodObject.strictCreate;
  var unionType = ZodUnion.create;
  var discriminatedUnionType = ZodDiscriminatedUnion.create;
  var intersectionType = ZodIntersection.create;
  var tupleType = ZodTuple.create;
  var recordType = ZodRecord.create;
  var mapType = ZodMap.create;
  var setType = ZodSet.create;
  var functionType = ZodFunction.create;
  var lazyType = ZodLazy.create;
  var literalType = ZodLiteral.create;
  var enumType = ZodEnum.create;
  var nativeEnumType = ZodNativeEnum.create;
  var promiseType = ZodPromise.create;
  var effectsType = ZodEffects.create;
  var optionalType = ZodOptional.create;
  var nullableType = ZodNullable.create;
  var preprocessType = ZodEffects.createWithPreprocess;
  var pipelineType = ZodPipeline.create;
  var coerce = {
    string: ((arg) => ZodString.create({ ...arg, coerce: true })),
    number: ((arg) => ZodNumber.create({ ...arg, coerce: true })),
    boolean: ((arg) => ZodBoolean.create({
      ...arg,
      coerce: true
    })),
    bigint: ((arg) => ZodBigInt.create({ ...arg, coerce: true })),
    date: ((arg) => ZodDate.create({ ...arg, coerce: true }))
  };

  // node_modules/@gleanwork/api-client/dist/esm/lib/base64.js
  function bytesToBase64(u8arr) {
    return btoa(String.fromCodePoint(...u8arr));
  }
  function bytesFromBase64(encoded) {
    return Uint8Array.from(atob(encoded), (c) => c.charCodeAt(0));
  }
  function stringToBytes(str) {
    return new TextEncoder().encode(str);
  }
  function stringToBase64(str) {
    return bytesToBase64(stringToBytes(str));
  }
  var zodOutbound = instanceOfType(Uint8Array).or(stringType().transform(stringToBytes));
  var zodInbound = instanceOfType(Uint8Array).or(stringType().transform(bytesFromBase64));

  // node_modules/@gleanwork/api-client/dist/esm/lib/is-plain-object.js
  function isPlainObject(value) {
    if (typeof value !== "object" || value === null) {
      return false;
    }
    const prototype = Object.getPrototypeOf(value);
    return (prototype === null || prototype === Object.prototype || Object.getPrototypeOf(prototype) === null) && !(Symbol.toStringTag in value) && !(Symbol.iterator in value);
  }

  // node_modules/@gleanwork/api-client/dist/esm/lib/encodings.js
  var EncodingError = class extends Error {
    constructor(message) {
      super(message);
      this.name = "EncodingError";
    }
  };
  function formEncoder(sep) {
    return (key, value, options) => {
      let out = "";
      const pairs = options?.explode ? explode(key, value) : [[key, value]];
      if (pairs.every(([_, v]) => v == null)) {
        return;
      }
      const encodeString = (v) => {
        return options?.charEncoding === "percent" ? encodeURIComponent(v) : v;
      };
      const encodeValue = (v) => encodeString(serializeValue(v));
      const encodedSep = encodeString(sep);
      pairs.forEach(([pk, pv]) => {
        let tmp = "";
        let encValue = null;
        if (pv == null) {
          return;
        } else if (Array.isArray(pv)) {
          encValue = mapDefined(pv, (v) => `${encodeValue(v)}`)?.join(encodedSep);
        } else if (isPlainObject(pv)) {
          encValue = mapDefinedEntries(Object.entries(pv), ([k, v]) => {
            return `${encodeString(k)}${encodedSep}${encodeValue(v)}`;
          })?.join(encodedSep);
        } else {
          encValue = `${encodeValue(pv)}`;
        }
        if (encValue == null) {
          return;
        }
        tmp = `${encodeString(pk)}=${encValue}`;
        if (!tmp || tmp === "=") {
          return;
        }
        out += `&${tmp}`;
      });
      return out.slice(1);
    };
  }
  var encodeForm = formEncoder(",");
  var encodeSpaceDelimited = formEncoder(" ");
  var encodePipeDelimited = formEncoder("|");
  function encodeDeepObject(key, value, options) {
    if (value == null) {
      return;
    }
    if (!isPlainObject(value)) {
      throw new EncodingError(`Value of parameter '${key}' which uses deepObject encoding must be an object or null`);
    }
    return encodeDeepObjectObject(key, value, options);
  }
  function encodeDeepObjectObject(key, value, options) {
    if (value == null) {
      return;
    }
    let out = "";
    const encodeString = (v) => {
      return options?.charEncoding === "percent" ? encodeURIComponent(v) : v;
    };
    if (!isPlainObject(value)) {
      throw new EncodingError(`Expected parameter '${key}' to be an object.`);
    }
    Object.entries(value).forEach(([ck, cv]) => {
      if (cv == null) {
        return;
      }
      const pk = `${key}[${ck}]`;
      if (isPlainObject(cv)) {
        const objOut = encodeDeepObjectObject(pk, cv, options);
        out += objOut == null ? "" : `&${objOut}`;
        return;
      }
      const pairs = Array.isArray(cv) ? cv : [cv];
      const encoded = mapDefined(pairs, (v) => {
        return `${encodeString(pk)}=${encodeString(serializeValue(v))}`;
      })?.join("&");
      out += encoded == null ? "" : `&${encoded}`;
    });
    return out.slice(1);
  }
  function encodeJSON(key, value, options) {
    if (typeof value === "undefined") {
      return;
    }
    const encodeString = (v) => {
      return options?.charEncoding === "percent" ? encodeURIComponent(v) : v;
    };
    const encVal = encodeString(JSON.stringify(value, jsonReplacer));
    return options?.explode ? encVal : `${encodeString(key)}=${encVal}`;
  }
  var encodeSimple = (key, value, options) => {
    let out = "";
    const pairs = options?.explode ? explode(key, value) : [[key, value]];
    if (pairs.every(([_, v]) => v == null)) {
      return;
    }
    const encodeString = (v) => {
      return options?.charEncoding === "percent" ? encodeURIComponent(v) : v;
    };
    const encodeValue = (v) => encodeString(serializeValue(v));
    pairs.forEach(([pk, pv]) => {
      let tmp = "";
      if (pv == null) {
        return;
      } else if (Array.isArray(pv)) {
        tmp = mapDefined(pv, (v) => `${encodeValue(v)}`)?.join(",");
      } else if (isPlainObject(pv)) {
        const mapped = mapDefinedEntries(Object.entries(pv), ([k, v]) => {
          return `,${encodeString(k)},${encodeValue(v)}`;
        });
        tmp = mapped?.join("").slice(1);
      } else {
        const k = options?.explode && isPlainObject(value) ? `${pk}=` : "";
        tmp = `${k}${encodeValue(pv)}`;
      }
      out += tmp ? `,${tmp}` : "";
    });
    return out.slice(1);
  };
  function explode(key, value) {
    if (Array.isArray(value)) {
      return value.map((v) => [key, v]);
    } else if (isPlainObject(value)) {
      const o = value ?? {};
      return Object.entries(o).map(([k, v]) => [k, v]);
    } else {
      return [[key, value]];
    }
  }
  function serializeValue(value) {
    if (value == null) {
      return "";
    } else if (value instanceof Date) {
      return value.toISOString();
    } else if (value instanceof Uint8Array) {
      return bytesToBase64(value);
    } else if (typeof value === "object") {
      return JSON.stringify(value, jsonReplacer);
    }
    return `${value}`;
  }
  function jsonReplacer(_, value) {
    if (value instanceof Uint8Array) {
      return bytesToBase64(value);
    } else {
      return value;
    }
  }
  function mapDefined(inp, mapper) {
    const res = inp.reduce((acc, v) => {
      if (v == null) {
        return acc;
      }
      const m = mapper(v);
      if (m == null) {
        return acc;
      }
      acc.push(m);
      return acc;
    }, []);
    return res.length ? res : null;
  }
  function mapDefinedEntries(inp, mapper) {
    const acc = [];
    for (const [k, v] of inp) {
      if (v == null) {
        continue;
      }
      const m = mapper([k, v]);
      if (m == null) {
        continue;
      }
      acc.push(m);
    }
    return acc.length ? acc : null;
  }
  function queryJoin(...args) {
    return args.filter(Boolean).join("&");
  }
  function queryEncoder(f) {
    const bulkEncode = function(values, options) {
      const opts = {
        ...options,
        explode: options?.explode ?? true,
        charEncoding: options?.charEncoding ?? "percent"
      };
      const encoded = Object.entries(values).map(([key, value]) => {
        return f(key, value, opts);
      });
      return queryJoin(...encoded);
    };
    return bulkEncode;
  }
  var encodeJSONQuery = queryEncoder(encodeJSON);
  var encodeFormQuery = queryEncoder(encodeForm);
  var encodeSpaceDelimitedQuery = queryEncoder(encodeSpaceDelimited);
  var encodePipeDelimitedQuery = queryEncoder(encodePipeDelimited);
  var encodeDeepObjectQuery = queryEncoder(encodeDeepObject);
  function appendForm(fd, key, value, fileName) {
    if (value == null) {
      return;
    } else if (value instanceof Blob && fileName) {
      fd.append(key, value, fileName);
    } else if (value instanceof Blob) {
      fd.append(key, value);
    } else {
      fd.append(key, String(value));
    }
  }

  // node_modules/@gleanwork/api-client/dist/esm/lib/dlv.js
  function dlv(obj, key, def, p, undef) {
    key = Array.isArray(key) ? key : key.split(".");
    for (p = 0; p < key.length; p++) {
      const k = key[p];
      obj = k != null && obj ? obj[k] : undef;
    }
    return obj === undef ? def : obj;
  }

  // node_modules/@gleanwork/api-client/dist/esm/lib/env.js
  var envSchema = objectType({
    GLEAN_API_TOKEN: stringType().optional(),
    GLEAN_DEBUG: coerce.boolean().optional()
  });
  var envMemo = void 0;
  function env() {
    if (envMemo) {
      return envMemo;
    }
    envMemo = envSchema.parse(dlv(globalThis, "process.env") ?? dlv(globalThis, "Deno.env") ?? {});
    return envMemo;
  }

  // node_modules/@gleanwork/api-client/dist/esm/lib/retries.js
  var defaultBackoff = {
    initialInterval: 500,
    maxInterval: 6e4,
    exponent: 1.5,
    maxElapsedTime: 36e5
  };
  var PermanentError = class _PermanentError extends Error {
    constructor(message, options) {
      let msg = message;
      if (options?.cause) {
        msg += `: ${options.cause}`;
      }
      super(msg, options);
      this.name = "PermanentError";
      if (typeof this.cause === "undefined") {
        this.cause = options?.cause;
      }
      Object.setPrototypeOf(this, _PermanentError.prototype);
    }
  };
  var TemporaryError = class _TemporaryError extends Error {
    constructor(message, response) {
      super(message);
      this.response = response;
      this.name = "TemporaryError";
      Object.setPrototypeOf(this, _TemporaryError.prototype);
    }
  };
  async function retry(fetchFn, options) {
    switch (options.config.strategy) {
      case "backoff":
        return retryBackoff(wrapFetcher(fetchFn, {
          statusCodes: options.statusCodes,
          retryConnectionErrors: !!options.config.retryConnectionErrors
        }), options.config.backoff ?? defaultBackoff);
      default:
        return await fetchFn();
    }
  }
  function wrapFetcher(fn, options) {
    return async () => {
      try {
        const res = await fn();
        if (isRetryableResponse(res, options.statusCodes)) {
          throw new TemporaryError("Response failed with retryable status code", res);
        }
        return res;
      } catch (err) {
        if (err instanceof TemporaryError) {
          throw err;
        }
        if (options.retryConnectionErrors && (isTimeoutError(err) || isConnectionError(err))) {
          throw err;
        }
        throw new PermanentError("Permanent error", { cause: err });
      }
    };
  }
  var codeRangeRE2 = new RegExp("^[0-9]xx$", "i");
  function isRetryableResponse(res, statusCodes) {
    const actual = `${res.status}`;
    return statusCodes.some((code) => {
      if (!codeRangeRE2.test(code)) {
        return code === actual;
      }
      const expectFamily = code.charAt(0);
      if (!expectFamily) {
        throw new Error("Invalid status code range");
      }
      const actualFamily = actual.charAt(0);
      if (!actualFamily) {
        throw new Error(`Invalid response status code: ${actual}`);
      }
      return actualFamily === expectFamily;
    });
  }
  async function retryBackoff(fn, strategy) {
    const { maxElapsedTime, initialInterval, exponent, maxInterval } = strategy;
    const start = Date.now();
    let x = 0;
    while (true) {
      try {
        const res = await fn();
        return res;
      } catch (err) {
        if (err instanceof PermanentError) {
          throw err.cause;
        }
        const elapsed = Date.now() - start;
        if (elapsed > maxElapsedTime) {
          if (err instanceof TemporaryError) {
            return err.response;
          }
          throw err;
        }
        let retryInterval = 0;
        if (err instanceof TemporaryError) {
          retryInterval = retryIntervalFromResponse(err.response);
        }
        if (retryInterval <= 0) {
          retryInterval = initialInterval * Math.pow(x, exponent) + Math.random() * 1e3;
        }
        const d = Math.min(retryInterval, maxInterval);
        await delay(d);
        x++;
      }
    }
  }
  function retryIntervalFromResponse(res) {
    const retryVal = res.headers.get("retry-after") || "";
    if (!retryVal) {
      return 0;
    }
    const parsedNumber = Number(retryVal);
    if (Number.isInteger(parsedNumber)) {
      return parsedNumber * 1e3;
    }
    const parsedDate = Date.parse(retryVal);
    if (Number.isInteger(parsedDate)) {
      const deltaMS = parsedDate - Date.now();
      return deltaMS > 0 ? Math.ceil(deltaMS) : 0;
    }
    return 0;
  }
  async function delay(delay2) {
    return new Promise((resolve) => setTimeout(resolve, delay2));
  }

  // node_modules/@gleanwork/api-client/dist/esm/lib/sdks.js
  var __classPrivateFieldSet = function(receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
  };
  var __classPrivateFieldGet = function(receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
  };
  var _ClientSDK_httpClient;
  var _ClientSDK_hooks;
  var _ClientSDK_logger;
  var gt = typeof globalThis === "undefined" ? null : globalThis;
  var webWorkerLike = typeof gt === "object" && gt != null && "importScripts" in gt && typeof gt["importScripts"] === "function";
  var isBrowserLike = webWorkerLike || typeof navigator !== "undefined" && "serviceWorker" in navigator || typeof window === "object" && typeof window.document !== "undefined";
  var ClientSDK = class {
    constructor(options = {}) {
      _ClientSDK_httpClient.set(this, void 0);
      _ClientSDK_hooks.set(this, void 0);
      _ClientSDK_logger.set(this, void 0);
      const opt = options;
      if (typeof opt === "object" && opt != null && "hooks" in opt && opt.hooks instanceof SDKHooks) {
        __classPrivateFieldSet(this, _ClientSDK_hooks, opt.hooks, "f");
      } else {
        __classPrivateFieldSet(this, _ClientSDK_hooks, new SDKHooks(), "f");
      }
      const url = serverURLFromOptions(options);
      if (url) {
        url.pathname = url.pathname.replace(/\/+$/, "") + "/";
      }
      const { baseURL, client } = __classPrivateFieldGet(this, _ClientSDK_hooks, "f").sdkInit({
        baseURL: url,
        client: options.httpClient || new HTTPClient()
      });
      this._baseURL = baseURL;
      __classPrivateFieldSet(this, _ClientSDK_httpClient, client, "f");
      this._options = { ...options, hooks: __classPrivateFieldGet(this, _ClientSDK_hooks, "f") };
      __classPrivateFieldSet(this, _ClientSDK_logger, this._options.debugLogger, "f");
      if (!__classPrivateFieldGet(this, _ClientSDK_logger, "f") && env().GLEAN_DEBUG) {
        __classPrivateFieldSet(this, _ClientSDK_logger, console, "f");
      }
    }
    _createRequest(context, conf, options) {
      const { method, path, query, headers: opHeaders, security } = conf;
      const base = conf.baseURL ?? this._baseURL;
      if (!base) {
        return ERR(new InvalidRequestError("No base URL provided for operation"));
      }
      const reqURL = new URL(base);
      const inputURL = new URL(path, reqURL);
      if (path) {
        reqURL.pathname += reqURL.pathname.endsWith("/") ? "" : "/";
        reqURL.pathname += inputURL.pathname.replace(/^\/+/, "");
      }
      let finalQuery = query || "";
      const secQuery = [];
      for (const [k, v] of Object.entries(security?.queryParams || {})) {
        const q = encodeForm(k, v, { charEncoding: "percent" });
        if (typeof q !== "undefined") {
          secQuery.push(q);
        }
      }
      if (secQuery.length) {
        finalQuery += `&${secQuery.join("&")}`;
      }
      if (finalQuery) {
        const q = finalQuery.startsWith("&") ? finalQuery.slice(1) : finalQuery;
        reqURL.search = `?${q}`;
      }
      const headers = new Headers(opHeaders);
      const username = security?.basic.username;
      const password = security?.basic.password;
      if (username != null || password != null) {
        const encoded = stringToBase64([username || "", password || ""].join(":"));
        headers.set("Authorization", `Basic ${encoded}`);
      }
      const securityHeaders = new Headers(security?.headers || {});
      for (const [k, v] of securityHeaders) {
        headers.set(k, v);
      }
      let cookie = headers.get("cookie") || "";
      for (const [k, v] of Object.entries(security?.cookies || {})) {
        cookie += `; ${k}=${v}`;
      }
      cookie = cookie.startsWith("; ") ? cookie.slice(2) : cookie;
      headers.set("cookie", cookie);
      const userHeaders = new Headers(options?.headers ?? options?.fetchOptions?.headers);
      for (const [k, v] of userHeaders) {
        headers.set(k, v);
      }
      if (!isBrowserLike) {
        headers.set(conf.uaHeader ?? "user-agent", conf.userAgent ?? SDK_METADATA.userAgent);
      }
      const fetchOptions = {
        ...options?.fetchOptions,
        ...options
      };
      if (!fetchOptions?.signal && conf.timeoutMs && conf.timeoutMs > 0) {
        const timeoutSignal = AbortSignal.timeout(conf.timeoutMs);
        fetchOptions.signal = timeoutSignal;
      }
      if (conf.body instanceof ReadableStream) {
        Object.assign(fetchOptions, { duplex: "half" });
      }
      let input;
      try {
        input = __classPrivateFieldGet(this, _ClientSDK_hooks, "f").beforeCreateRequest(context, {
          url: reqURL,
          options: {
            ...fetchOptions,
            body: conf.body ?? null,
            headers,
            method
          }
        });
      } catch (err) {
        return ERR(new UnexpectedClientError("Create request hook failed to execute", {
          cause: err
        }));
      }
      return OK(new Request(input.url, input.options));
    }
    async _do(request, options) {
      const { context, errorCodes } = options;
      return retry(async () => {
        const req = await __classPrivateFieldGet(this, _ClientSDK_hooks, "f").beforeRequest(context, request.clone());
        await logRequest(__classPrivateFieldGet(this, _ClientSDK_logger, "f"), req).catch((e) => __classPrivateFieldGet(this, _ClientSDK_logger, "f")?.log("Failed to log request:", e));
        let response = await __classPrivateFieldGet(this, _ClientSDK_httpClient, "f").request(req);
        try {
          if (matchStatusCode(response, errorCodes)) {
            const result = await __classPrivateFieldGet(this, _ClientSDK_hooks, "f").afterError(context, response, null);
            if (result.error) {
              throw result.error;
            }
            response = result.response || response;
          } else {
            response = await __classPrivateFieldGet(this, _ClientSDK_hooks, "f").afterSuccess(context, response);
          }
        } finally {
          await logResponse(__classPrivateFieldGet(this, _ClientSDK_logger, "f"), response, req).catch((e) => __classPrivateFieldGet(this, _ClientSDK_logger, "f")?.log("Failed to log response:", e));
        }
        return response;
      }, { config: options.retryConfig, statusCodes: options.retryCodes }).then((r) => OK(r), (err) => {
        switch (true) {
          case isAbortError(err):
            return ERR(new RequestAbortedError("Request aborted by client", {
              cause: err
            }));
          case isTimeoutError(err):
            return ERR(new RequestTimeoutError("Request timed out", { cause: err }));
          case isConnectionError(err):
            return ERR(new ConnectionError("Unable to make request", { cause: err }));
          default:
            return ERR(new UnexpectedClientError("Unexpected HTTP client error", {
              cause: err
            }));
        }
      });
    }
  };
  _ClientSDK_httpClient = /* @__PURE__ */ new WeakMap(), _ClientSDK_hooks = /* @__PURE__ */ new WeakMap(), _ClientSDK_logger = /* @__PURE__ */ new WeakMap();
  var jsonLikeContentTypeRE = /(application|text)\/.*?\+*json.*/;
  var jsonlLikeContentTypeRE = /(application|text)\/(.*?\+*\bjsonl\b.*|.*?\+*\bx-ndjson\b.*)/;
  async function logRequest(logger, req) {
    if (!logger) {
      return;
    }
    const contentType = req.headers.get("content-type");
    const ct = contentType?.split(";")[0] || "";
    logger.group(`> Request: ${req.method} ${req.url}`);
    logger.group("Headers:");
    for (const [k, v] of req.headers.entries()) {
      logger.log(`${k}: ${v}`);
    }
    logger.groupEnd();
    logger.group("Body:");
    switch (true) {
      case jsonLikeContentTypeRE.test(ct):
        logger.log(await req.clone().json());
        break;
      case ct.startsWith("text/"):
        logger.log(await req.clone().text());
        break;
      case ct === "multipart/form-data": {
        const body = await req.clone().formData();
        for (const [k, v] of body) {
          const vlabel = v instanceof Blob ? "<Blob>" : v;
          logger.log(`${k}: ${vlabel}`);
        }
        break;
      }
      default:
        logger.log(`<${contentType}>`);
        break;
    }
    logger.groupEnd();
    logger.groupEnd();
  }
  async function logResponse(logger, res, req) {
    if (!logger) {
      return;
    }
    const contentType = res.headers.get("content-type");
    const ct = contentType?.split(";")[0] || "";
    logger.group(`< Response: ${req.method} ${req.url}`);
    logger.log("Status Code:", res.status, res.statusText);
    logger.group("Headers:");
    for (const [k, v] of res.headers.entries()) {
      logger.log(`${k}: ${v}`);
    }
    logger.groupEnd();
    logger.group("Body:");
    switch (true) {
      case (matchContentType(res, "application/json") || jsonLikeContentTypeRE.test(ct) && !jsonlLikeContentTypeRE.test(ct)):
        logger.log(await res.clone().json());
        break;
      case (matchContentType(res, "application/jsonl") || jsonlLikeContentTypeRE.test(ct)):
        logger.log(await res.clone().text());
        break;
      case matchContentType(res, "text/event-stream"):
        logger.log(`<${contentType}>`);
        break;
      case matchContentType(res, "text/*"):
        logger.log(await res.clone().text());
        break;
      case matchContentType(res, "multipart/form-data"): {
        const body = await res.clone().formData();
        for (const [k, v] of body) {
          const vlabel = v instanceof Blob ? "<Blob>" : v;
          logger.log(`${k}: ${vlabel}`);
        }
        break;
      }
      default:
        logger.log(`<${contentType}>`);
        break;
    }
    logger.groupEnd();
    logger.groupEnd();
  }

  // node_modules/@gleanwork/api-client/dist/esm/models/errors/gleanbaseerror.js
  var GleanBaseError = class extends Error {
    constructor(message, httpMeta) {
      super(message);
      this.statusCode = httpMeta.response.status;
      this.body = httpMeta.body;
      this.headers = httpMeta.response.headers;
      this.contentType = httpMeta.response.headers.get("content-type") || "";
      this.rawResponse = httpMeta.response;
      this.name = "GleanBaseError";
    }
  };

  // node_modules/@gleanwork/api-client/dist/esm/models/errors/gleanerror.js
  var GleanError = class extends GleanBaseError {
    constructor(message, httpMeta) {
      if (message) {
        message += `: `;
      }
      message += `Status ${httpMeta.response.status}`;
      const contentType = httpMeta.response.headers.get("content-type") || `""`;
      if (contentType !== "application/json") {
        message += ` Content-Type ${contentType.includes(" ") ? `"${contentType}"` : contentType}`;
      }
      const body = httpMeta.body || `""`;
      message += body.length > 100 ? "\n" : ". ";
      let bodyDisplay = body;
      if (body.length > 1e4) {
        const truncated = body.substring(0, 1e4);
        const remaining = body.length - 1e4;
        bodyDisplay = `${truncated}...and ${remaining} more chars`;
      }
      message += `Body: ${bodyDisplay}`;
      message = message.trim();
      super(message, httpMeta);
      this.name = "GleanError";
    }
  };

  // node_modules/@gleanwork/api-client/dist/esm/models/errors/sdkvalidationerror.js
  var SDKValidationError = class extends Error {
    // Allows for backwards compatibility for `instanceof` checks of `ResponseValidationError`
    static [Symbol.hasInstance](instance) {
      if (!(instance instanceof Error))
        return false;
      if (!("rawValue" in instance))
        return false;
      if (!("rawMessage" in instance))
        return false;
      if (!("pretty" in instance))
        return false;
      if (typeof instance.pretty !== "function")
        return false;
      return true;
    }
    constructor(message, cause, rawValue) {
      super(`${message}: ${cause}`);
      this.name = "SDKValidationError";
      this.cause = cause;
      this.rawValue = rawValue;
      this.rawMessage = message;
    }
    /**
     * Return a pretty-formatted error message if the underlying validation error
     * is a ZodError or some other recognized error type, otherwise return the
     * default error message.
     */
    pretty() {
      if (this.cause instanceof ZodError) {
        return `${this.rawMessage}
${formatZodError(this.cause)}`;
      } else {
        return this.toString();
      }
    }
  };
  function formatZodError(err, level = 0) {
    let pre = "  ".repeat(level);
    pre = level > 0 ? `\u2502${pre}` : pre;
    pre += " ".repeat(level);
    let message = "";
    const append = (str) => message += `
${pre}${str}`;
    const len = err.issues.length;
    const headline = len === 1 ? `${len} issue found` : `${len} issues found`;
    if (len) {
      append(`\u250C ${headline}:`);
    }
    for (const issue of err.issues) {
      let path = issue.path.join(".");
      path = path ? `<root>.${path}` : "<root>";
      append(`\u2502 \u2022 [${path}]: ${issue.message} (${issue.code})`);
      switch (issue.code) {
        case "invalid_literal":
        case "invalid_type": {
          append(`\u2502     Want: ${issue.expected}`);
          append(`\u2502      Got: ${issue.received}`);
          break;
        }
        case "unrecognized_keys": {
          append(`\u2502     Keys: ${issue.keys.join(", ")}`);
          break;
        }
        case "invalid_enum_value": {
          append(`\u2502     Allowed: ${issue.options.join(", ")}`);
          append(`\u2502         Got: ${issue.received}`);
          break;
        }
        case "invalid_union_discriminator": {
          append(`\u2502     Allowed: ${issue.options.join(", ")}`);
          break;
        }
        case "invalid_union": {
          const len2 = issue.unionErrors.length;
          append(`\u2502   \u2716\uFE0E Attemped to deserialize into one of ${len2} union members:`);
          issue.unionErrors.forEach((err2, i) => {
            append(`\u2502   \u2716\uFE0E Member ${i + 1} of ${len2}`);
            append(`${formatZodError(err2, level + 1)}`);
          });
        }
      }
    }
    if (err.issues.length) {
      append(`\u2514\u2500*`);
    }
    return message.slice(1);
  }

  // node_modules/@gleanwork/api-client/dist/esm/models/errors/responsevalidationerror.js
  var ResponseValidationError = class extends GleanBaseError {
    constructor(message, extra) {
      super(message, extra);
      this.name = "ResponseValidationError";
      this.cause = extra.cause;
      this.rawValue = extra.rawValue;
      this.rawMessage = extra.rawMessage;
    }
    /**
     * Return a pretty-formatted error message if the underlying validation error
     * is a ZodError or some other recognized error type, otherwise return the
     * default error message.
     */
    pretty() {
      if (this.cause instanceof ZodError) {
        return `${this.rawMessage}
${formatZodError(this.cause)}`;
      } else {
        return this.toString();
      }
    }
  };

  // node_modules/@gleanwork/api-client/dist/esm/lib/matchers.js
  var DEFAULT_CONTENT_TYPES = {
    jsonl: "application/jsonl",
    json: "application/json",
    text: "text/plain",
    bytes: "application/octet-stream",
    stream: "application/octet-stream",
    sse: "text/event-stream",
    nil: "*",
    fail: "*"
  };
  function jsonErr(codes, schema, options) {
    return { ...options, err: true, enc: "json", codes, schema };
  }
  function json(codes, schema, options) {
    return { ...options, enc: "json", codes, schema };
  }
  function text(codes, schema, options) {
    return { ...options, enc: "text", codes, schema };
  }
  function nil(codes, schema, options) {
    return { ...options, enc: "nil", codes, schema };
  }
  function fail(codes) {
    return { enc: "fail", codes };
  }
  function match(...matchers) {
    return async function matchFunc(response, request, options) {
      let raw;
      let matcher;
      for (const match2 of matchers) {
        const { codes } = match2;
        const ctpattern = "ctype" in match2 ? match2.ctype : DEFAULT_CONTENT_TYPES[match2.enc];
        if (ctpattern && matchResponse(response, codes, ctpattern)) {
          matcher = match2;
          break;
        } else if (!ctpattern && matchStatusCode(response, codes)) {
          matcher = match2;
          break;
        }
      }
      if (!matcher) {
        return [{
          ok: false,
          error: new GleanError("Unexpected Status or Content-Type", {
            response,
            request,
            body: await response.text().catch(() => "")
          })
        }, raw];
      }
      const encoding = matcher.enc;
      let body = "";
      switch (encoding) {
        case "json":
          body = await response.text();
          raw = JSON.parse(body);
          break;
        case "jsonl":
          raw = response.body;
          break;
        case "bytes":
          raw = new Uint8Array(await response.arrayBuffer());
          break;
        case "stream":
          raw = response.body;
          break;
        case "text":
          body = await response.text();
          raw = body;
          break;
        case "sse":
          raw = response.body;
          break;
        case "nil":
          body = await response.text();
          raw = void 0;
          break;
        case "fail":
          body = await response.text();
          raw = body;
          break;
        default:
          encoding;
          throw new Error(`Unsupported response type: ${encoding}`);
      }
      if (matcher.enc === "fail") {
        return [{
          ok: false,
          error: new GleanError("API error occurred", {
            request,
            response,
            body
          })
        }, raw];
      }
      const resultKey = matcher.key || options?.resultKey;
      let data;
      if ("err" in matcher) {
        data = {
          ...options?.extraFields,
          ...matcher.hdrs ? { Headers: unpackHeaders(response.headers) } : null,
          ...isPlainObject(raw) ? raw : null,
          request$: request,
          response$: response,
          body$: body
        };
      } else if (resultKey) {
        data = {
          ...options?.extraFields,
          ...matcher.hdrs ? { Headers: unpackHeaders(response.headers) } : null,
          [resultKey]: raw
        };
      } else if (matcher.hdrs) {
        data = {
          ...options?.extraFields,
          ...matcher.hdrs ? { Headers: unpackHeaders(response.headers) } : null,
          ...isPlainObject(raw) ? raw : null
        };
      } else {
        data = raw;
      }
      if ("err" in matcher) {
        const result = safeParseResponse(data, (v) => matcher.schema.parse(v), "Response validation failed", { request, response, body });
        return [result.ok ? { ok: false, error: result.value } : result, raw];
      } else {
        return [
          safeParseResponse(data, (v) => matcher.schema.parse(v), "Response validation failed", { request, response, body }),
          raw
        ];
      }
    };
  }
  var headerValRE = /, */;
  function unpackHeaders(headers) {
    const out = {};
    for (const [k, v] of headers.entries()) {
      out[k] = v.split(headerValRE);
    }
    return out;
  }
  function safeParseResponse(rawValue, fn, errorMessage, httpMeta) {
    try {
      return OK(fn(rawValue));
    } catch (err) {
      return ERR(new ResponseValidationError(errorMessage, {
        cause: err,
        rawValue,
        rawMessage: errorMessage,
        ...httpMeta
      }));
    }
  }

  // node_modules/@gleanwork/api-client/dist/esm/lib/primitives.js
  function remap(inp, mappings) {
    let out = {};
    if (!Object.keys(mappings).length) {
      out = inp;
      return out;
    }
    for (const [k, v] of Object.entries(inp)) {
      const j = mappings[k];
      if (j === null) {
        continue;
      }
      out[j ?? k] = v;
    }
    return out;
  }
  function compactMap(values) {
    const out = {};
    for (const [k, v] of Object.entries(values)) {
      if (typeof v !== "undefined") {
        out[k] = v;
      }
    }
    return out;
  }

  // node_modules/@gleanwork/api-client/dist/esm/lib/schemas.js
  function safeParse(rawValue, fn, errorMessage) {
    try {
      return OK(fn(rawValue));
    } catch (err) {
      return ERR(new SDKValidationError(errorMessage, err, rawValue));
    }
  }
  function collectExtraKeys(obj, extrasKey, optional) {
    return obj.transform((val) => {
      const extras = {};
      const { shape } = obj;
      for (const [key] of Object.entries(val)) {
        if (key in shape) {
          continue;
        }
        const v = val[key];
        if (typeof v === "undefined") {
          continue;
        }
        extras[key] = v;
        delete val[key];
      }
      if (optional && Object.keys(extras).length === 0) {
        return val;
      }
      return { ...val, [extrasKey]: extras };
    });
  }

  // node_modules/@gleanwork/api-client/dist/esm/lib/security.js
  var SecurityErrorCode;
  (function(SecurityErrorCode2) {
    SecurityErrorCode2["Incomplete"] = "incomplete";
    SecurityErrorCode2["UnrecognisedSecurityType"] = "unrecognized_security_type";
  })(SecurityErrorCode || (SecurityErrorCode = {}));
  var SecurityError = class _SecurityError extends Error {
    constructor(code, message) {
      super(message);
      this.code = code;
      this.name = "SecurityError";
    }
    static incomplete() {
      return new _SecurityError(SecurityErrorCode.Incomplete, "Security requirements not met in order to perform the operation");
    }
    static unrecognizedType(type) {
      return new _SecurityError(SecurityErrorCode.UnrecognisedSecurityType, `Unrecognised security type: ${type}`);
    }
  };
  function resolveSecurity(...options) {
    const state = {
      basic: {},
      headers: {},
      queryParams: {},
      cookies: {},
      oauth2: { type: "none" }
    };
    const option = options.find((opts) => {
      return opts.every((o) => {
        if (o.value == null) {
          return false;
        } else if (o.type === "http:basic") {
          return o.value.username != null || o.value.password != null;
        } else if (o.type === "http:custom") {
          return null;
        } else if (o.type === "oauth2:password") {
          return typeof o.value === "string" && !!o.value;
        } else if (o.type === "oauth2:client_credentials") {
          if (typeof o.value == "string") {
            return !!o.value;
          }
          return o.value.clientID != null || o.value.clientSecret != null;
        } else if (typeof o.value === "string") {
          return !!o.value;
        } else {
          throw new Error(`Unrecognized security type: ${o.type} (value type: ${typeof o.value})`);
        }
      });
    });
    if (option == null) {
      return null;
    }
    option.forEach((spec) => {
      if (spec.value == null) {
        return;
      }
      const { type } = spec;
      switch (type) {
        case "apiKey:header":
          state.headers[spec.fieldName] = spec.value;
          break;
        case "apiKey:query":
          state.queryParams[spec.fieldName] = spec.value;
          break;
        case "apiKey:cookie":
          state.cookies[spec.fieldName] = spec.value;
          break;
        case "http:basic":
          applyBasic(state, spec);
          break;
        case "http:custom":
          break;
        case "http:bearer":
          applyBearer(state, spec);
          break;
        case "oauth2":
          applyBearer(state, spec);
          break;
        case "oauth2:password":
          applyBearer(state, spec);
          break;
        case "oauth2:client_credentials":
          break;
        case "openIdConnect":
          applyBearer(state, spec);
          break;
        default:
          spec;
          throw SecurityError.unrecognizedType(type);
      }
    });
    return state;
  }
  function applyBasic(state, spec) {
    if (spec.value == null) {
      return;
    }
    state.basic = spec.value;
  }
  function applyBearer(state, spec) {
    if (typeof spec.value !== "string" || !spec.value) {
      return;
    }
    let value = spec.value;
    if (value.slice(0, 7).toLowerCase() !== "bearer ") {
      value = `Bearer ${value}`;
    }
    if (spec.fieldName !== void 0) {
      state.headers[spec.fieldName] = value;
    }
  }
  function resolveGlobalSecurity(security) {
    return resolveSecurity([
      {
        fieldName: "Authorization",
        type: "http:bearer",
        value: security?.apiToken ?? env().GLEAN_API_TOKEN
      }
    ]);
  }
  async function extractSecurity(sec) {
    if (sec == null) {
      return;
    }
    return typeof sec === "function" ? sec() : sec;
  }

  // node_modules/@gleanwork/api-client/dist/esm/models/components/activityeventparams.js
  var ActivityEventParams$inboundSchema = objectType({
    bodyContent: stringType().optional(),
    datasourceInstance: stringType().optional(),
    datasource: stringType().optional(),
    instanceOnlyName: stringType().optional(),
    duration: numberType().int().optional(),
    query: stringType().optional(),
    referrer: stringType().optional(),
    title: stringType().optional(),
    truncated: booleanType().optional()
  });
  var ActivityEventParams$outboundSchema = objectType({
    bodyContent: stringType().optional(),
    datasourceInstance: stringType().optional(),
    datasource: stringType().optional(),
    instanceOnlyName: stringType().optional(),
    duration: numberType().int().optional(),
    query: stringType().optional(),
    referrer: stringType().optional(),
    title: stringType().optional(),
    truncated: booleanType().optional()
  });
  var ActivityEventParams$;
  (function(ActivityEventParams$2) {
    ActivityEventParams$2.inboundSchema = ActivityEventParams$inboundSchema;
    ActivityEventParams$2.outboundSchema = ActivityEventParams$outboundSchema;
  })(ActivityEventParams$ || (ActivityEventParams$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/activityevent.js
  var ActivityEventAction = {
    View: "VIEW",
    Edit: "EDIT",
    Search: "SEARCH",
    Comment: "COMMENT",
    Crawl: "CRAWL",
    HistoricalSearch: "HISTORICAL_SEARCH",
    HistoricalView: "HISTORICAL_VIEW"
  };
  var ActivityEventAction$inboundSchema = nativeEnumType(ActivityEventAction);
  var ActivityEventAction$outboundSchema = ActivityEventAction$inboundSchema;
  var ActivityEventAction$;
  (function(ActivityEventAction$2) {
    ActivityEventAction$2.inboundSchema = ActivityEventAction$inboundSchema;
    ActivityEventAction$2.outboundSchema = ActivityEventAction$outboundSchema;
  })(ActivityEventAction$ || (ActivityEventAction$ = {}));
  var ActivityEvent$inboundSchema = objectType({
    id: stringType().optional(),
    action: ActivityEventAction$inboundSchema,
    params: ActivityEventParams$inboundSchema.optional(),
    timestamp: stringType().datetime({ offset: true }).transform((v) => new Date(v)),
    url: stringType()
  });
  var ActivityEvent$outboundSchema = objectType({
    id: stringType().optional(),
    action: ActivityEventAction$outboundSchema,
    params: ActivityEventParams$outboundSchema.optional(),
    timestamp: dateType().transform((v) => v.toISOString()),
    url: stringType()
  });
  var ActivityEvent$;
  (function(ActivityEvent$2) {
    ActivityEvent$2.inboundSchema = ActivityEvent$inboundSchema;
    ActivityEvent$2.outboundSchema = ActivityEvent$outboundSchema;
  })(ActivityEvent$ || (ActivityEvent$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/activity.js
  var Activity$inboundSchema = objectType({
    events: arrayType(ActivityEvent$inboundSchema)
  });
  var Activity$outboundSchema = objectType({
    events: arrayType(ActivityEvent$outboundSchema)
  });
  var Activity$;
  (function(Activity$2) {
    Activity$2.inboundSchema = Activity$inboundSchema;
    Activity$2.outboundSchema = Activity$outboundSchema;
  })(Activity$ || (Activity$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/addcollectionitemserror.js
  var AddCollectionItemsErrorErrorType = {
    ExistingItem: "EXISTING_ITEM"
  };
  var AddCollectionItemsErrorErrorType$inboundSchema = nativeEnumType(AddCollectionItemsErrorErrorType);
  var AddCollectionItemsErrorErrorType$outboundSchema = AddCollectionItemsErrorErrorType$inboundSchema;
  var AddCollectionItemsErrorErrorType$;
  (function(AddCollectionItemsErrorErrorType$2) {
    AddCollectionItemsErrorErrorType$2.inboundSchema = AddCollectionItemsErrorErrorType$inboundSchema;
    AddCollectionItemsErrorErrorType$2.outboundSchema = AddCollectionItemsErrorErrorType$outboundSchema;
  })(AddCollectionItemsErrorErrorType$ || (AddCollectionItemsErrorErrorType$ = {}));
  var AddCollectionItemsError$inboundSchema = objectType({
    errorType: AddCollectionItemsErrorErrorType$inboundSchema.optional()
  });
  var AddCollectionItemsError$outboundSchema = objectType({
    errorType: AddCollectionItemsErrorErrorType$outboundSchema.optional()
  });
  var AddCollectionItemsError$;
  (function(AddCollectionItemsError$2) {
    AddCollectionItemsError$2.inboundSchema = AddCollectionItemsError$inboundSchema;
    AddCollectionItemsError$2.outboundSchema = AddCollectionItemsError$outboundSchema;
  })(AddCollectionItemsError$ || (AddCollectionItemsError$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/collectionitemdescriptor.js
  var CollectionItemDescriptorItemType = {
    Document: "DOCUMENT",
    Text: "TEXT",
    Url: "URL"
  };
  var CollectionItemDescriptorItemType$inboundSchema = nativeEnumType(CollectionItemDescriptorItemType);
  var CollectionItemDescriptorItemType$outboundSchema = CollectionItemDescriptorItemType$inboundSchema;
  var CollectionItemDescriptorItemType$;
  (function(CollectionItemDescriptorItemType$2) {
    CollectionItemDescriptorItemType$2.inboundSchema = CollectionItemDescriptorItemType$inboundSchema;
    CollectionItemDescriptorItemType$2.outboundSchema = CollectionItemDescriptorItemType$outboundSchema;
  })(CollectionItemDescriptorItemType$ || (CollectionItemDescriptorItemType$ = {}));
  var CollectionItemDescriptor$inboundSchema = objectType({
    name: stringType().optional(),
    description: stringType().optional(),
    icon: stringType().optional(),
    url: stringType().optional(),
    documentId: stringType().optional(),
    newNextItemId: stringType().optional(),
    itemType: CollectionItemDescriptorItemType$inboundSchema.optional()
  });
  var CollectionItemDescriptor$outboundSchema = objectType({
    name: stringType().optional(),
    description: stringType().optional(),
    icon: stringType().optional(),
    url: stringType().optional(),
    documentId: stringType().optional(),
    newNextItemId: stringType().optional(),
    itemType: CollectionItemDescriptorItemType$outboundSchema.optional()
  });
  var CollectionItemDescriptor$;
  (function(CollectionItemDescriptor$2) {
    CollectionItemDescriptor$2.inboundSchema = CollectionItemDescriptor$inboundSchema;
    CollectionItemDescriptor$2.outboundSchema = CollectionItemDescriptor$outboundSchema;
  })(CollectionItemDescriptor$ || (CollectionItemDescriptor$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/addcollectionitemsrequest.js
  var AddCollectionItemsRequest$inboundSchema = objectType({
    collectionId: numberType(),
    addedCollectionItemDescriptors: arrayType(CollectionItemDescriptor$inboundSchema).optional()
  });
  var AddCollectionItemsRequest$outboundSchema = objectType({
    collectionId: numberType(),
    addedCollectionItemDescriptors: arrayType(CollectionItemDescriptor$outboundSchema).optional()
  });
  var AddCollectionItemsRequest$;
  (function(AddCollectionItemsRequest$2) {
    AddCollectionItemsRequest$2.inboundSchema = AddCollectionItemsRequest$inboundSchema;
    AddCollectionItemsRequest$2.outboundSchema = AddCollectionItemsRequest$outboundSchema;
  })(AddCollectionItemsRequest$ || (AddCollectionItemsRequest$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/connectortype.js
  var ConnectorType = {
    ApiCrawl: "API_CRAWL",
    BrowserCrawl: "BROWSER_CRAWL",
    BrowserHistory: "BROWSER_HISTORY",
    Builtin: "BUILTIN",
    FederatedSearch: "FEDERATED_SEARCH",
    PushApi: "PUSH_API",
    WebCrawl: "WEB_CRAWL",
    NativeHistory: "NATIVE_HISTORY"
  };
  var ConnectorType$inboundSchema = nativeEnumType(ConnectorType);
  var ConnectorType$outboundSchema = ConnectorType$inboundSchema;
  var ConnectorType$;
  (function(ConnectorType$2) {
    ConnectorType$2.inboundSchema = ConnectorType$inboundSchema;
    ConnectorType$2.outboundSchema = ConnectorType$outboundSchema;
  })(ConnectorType$ || (ConnectorType$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/documentcontent.js
  var DocumentContent$inboundSchema = objectType({
    fullTextList: arrayType(stringType()).optional()
  });
  var DocumentContent$outboundSchema = objectType({
    fullTextList: arrayType(stringType()).optional()
  });
  var DocumentContent$;
  (function(DocumentContent$2) {
    DocumentContent$2.inboundSchema = DocumentContent$inboundSchema;
    DocumentContent$2.outboundSchema = DocumentContent$outboundSchema;
  })(DocumentContent$ || (DocumentContent$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/timepoint.js
  var TimePoint$inboundSchema = objectType({
    epochSeconds: numberType().int().optional(),
    daysFromNow: numberType().int().optional()
  });
  var TimePoint$outboundSchema = objectType({
    epochSeconds: numberType().int().optional(),
    daysFromNow: numberType().int().optional()
  });
  var TimePoint$;
  (function(TimePoint$2) {
    TimePoint$2.inboundSchema = TimePoint$inboundSchema;
    TimePoint$2.outboundSchema = TimePoint$outboundSchema;
  })(TimePoint$ || (TimePoint$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/period.js
  var Period$inboundSchema = objectType({
    minDaysFromNow: numberType().int().optional(),
    maxDaysFromNow: numberType().int().optional(),
    start: TimePoint$inboundSchema.optional(),
    end: TimePoint$inboundSchema.optional()
  });
  var Period$outboundSchema = objectType({
    minDaysFromNow: numberType().int().optional(),
    maxDaysFromNow: numberType().int().optional(),
    start: TimePoint$outboundSchema.optional(),
    end: TimePoint$outboundSchema.optional()
  });
  var Period$;
  (function(Period$2) {
    Period$2.inboundSchema = Period$inboundSchema;
    Period$2.outboundSchema = Period$outboundSchema;
  })(Period$ || (Period$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/countinfo.js
  var CountInfo$inboundSchema = objectType({
    count: numberType().int(),
    period: Period$inboundSchema.optional(),
    org: stringType().optional()
  });
  var CountInfo$outboundSchema = objectType({
    count: numberType().int(),
    period: Period$outboundSchema.optional(),
    org: stringType().optional()
  });
  var CountInfo$;
  (function(CountInfo$2) {
    CountInfo$2.inboundSchema = CountInfo$inboundSchema;
    CountInfo$2.outboundSchema = CountInfo$outboundSchema;
  })(CountInfo$ || (CountInfo$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/customdatavalue.js
  var CustomDataValue$inboundSchema = objectType({
    displayLabel: stringType().optional(),
    stringValue: stringType().optional(),
    stringListValue: arrayType(stringType()).optional(),
    numberValue: numberType().optional(),
    booleanValue: booleanType().optional()
  });
  var CustomDataValue$outboundSchema = objectType({
    displayLabel: stringType().optional(),
    stringValue: stringType().optional(),
    stringListValue: arrayType(stringType()).optional(),
    numberValue: numberType().optional(),
    booleanValue: booleanType().optional()
  });
  var CustomDataValue$;
  (function(CustomDataValue$2) {
    CustomDataValue$2.inboundSchema = CustomDataValue$inboundSchema;
    CustomDataValue$2.outboundSchema = CustomDataValue$outboundSchema;
  })(CustomDataValue$ || (CustomDataValue$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/types/rfcdate.js
  var dateRE = /^\d{4}-\d{2}-\d{2}$/;
  var RFCDate = class _RFCDate {
    /**
     * Creates a new RFCDate instance using today's date.
     */
    static today() {
      return new _RFCDate(/* @__PURE__ */ new Date());
    }
    /**
     * Creates a new RFCDate instance using the provided input.
     * If a string is used then in must be in the format YYYY-MM-DD.
     *
     * @param date A Date object or a date string in YYYY-MM-DD format
     * @example
     * new RFCDate("2022-01-01")
     * @example
     * new RFCDate(new Date())
     */
    constructor(date) {
      if (typeof date === "string" && !dateRE.test(date)) {
        throw new RangeError("RFCDate: date strings must be in the format YYYY-MM-DD: " + date);
      }
      const value = new Date(date);
      if (isNaN(+value)) {
        throw new RangeError("RFCDate: invalid date provided: " + date);
      }
      this.serialized = value.toISOString().slice(0, "YYYY-MM-DD".length);
      if (!dateRE.test(this.serialized)) {
        throw new TypeError(`RFCDate: failed to build valid date with given value: ${date} serialized to ${this.serialized}`);
      }
    }
    toJSON() {
      return this.toString();
    }
    toString() {
      return this.serialized;
    }
  };

  // node_modules/@gleanwork/api-client/dist/esm/models/components/timeinterval.js
  var TimeInterval$inboundSchema = objectType({
    start: stringType(),
    end: stringType()
  });
  var TimeInterval$outboundSchema = objectType({
    start: stringType(),
    end: stringType()
  });
  var TimeInterval$;
  (function(TimeInterval$2) {
    TimeInterval$2.inboundSchema = TimeInterval$inboundSchema;
    TimeInterval$2.outboundSchema = TimeInterval$outboundSchema;
  })(TimeInterval$ || (TimeInterval$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/anonymousevent.js
  var AnonymousEventEventType = {
    Default: "DEFAULT",
    OutOfOffice: "OUT_OF_OFFICE"
  };
  var AnonymousEventEventType$inboundSchema = nativeEnumType(AnonymousEventEventType);
  var AnonymousEventEventType$outboundSchema = AnonymousEventEventType$inboundSchema;
  var AnonymousEventEventType$;
  (function(AnonymousEventEventType$2) {
    AnonymousEventEventType$2.inboundSchema = AnonymousEventEventType$inboundSchema;
    AnonymousEventEventType$2.outboundSchema = AnonymousEventEventType$outboundSchema;
  })(AnonymousEventEventType$ || (AnonymousEventEventType$ = {}));
  var AnonymousEvent$inboundSchema = objectType({
    time: TimeInterval$inboundSchema.optional(),
    eventType: AnonymousEventEventType$inboundSchema.optional()
  });
  var AnonymousEvent$outboundSchema = objectType({
    time: TimeInterval$outboundSchema.optional(),
    eventType: AnonymousEventEventType$outboundSchema.optional()
  });
  var AnonymousEvent$;
  (function(AnonymousEvent$2) {
    AnonymousEvent$2.inboundSchema = AnonymousEvent$inboundSchema;
    AnonymousEvent$2.outboundSchema = AnonymousEvent$outboundSchema;
  })(AnonymousEvent$ || (AnonymousEvent$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/iconconfig.js
  var IconType = {
    Collection: "COLLECTION",
    Custom: "CUSTOM",
    Datasource: "DATASOURCE",
    DatasourceInstance: "DATASOURCE_INSTANCE",
    Favicon: "FAVICON",
    FileType: "FILE_TYPE",
    GeneratedBackground: "GENERATED_BACKGROUND",
    Glyph: "GLYPH",
    MimeType: "MIME_TYPE",
    NoIcon: "NO_ICON",
    Person: "PERSON",
    Reactions: "REACTIONS",
    Url: "URL"
  };
  var IconType$inboundSchema = nativeEnumType(IconType);
  var IconType$outboundSchema = IconType$inboundSchema;
  var IconType$;
  (function(IconType$2) {
    IconType$2.inboundSchema = IconType$inboundSchema;
    IconType$2.outboundSchema = IconType$outboundSchema;
  })(IconType$ || (IconType$ = {}));
  var IconConfig$inboundSchema = objectType({
    generatedBackgroundColorKey: stringType().optional(),
    backgroundColor: stringType().optional(),
    color: stringType().optional(),
    key: stringType().optional(),
    iconType: IconType$inboundSchema.optional(),
    masked: booleanType().optional(),
    name: stringType().optional(),
    url: stringType().optional()
  });
  var IconConfig$outboundSchema = objectType({
    generatedBackgroundColorKey: stringType().optional(),
    backgroundColor: stringType().optional(),
    color: stringType().optional(),
    key: stringType().optional(),
    iconType: IconType$outboundSchema.optional(),
    masked: booleanType().optional(),
    name: stringType().optional(),
    url: stringType().optional()
  });
  var IconConfig$;
  (function(IconConfig$2) {
    IconConfig$2.inboundSchema = IconConfig$inboundSchema;
    IconConfig$2.outboundSchema = IconConfig$outboundSchema;
  })(IconConfig$ || (IconConfig$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/badge.js
  var Badge$inboundSchema = objectType({
    key: stringType().optional(),
    displayName: stringType().optional(),
    iconConfig: IconConfig$inboundSchema.optional(),
    pinned: booleanType().optional()
  });
  var Badge$outboundSchema = objectType({
    key: stringType().optional(),
    displayName: stringType().optional(),
    iconConfig: IconConfig$outboundSchema.optional(),
    pinned: booleanType().optional()
  });
  var Badge$;
  (function(Badge$2) {
    Badge$2.inboundSchema = Badge$inboundSchema;
    Badge$2.outboundSchema = Badge$outboundSchema;
  })(Badge$ || (Badge$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/customfieldvaluehyperlink.js
  var CustomFieldValueHyperlink$inboundSchema = objectType({
    urlAnchor: stringType().optional(),
    urlLink: stringType().optional()
  });
  var CustomFieldValueHyperlink$outboundSchema = objectType({
    urlAnchor: stringType().optional(),
    urlLink: stringType().optional()
  });
  var CustomFieldValueHyperlink$;
  (function(CustomFieldValueHyperlink$2) {
    CustomFieldValueHyperlink$2.inboundSchema = CustomFieldValueHyperlink$inboundSchema;
    CustomFieldValueHyperlink$2.outboundSchema = CustomFieldValueHyperlink$outboundSchema;
  })(CustomFieldValueHyperlink$ || (CustomFieldValueHyperlink$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/customfieldvalueperson.js
  var CustomFieldValuePerson$inboundSchema = objectType({
    person: lazyType(() => Person$inboundSchema).optional()
  });
  var CustomFieldValuePerson$outboundSchema = objectType({
    person: lazyType(() => Person$outboundSchema).optional()
  });
  var CustomFieldValuePerson$;
  (function(CustomFieldValuePerson$2) {
    CustomFieldValuePerson$2.inboundSchema = CustomFieldValuePerson$inboundSchema;
    CustomFieldValuePerson$2.outboundSchema = CustomFieldValuePerson$outboundSchema;
  })(CustomFieldValuePerson$ || (CustomFieldValuePerson$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/customfieldvaluestr.js
  var CustomFieldValueStr$inboundSchema = objectType({
    strText: stringType().optional()
  });
  var CustomFieldValueStr$outboundSchema = objectType({
    strText: stringType().optional()
  });
  var CustomFieldValueStr$;
  (function(CustomFieldValueStr$2) {
    CustomFieldValueStr$2.inboundSchema = CustomFieldValueStr$inboundSchema;
    CustomFieldValueStr$2.outboundSchema = CustomFieldValueStr$outboundSchema;
  })(CustomFieldValueStr$ || (CustomFieldValueStr$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/customfieldvalue.js
  var CustomFieldValue$inboundSchema = unionType([
    CustomFieldValueStr$inboundSchema,
    CustomFieldValueHyperlink$inboundSchema,
    lazyType(() => CustomFieldValuePerson$inboundSchema)
  ]);
  var CustomFieldValue$outboundSchema = unionType([
    CustomFieldValueStr$outboundSchema,
    CustomFieldValueHyperlink$outboundSchema,
    lazyType(() => CustomFieldValuePerson$outboundSchema)
  ]);
  var CustomFieldValue$;
  (function(CustomFieldValue$2) {
    CustomFieldValue$2.inboundSchema = CustomFieldValue$inboundSchema;
    CustomFieldValue$2.outboundSchema = CustomFieldValue$outboundSchema;
  })(CustomFieldValue$ || (CustomFieldValue$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/customfielddata.js
  var CustomFieldData$inboundSchema = objectType({
    label: stringType(),
    values: arrayType(lazyType(() => CustomFieldValue$inboundSchema)),
    displayable: booleanType().default(true)
  });
  var CustomFieldData$outboundSchema = objectType({
    label: stringType(),
    values: arrayType(lazyType(() => CustomFieldValue$outboundSchema)),
    displayable: booleanType().default(true)
  });
  var CustomFieldData$;
  (function(CustomFieldData$2) {
    CustomFieldData$2.inboundSchema = CustomFieldData$inboundSchema;
    CustomFieldData$2.outboundSchema = CustomFieldData$outboundSchema;
  })(CustomFieldData$ || (CustomFieldData$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/datasourceprofile.js
  var DatasourceProfile$inboundSchema = objectType({
    datasource: stringType(),
    handle: stringType(),
    url: stringType().optional(),
    nativeAppUrl: stringType().optional(),
    isUserGenerated: booleanType().optional()
  });
  var DatasourceProfile$outboundSchema = objectType({
    datasource: stringType(),
    handle: stringType(),
    url: stringType().optional(),
    nativeAppUrl: stringType().optional(),
    isUserGenerated: booleanType().optional()
  });
  var DatasourceProfile$;
  (function(DatasourceProfile$2) {
    DatasourceProfile$2.inboundSchema = DatasourceProfile$inboundSchema;
    DatasourceProfile$2.outboundSchema = DatasourceProfile$outboundSchema;
  })(DatasourceProfile$ || (DatasourceProfile$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/communicationchannel.js
  var CommunicationChannel = {
    CommunicationChannelEmail: "COMMUNICATION_CHANNEL_EMAIL",
    CommunicationChannelSlack: "COMMUNICATION_CHANNEL_SLACK"
  };
  var CommunicationChannel$inboundSchema = nativeEnumType(CommunicationChannel);
  var CommunicationChannel$outboundSchema = CommunicationChannel$inboundSchema;
  var CommunicationChannel$;
  (function(CommunicationChannel$2) {
    CommunicationChannel$2.inboundSchema = CommunicationChannel$inboundSchema;
    CommunicationChannel$2.outboundSchema = CommunicationChannel$outboundSchema;
  })(CommunicationChannel$ || (CommunicationChannel$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/channelinviteinfo.js
  var ChannelInviteInfo$inboundSchema = objectType({
    channel: CommunicationChannel$inboundSchema.optional(),
    isAutoInvite: booleanType().optional(),
    inviter: lazyType(() => Person$inboundSchema).optional(),
    inviteTime: stringType().datetime({ offset: true }).transform((v) => new Date(v)).optional(),
    reminderTime: stringType().datetime({ offset: true }).transform((v) => new Date(v)).optional()
  });
  var ChannelInviteInfo$outboundSchema = objectType({
    channel: CommunicationChannel$outboundSchema.optional(),
    isAutoInvite: booleanType().optional(),
    inviter: lazyType(() => Person$outboundSchema).optional(),
    inviteTime: dateType().transform((v) => v.toISOString()).optional(),
    reminderTime: dateType().transform((v) => v.toISOString()).optional()
  });
  var ChannelInviteInfo$;
  (function(ChannelInviteInfo$2) {
    ChannelInviteInfo$2.inboundSchema = ChannelInviteInfo$inboundSchema;
    ChannelInviteInfo$2.outboundSchema = ChannelInviteInfo$outboundSchema;
  })(ChannelInviteInfo$ || (ChannelInviteInfo$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/inviteinfo.js
  var InviteInfo$inboundSchema = objectType({
    signUpTime: stringType().datetime({ offset: true }).transform((v) => new Date(v)).optional(),
    invites: arrayType(lazyType(() => ChannelInviteInfo$inboundSchema)).optional(),
    inviter: lazyType(() => Person$inboundSchema).optional(),
    inviteTime: stringType().datetime({ offset: true }).transform((v) => new Date(v)).optional(),
    reminderTime: stringType().datetime({ offset: true }).transform((v) => new Date(v)).optional()
  });
  var InviteInfo$outboundSchema = objectType({
    signUpTime: dateType().transform((v) => v.toISOString()).optional(),
    invites: arrayType(lazyType(() => ChannelInviteInfo$outboundSchema)).optional(),
    inviter: lazyType(() => Person$outboundSchema).optional(),
    inviteTime: dateType().transform((v) => v.toISOString()).optional(),
    reminderTime: dateType().transform((v) => v.toISOString()).optional()
  });
  var InviteInfo$;
  (function(InviteInfo$2) {
    InviteInfo$2.inboundSchema = InviteInfo$inboundSchema;
    InviteInfo$2.outboundSchema = InviteInfo$outboundSchema;
  })(InviteInfo$ || (InviteInfo$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/scopetype.js
  var ScopeType = {
    Global: "GLOBAL",
    Own: "OWN"
  };
  var ScopeType$inboundSchema = nativeEnumType(ScopeType);
  var ScopeType$outboundSchema = ScopeType$inboundSchema;
  var ScopeType$;
  (function(ScopeType$2) {
    ScopeType$2.inboundSchema = ScopeType$inboundSchema;
    ScopeType$2.outboundSchema = ScopeType$outboundSchema;
  })(ScopeType$ || (ScopeType$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/grantpermission.js
  var GrantPermission$inboundSchema = objectType({
    scopeType: ScopeType$inboundSchema.optional()
  });
  var GrantPermission$outboundSchema = objectType({
    scopeType: ScopeType$outboundSchema.optional()
  });
  var GrantPermission$;
  (function(GrantPermission$2) {
    GrantPermission$2.inboundSchema = GrantPermission$inboundSchema;
    GrantPermission$2.outboundSchema = GrantPermission$outboundSchema;
  })(GrantPermission$ || (GrantPermission$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/readpermission.js
  var ReadPermission$inboundSchema = objectType({
    scopeType: ScopeType$inboundSchema.optional()
  });
  var ReadPermission$outboundSchema = objectType({
    scopeType: ScopeType$outboundSchema.optional()
  });
  var ReadPermission$;
  (function(ReadPermission$2) {
    ReadPermission$2.inboundSchema = ReadPermission$inboundSchema;
    ReadPermission$2.outboundSchema = ReadPermission$outboundSchema;
  })(ReadPermission$ || (ReadPermission$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/writepermission.js
  var WritePermission$inboundSchema = objectType({
    scopeType: ScopeType$inboundSchema.optional(),
    create: booleanType().optional(),
    update: booleanType().optional(),
    delete: booleanType().optional()
  });
  var WritePermission$outboundSchema = objectType({
    scopeType: ScopeType$outboundSchema.optional(),
    create: booleanType().optional(),
    update: booleanType().optional(),
    delete: booleanType().optional()
  });
  var WritePermission$;
  (function(WritePermission$2) {
    WritePermission$2.inboundSchema = WritePermission$inboundSchema;
    WritePermission$2.outboundSchema = WritePermission$outboundSchema;
  })(WritePermission$ || (WritePermission$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/permissions.js
  var Permissions$inboundSchema = objectType({
    canAdminSearch: booleanType().optional(),
    canAdminClientApiGlobalTokens: booleanType().optional(),
    canDlp: booleanType().optional(),
    read: recordType(arrayType(ReadPermission$inboundSchema)).optional(),
    write: recordType(arrayType(WritePermission$inboundSchema)).optional(),
    grant: recordType(arrayType(GrantPermission$inboundSchema)).optional(),
    role: stringType().optional(),
    roles: arrayType(stringType()).optional()
  });
  var Permissions$outboundSchema = objectType({
    canAdminSearch: booleanType().optional(),
    canAdminClientApiGlobalTokens: booleanType().optional(),
    canDlp: booleanType().optional(),
    read: recordType(arrayType(ReadPermission$outboundSchema)).optional(),
    write: recordType(arrayType(WritePermission$outboundSchema)).optional(),
    grant: recordType(arrayType(GrantPermission$outboundSchema)).optional(),
    role: stringType().optional(),
    roles: arrayType(stringType()).optional()
  });
  var Permissions$;
  (function(Permissions$2) {
    Permissions$2.inboundSchema = Permissions$inboundSchema;
    Permissions$2.outboundSchema = Permissions$outboundSchema;
  })(Permissions$ || (Permissions$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/persondistance.js
  var PersonDistance$inboundSchema = objectType({
    name: stringType(),
    obfuscatedId: stringType(),
    distance: numberType()
  });
  var PersonDistance$outboundSchema = objectType({
    name: stringType(),
    obfuscatedId: stringType(),
    distance: numberType()
  });
  var PersonDistance$;
  (function(PersonDistance$2) {
    PersonDistance$2.inboundSchema = PersonDistance$inboundSchema;
    PersonDistance$2.outboundSchema = PersonDistance$outboundSchema;
  })(PersonDistance$ || (PersonDistance$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/personteam.js
  var PersonTeamRelationship = {
    Member: "MEMBER",
    Manager: "MANAGER",
    Lead: "LEAD",
    PointOfContact: "POINT_OF_CONTACT",
    Other: "OTHER"
  };
  var PersonTeamRelationship$inboundSchema = nativeEnumType(PersonTeamRelationship);
  var PersonTeamRelationship$outboundSchema = PersonTeamRelationship$inboundSchema;
  var PersonTeamRelationship$;
  (function(PersonTeamRelationship$2) {
    PersonTeamRelationship$2.inboundSchema = PersonTeamRelationship$inboundSchema;
    PersonTeamRelationship$2.outboundSchema = PersonTeamRelationship$outboundSchema;
  })(PersonTeamRelationship$ || (PersonTeamRelationship$ = {}));
  var PersonTeam$inboundSchema = objectType({
    id: stringType().optional(),
    name: stringType().optional(),
    externalLink: stringType().optional(),
    relationship: PersonTeamRelationship$inboundSchema.default("MEMBER"),
    joinDate: stringType().datetime({ offset: true }).transform((v) => new Date(v)).optional()
  });
  var PersonTeam$outboundSchema = objectType({
    id: stringType().optional(),
    name: stringType().optional(),
    externalLink: stringType().optional(),
    relationship: PersonTeamRelationship$outboundSchema.default("MEMBER"),
    joinDate: dateType().transform((v) => v.toISOString()).optional()
  });
  var PersonTeam$;
  (function(PersonTeam$2) {
    PersonTeam$2.inboundSchema = PersonTeam$inboundSchema;
    PersonTeam$2.outboundSchema = PersonTeam$outboundSchema;
  })(PersonTeam$ || (PersonTeam$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/searchproviderinfo.js
  var SearchProviderInfo$inboundSchema = objectType({
    name: stringType().optional(),
    logoUrl: stringType().optional(),
    searchLinkUrlTemplate: stringType().optional()
  });
  var SearchProviderInfo$outboundSchema = objectType({
    name: stringType().optional(),
    logoUrl: stringType().optional(),
    searchLinkUrlTemplate: stringType().optional()
  });
  var SearchProviderInfo$;
  (function(SearchProviderInfo$2) {
    SearchProviderInfo$2.inboundSchema = SearchProviderInfo$inboundSchema;
    SearchProviderInfo$2.outboundSchema = SearchProviderInfo$outboundSchema;
  })(SearchProviderInfo$ || (SearchProviderInfo$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/searchrequestinputdetails.js
  var SearchRequestInputDetails$inboundSchema = objectType({
    hasCopyPaste: booleanType().optional()
  });
  var SearchRequestInputDetails$outboundSchema = objectType({
    hasCopyPaste: booleanType().optional()
  });
  var SearchRequestInputDetails$;
  (function(SearchRequestInputDetails$2) {
    SearchRequestInputDetails$2.inboundSchema = SearchRequestInputDetails$inboundSchema;
    SearchRequestInputDetails$2.outboundSchema = SearchRequestInputDetails$outboundSchema;
  })(SearchRequestInputDetails$ || (SearchRequestInputDetails$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/authtoken.js
  var AuthToken$inboundSchema = objectType({
    accessToken: stringType(),
    datasource: stringType(),
    scope: stringType().optional(),
    tokenType: stringType().optional(),
    authUser: stringType().optional(),
    expiration: numberType().int().optional()
  });
  var AuthToken$outboundSchema = objectType({
    accessToken: stringType(),
    datasource: stringType(),
    scope: stringType().optional(),
    tokenType: stringType().optional(),
    authUser: stringType().optional(),
    expiration: numberType().int().optional()
  });
  var AuthToken$;
  (function(AuthToken$2) {
    AuthToken$2.inboundSchema = AuthToken$inboundSchema;
    AuthToken$2.outboundSchema = AuthToken$outboundSchema;
  })(AuthToken$ || (AuthToken$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/facetbucketfilter.js
  var FacetBucketFilter$inboundSchema = objectType({
    facet: stringType().optional(),
    prefix: stringType().optional()
  });
  var FacetBucketFilter$outboundSchema = objectType({
    facet: stringType().optional(),
    prefix: stringType().optional()
  });
  var FacetBucketFilter$;
  (function(FacetBucketFilter$2) {
    FacetBucketFilter$2.inboundSchema = FacetBucketFilter$inboundSchema;
    FacetBucketFilter$2.outboundSchema = FacetBucketFilter$outboundSchema;
  })(FacetBucketFilter$ || (FacetBucketFilter$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/facetfiltervalue.js
  var RelationType = {
    Equals: "EQUALS",
    IdEquals: "ID_EQUALS",
    Lt: "LT",
    Gt: "GT",
    NotEquals: "NOT_EQUALS"
  };
  var RelationType$inboundSchema = nativeEnumType(RelationType);
  var RelationType$outboundSchema = RelationType$inboundSchema;
  var RelationType$;
  (function(RelationType$2) {
    RelationType$2.inboundSchema = RelationType$inboundSchema;
    RelationType$2.outboundSchema = RelationType$outboundSchema;
  })(RelationType$ || (RelationType$ = {}));
  var FacetFilterValue$inboundSchema = objectType({
    value: stringType().optional(),
    relationType: RelationType$inboundSchema.optional(),
    isNegated: booleanType().optional()
  });
  var FacetFilterValue$outboundSchema = objectType({
    value: stringType().optional(),
    relationType: RelationType$outboundSchema.optional(),
    isNegated: booleanType().optional()
  });
  var FacetFilterValue$;
  (function(FacetFilterValue$2) {
    FacetFilterValue$2.inboundSchema = FacetFilterValue$inboundSchema;
    FacetFilterValue$2.outboundSchema = FacetFilterValue$outboundSchema;
  })(FacetFilterValue$ || (FacetFilterValue$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/facetfilter.js
  var FacetFilter$inboundSchema = objectType({
    fieldName: stringType().optional(),
    values: arrayType(FacetFilterValue$inboundSchema).optional(),
    groupName: stringType().optional()
  });
  var FacetFilter$outboundSchema = objectType({
    fieldName: stringType().optional(),
    values: arrayType(FacetFilterValue$outboundSchema).optional(),
    groupName: stringType().optional()
  });
  var FacetFilter$;
  (function(FacetFilter$2) {
    FacetFilter$2.inboundSchema = FacetFilter$inboundSchema;
    FacetFilter$2.outboundSchema = FacetFilter$outboundSchema;
  })(FacetFilter$ || (FacetFilter$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/facetfilterset.js
  var FacetFilterSet$inboundSchema = objectType({
    filters: arrayType(FacetFilter$inboundSchema).optional()
  });
  var FacetFilterSet$outboundSchema = objectType({
    filters: arrayType(FacetFilter$outboundSchema).optional()
  });
  var FacetFilterSet$;
  (function(FacetFilterSet$2) {
    FacetFilterSet$2.inboundSchema = FacetFilterSet$inboundSchema;
    FacetFilterSet$2.outboundSchema = FacetFilterSet$outboundSchema;
  })(FacetFilterSet$ || (FacetFilterSet$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/documentspecunion.js
  var DocumentSpecUgcType2 = {
    Announcements: "ANNOUNCEMENTS",
    Answers: "ANSWERS",
    Collections: "COLLECTIONS",
    Shortcuts: "SHORTCUTS",
    Chats: "CHATS"
  };
  var DocumentSpecUgcType1 = {
    Announcements: "ANNOUNCEMENTS",
    Answers: "ANSWERS",
    Collections: "COLLECTIONS",
    Shortcuts: "SHORTCUTS",
    Chats: "CHATS"
  };
  var DocumentSpecUgcType2$inboundSchema = nativeEnumType(DocumentSpecUgcType2);
  var DocumentSpecUgcType2$outboundSchema = DocumentSpecUgcType2$inboundSchema;
  var DocumentSpecUgcType2$;
  (function(DocumentSpecUgcType2$2) {
    DocumentSpecUgcType2$2.inboundSchema = DocumentSpecUgcType2$inboundSchema;
    DocumentSpecUgcType2$2.outboundSchema = DocumentSpecUgcType2$outboundSchema;
  })(DocumentSpecUgcType2$ || (DocumentSpecUgcType2$ = {}));
  var DocumentSpec4$inboundSchema = objectType({
    ugcType: DocumentSpecUgcType2$inboundSchema,
    ugcId: stringType(),
    docType: stringType().optional()
  });
  var DocumentSpec4$outboundSchema = objectType({
    ugcType: DocumentSpecUgcType2$outboundSchema,
    ugcId: stringType(),
    docType: stringType().optional()
  });
  var DocumentSpec4$;
  (function(DocumentSpec4$2) {
    DocumentSpec4$2.inboundSchema = DocumentSpec4$inboundSchema;
    DocumentSpec4$2.outboundSchema = DocumentSpec4$outboundSchema;
  })(DocumentSpec4$ || (DocumentSpec4$ = {}));
  var DocumentSpecUgcType1$inboundSchema = nativeEnumType(DocumentSpecUgcType1);
  var DocumentSpecUgcType1$outboundSchema = DocumentSpecUgcType1$inboundSchema;
  var DocumentSpecUgcType1$;
  (function(DocumentSpecUgcType1$2) {
    DocumentSpecUgcType1$2.inboundSchema = DocumentSpecUgcType1$inboundSchema;
    DocumentSpecUgcType1$2.outboundSchema = DocumentSpecUgcType1$outboundSchema;
  })(DocumentSpecUgcType1$ || (DocumentSpecUgcType1$ = {}));
  var DocumentSpec3$inboundSchema = objectType({
    ugcType: DocumentSpecUgcType1$inboundSchema,
    contentId: numberType().int(),
    docType: stringType().optional()
  });
  var DocumentSpec3$outboundSchema = objectType({
    ugcType: DocumentSpecUgcType1$outboundSchema,
    contentId: numberType().int(),
    docType: stringType().optional()
  });
  var DocumentSpec3$;
  (function(DocumentSpec3$2) {
    DocumentSpec3$2.inboundSchema = DocumentSpec3$inboundSchema;
    DocumentSpec3$2.outboundSchema = DocumentSpec3$outboundSchema;
  })(DocumentSpec3$ || (DocumentSpec3$ = {}));
  var DocumentSpec2$inboundSchema = objectType({
    id: stringType()
  });
  var DocumentSpec2$outboundSchema = objectType({
    id: stringType()
  });
  var DocumentSpec2$;
  (function(DocumentSpec2$2) {
    DocumentSpec2$2.inboundSchema = DocumentSpec2$inboundSchema;
    DocumentSpec2$2.outboundSchema = DocumentSpec2$outboundSchema;
  })(DocumentSpec2$ || (DocumentSpec2$ = {}));
  var DocumentSpec1$inboundSchema = objectType({
    url: stringType()
  });
  var DocumentSpec1$outboundSchema = objectType({
    url: stringType()
  });
  var DocumentSpec1$;
  (function(DocumentSpec1$2) {
    DocumentSpec1$2.inboundSchema = DocumentSpec1$inboundSchema;
    DocumentSpec1$2.outboundSchema = DocumentSpec1$outboundSchema;
  })(DocumentSpec1$ || (DocumentSpec1$ = {}));
  var DocumentSpecUnion$inboundSchema = unionType([
    lazyType(() => DocumentSpec3$inboundSchema),
    lazyType(() => DocumentSpec4$inboundSchema),
    lazyType(() => DocumentSpec1$inboundSchema),
    lazyType(() => DocumentSpec2$inboundSchema)
  ]);
  var DocumentSpecUnion$outboundSchema = unionType([
    lazyType(() => DocumentSpec3$outboundSchema),
    lazyType(() => DocumentSpec4$outboundSchema),
    lazyType(() => DocumentSpec1$outboundSchema),
    lazyType(() => DocumentSpec2$outboundSchema)
  ]);
  var DocumentSpecUnion$;
  (function(DocumentSpecUnion$2) {
    DocumentSpecUnion$2.inboundSchema = DocumentSpecUnion$inboundSchema;
    DocumentSpecUnion$2.outboundSchema = DocumentSpecUnion$outboundSchema;
  })(DocumentSpecUnion$ || (DocumentSpecUnion$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/restrictionfilters.js
  var RestrictionFilters$inboundSchema = objectType({
    containerSpecs: arrayType(DocumentSpecUnion$inboundSchema).optional()
  });
  var RestrictionFilters$outboundSchema = objectType({
    containerSpecs: arrayType(DocumentSpecUnion$outboundSchema).optional()
  });
  var RestrictionFilters$;
  (function(RestrictionFilters$2) {
    RestrictionFilters$2.inboundSchema = RestrictionFilters$inboundSchema;
    RestrictionFilters$2.outboundSchema = RestrictionFilters$outboundSchema;
  })(RestrictionFilters$ || (RestrictionFilters$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/searchrequestoptions.js
  var ResponseHint = {
    AllResultCounts: "ALL_RESULT_COUNTS",
    FacetResults: "FACET_RESULTS",
    QueryMetadata: "QUERY_METADATA",
    Results: "RESULTS",
    SpellcheckMetadata: "SPELLCHECK_METADATA"
  };
  var ResponseHint$inboundSchema = nativeEnumType(ResponseHint);
  var ResponseHint$outboundSchema = ResponseHint$inboundSchema;
  var ResponseHint$;
  (function(ResponseHint$2) {
    ResponseHint$2.inboundSchema = ResponseHint$inboundSchema;
    ResponseHint$2.outboundSchema = ResponseHint$outboundSchema;
  })(ResponseHint$ || (ResponseHint$ = {}));
  var SearchRequestOptions$inboundSchema = objectType({
    datasourceFilter: stringType().optional(),
    datasourcesFilter: arrayType(stringType()).optional(),
    queryOverridesFacetFilters: booleanType().optional(),
    facetFilters: arrayType(FacetFilter$inboundSchema).optional(),
    facetFilterSets: arrayType(FacetFilterSet$inboundSchema).optional(),
    facetBucketFilter: FacetBucketFilter$inboundSchema.optional(),
    facetBucketSize: numberType().int(),
    defaultFacets: arrayType(stringType()).optional(),
    authTokens: arrayType(AuthToken$inboundSchema).optional(),
    fetchAllDatasourceCounts: booleanType().optional(),
    responseHints: arrayType(ResponseHint$inboundSchema).optional(),
    timezoneOffset: numberType().int().optional(),
    disableSpellcheck: booleanType().optional(),
    disableQueryAutocorrect: booleanType().optional(),
    returnLlmContentOverSnippets: booleanType().optional(),
    inclusions: RestrictionFilters$inboundSchema.optional(),
    exclusions: RestrictionFilters$inboundSchema.optional()
  });
  var SearchRequestOptions$outboundSchema = objectType({
    datasourceFilter: stringType().optional(),
    datasourcesFilter: arrayType(stringType()).optional(),
    queryOverridesFacetFilters: booleanType().optional(),
    facetFilters: arrayType(FacetFilter$outboundSchema).optional(),
    facetFilterSets: arrayType(FacetFilterSet$outboundSchema).optional(),
    facetBucketFilter: FacetBucketFilter$outboundSchema.optional(),
    facetBucketSize: numberType().int(),
    defaultFacets: arrayType(stringType()).optional(),
    authTokens: arrayType(AuthToken$outboundSchema).optional(),
    fetchAllDatasourceCounts: booleanType().optional(),
    responseHints: arrayType(ResponseHint$outboundSchema).optional(),
    timezoneOffset: numberType().int().optional(),
    disableSpellcheck: booleanType().optional(),
    disableQueryAutocorrect: booleanType().optional(),
    returnLlmContentOverSnippets: booleanType().optional(),
    inclusions: RestrictionFilters$outboundSchema.optional(),
    exclusions: RestrictionFilters$outboundSchema.optional()
  });
  var SearchRequestOptions$;
  (function(SearchRequestOptions$2) {
    SearchRequestOptions$2.inboundSchema = SearchRequestOptions$inboundSchema;
    SearchRequestOptions$2.outboundSchema = SearchRequestOptions$outboundSchema;
  })(SearchRequestOptions$ || (SearchRequestOptions$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/textrange.js
  var TextRangeType = {
    Bold: "BOLD",
    Citation: "CITATION",
    Highlight: "HIGHLIGHT",
    Link: "LINK"
  };
  var TextRangeType$inboundSchema = nativeEnumType(TextRangeType);
  var TextRangeType$outboundSchema = TextRangeType$inboundSchema;
  var TextRangeType$;
  (function(TextRangeType$2) {
    TextRangeType$2.inboundSchema = TextRangeType$inboundSchema;
    TextRangeType$2.outboundSchema = TextRangeType$outboundSchema;
  })(TextRangeType$ || (TextRangeType$ = {}));
  var TextRange$inboundSchema = objectType({
    startIndex: numberType().int(),
    endIndex: numberType().int().optional(),
    type: TextRangeType$inboundSchema.optional(),
    url: stringType().optional(),
    document: lazyType(() => Document$inboundSchema).optional()
  });
  var TextRange$outboundSchema = objectType({
    startIndex: numberType().int(),
    endIndex: numberType().int().optional(),
    type: TextRangeType$outboundSchema.optional(),
    url: stringType().optional(),
    document: lazyType(() => Document$outboundSchema).optional()
  });
  var TextRange$;
  (function(TextRange$2) {
    TextRange$2.inboundSchema = TextRange$inboundSchema;
    TextRange$2.outboundSchema = TextRange$outboundSchema;
  })(TextRange$ || (TextRange$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/querysuggestion.js
  var QuerySuggestion$inboundSchema = objectType({
    missingTerm: stringType().optional(),
    query: stringType(),
    searchProviderInfo: SearchProviderInfo$inboundSchema.optional(),
    label: stringType().optional(),
    datasource: stringType().optional(),
    requestOptions: SearchRequestOptions$inboundSchema.optional(),
    ranges: arrayType(lazyType(() => TextRange$inboundSchema)).optional(),
    inputDetails: SearchRequestInputDetails$inboundSchema.optional()
  });
  var QuerySuggestion$outboundSchema = objectType({
    missingTerm: stringType().optional(),
    query: stringType(),
    searchProviderInfo: SearchProviderInfo$outboundSchema.optional(),
    label: stringType().optional(),
    datasource: stringType().optional(),
    requestOptions: SearchRequestOptions$outboundSchema.optional(),
    ranges: arrayType(lazyType(() => TextRange$outboundSchema)).optional(),
    inputDetails: SearchRequestInputDetails$outboundSchema.optional()
  });
  var QuerySuggestion$;
  (function(QuerySuggestion$2) {
    QuerySuggestion$2.inboundSchema = QuerySuggestion$inboundSchema;
    QuerySuggestion$2.outboundSchema = QuerySuggestion$outboundSchema;
  })(QuerySuggestion$ || (QuerySuggestion$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/querysuggestionlist.js
  var QuerySuggestionList$inboundSchema = objectType({
    suggestions: arrayType(lazyType(() => QuerySuggestion$inboundSchema)).optional(),
    person: lazyType(() => Person$inboundSchema).optional()
  });
  var QuerySuggestionList$outboundSchema = objectType({
    suggestions: arrayType(lazyType(() => QuerySuggestion$outboundSchema)).optional(),
    person: lazyType(() => Person$outboundSchema).optional()
  });
  var QuerySuggestionList$;
  (function(QuerySuggestionList$2) {
    QuerySuggestionList$2.inboundSchema = QuerySuggestionList$inboundSchema;
    QuerySuggestionList$2.outboundSchema = QuerySuggestionList$outboundSchema;
  })(QuerySuggestionList$ || (QuerySuggestionList$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/socialnetwork.js
  var SocialNetwork$inboundSchema = objectType({
    name: stringType(),
    profileName: stringType().optional(),
    profileUrl: stringType()
  });
  var SocialNetwork$outboundSchema = objectType({
    name: stringType(),
    profileName: stringType().optional(),
    profileUrl: stringType()
  });
  var SocialNetwork$;
  (function(SocialNetwork$2) {
    SocialNetwork$2.inboundSchema = SocialNetwork$inboundSchema;
    SocialNetwork$2.outboundSchema = SocialNetwork$outboundSchema;
  })(SocialNetwork$ || (SocialNetwork$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/structuredlocation.js
  var StructuredLocation$inboundSchema = objectType({
    deskLocation: stringType().optional(),
    timezone: stringType().optional(),
    address: stringType().optional(),
    city: stringType().optional(),
    state: stringType().optional(),
    region: stringType().optional(),
    zipCode: stringType().optional(),
    country: stringType().optional(),
    countryCode: stringType().optional()
  });
  var StructuredLocation$outboundSchema = objectType({
    deskLocation: stringType().optional(),
    timezone: stringType().optional(),
    address: stringType().optional(),
    city: stringType().optional(),
    state: stringType().optional(),
    region: stringType().optional(),
    zipCode: stringType().optional(),
    country: stringType().optional(),
    countryCode: stringType().optional()
  });
  var StructuredLocation$;
  (function(StructuredLocation$2) {
    StructuredLocation$2.inboundSchema = StructuredLocation$inboundSchema;
    StructuredLocation$2.outboundSchema = StructuredLocation$outboundSchema;
  })(StructuredLocation$ || (StructuredLocation$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/personmetadata.js
  var PersonMetadataType = {
    FullTime: "FULL_TIME",
    Contractor: "CONTRACTOR",
    NonEmployee: "NON_EMPLOYEE",
    FormerEmployee: "FORMER_EMPLOYEE"
  };
  var PersonMetadataType$inboundSchema = nativeEnumType(PersonMetadataType);
  var PersonMetadataType$outboundSchema = PersonMetadataType$inboundSchema;
  var PersonMetadataType$;
  (function(PersonMetadataType$2) {
    PersonMetadataType$2.inboundSchema = PersonMetadataType$inboundSchema;
    PersonMetadataType$2.outboundSchema = PersonMetadataType$outboundSchema;
  })(PersonMetadataType$ || (PersonMetadataType$ = {}));
  var PersonMetadata$inboundSchema = objectType({
    type: PersonMetadataType$inboundSchema.optional(),
    firstName: stringType().optional(),
    lastName: stringType().optional(),
    title: stringType().optional(),
    businessUnit: stringType().optional(),
    department: stringType().optional(),
    teams: arrayType(PersonTeam$inboundSchema).optional(),
    departmentCount: numberType().int().optional(),
    email: stringType().optional(),
    aliasEmails: arrayType(stringType()).optional(),
    location: stringType().optional(),
    structuredLocation: StructuredLocation$inboundSchema.optional(),
    externalProfileLink: stringType().optional(),
    manager: lazyType(() => Person$inboundSchema).optional(),
    managementChain: arrayType(lazyType(() => Person$inboundSchema)).optional(),
    phone: stringType().optional(),
    timezone: stringType().optional(),
    timezoneOffset: numberType().int().optional(),
    photoUrl: stringType().optional(),
    uneditedPhotoUrl: stringType().optional(),
    bannerUrl: stringType().optional(),
    reports: arrayType(lazyType(() => Person$inboundSchema)).optional(),
    startDate: stringType().transform((v) => new RFCDate(v)).optional(),
    endDate: stringType().transform((v) => new RFCDate(v)).optional(),
    bio: stringType().optional(),
    pronoun: stringType().optional(),
    orgSizeCount: numberType().int().optional(),
    directReportsCount: numberType().int().optional(),
    preferredName: stringType().optional(),
    socialNetwork: arrayType(SocialNetwork$inboundSchema).optional(),
    datasourceProfile: arrayType(DatasourceProfile$inboundSchema).optional(),
    querySuggestions: lazyType(() => QuerySuggestionList$inboundSchema).optional(),
    peopleDistance: arrayType(PersonDistance$inboundSchema).optional(),
    inviteInfo: lazyType(() => InviteInfo$inboundSchema).optional(),
    isSignedUp: booleanType().optional(),
    lastExtensionUse: stringType().datetime({ offset: true }).transform((v) => new Date(v)).optional(),
    permissions: Permissions$inboundSchema.optional(),
    customFields: arrayType(lazyType(() => CustomFieldData$inboundSchema)).optional(),
    loggingId: stringType().optional(),
    startDatePercentile: numberType().optional(),
    busyEvents: arrayType(AnonymousEvent$inboundSchema).optional(),
    profileBoolSettings: recordType(booleanType()).optional(),
    badges: arrayType(Badge$inboundSchema).optional(),
    isOrgRoot: booleanType().optional()
  });
  var PersonMetadata$outboundSchema = objectType({
    type: PersonMetadataType$outboundSchema.optional(),
    firstName: stringType().optional(),
    lastName: stringType().optional(),
    title: stringType().optional(),
    businessUnit: stringType().optional(),
    department: stringType().optional(),
    teams: arrayType(PersonTeam$outboundSchema).optional(),
    departmentCount: numberType().int().optional(),
    email: stringType().optional(),
    aliasEmails: arrayType(stringType()).optional(),
    location: stringType().optional(),
    structuredLocation: StructuredLocation$outboundSchema.optional(),
    externalProfileLink: stringType().optional(),
    manager: lazyType(() => Person$outboundSchema).optional(),
    managementChain: arrayType(lazyType(() => Person$outboundSchema)).optional(),
    phone: stringType().optional(),
    timezone: stringType().optional(),
    timezoneOffset: numberType().int().optional(),
    photoUrl: stringType().optional(),
    uneditedPhotoUrl: stringType().optional(),
    bannerUrl: stringType().optional(),
    reports: arrayType(lazyType(() => Person$outboundSchema)).optional(),
    startDate: instanceOfType(RFCDate).transform((v) => v.toString()).optional(),
    endDate: instanceOfType(RFCDate).transform((v) => v.toString()).optional(),
    bio: stringType().optional(),
    pronoun: stringType().optional(),
    orgSizeCount: numberType().int().optional(),
    directReportsCount: numberType().int().optional(),
    preferredName: stringType().optional(),
    socialNetwork: arrayType(SocialNetwork$outboundSchema).optional(),
    datasourceProfile: arrayType(DatasourceProfile$outboundSchema).optional(),
    querySuggestions: lazyType(() => QuerySuggestionList$outboundSchema).optional(),
    peopleDistance: arrayType(PersonDistance$outboundSchema).optional(),
    inviteInfo: lazyType(() => InviteInfo$outboundSchema).optional(),
    isSignedUp: booleanType().optional(),
    lastExtensionUse: dateType().transform((v) => v.toISOString()).optional(),
    permissions: Permissions$outboundSchema.optional(),
    customFields: arrayType(lazyType(() => CustomFieldData$outboundSchema)).optional(),
    loggingId: stringType().optional(),
    startDatePercentile: numberType().optional(),
    busyEvents: arrayType(AnonymousEvent$outboundSchema).optional(),
    profileBoolSettings: recordType(booleanType()).optional(),
    badges: arrayType(Badge$outboundSchema).optional(),
    isOrgRoot: booleanType().optional()
  });
  var PersonMetadata$;
  (function(PersonMetadata$2) {
    PersonMetadata$2.inboundSchema = PersonMetadata$inboundSchema;
    PersonMetadata$2.outboundSchema = PersonMetadata$outboundSchema;
  })(PersonMetadata$ || (PersonMetadata$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/clustertypeenum.js
  var ClusterTypeEnum = {
    Similar: "SIMILAR",
    Freshness: "FRESHNESS",
    Title: "TITLE",
    Content: "CONTENT",
    None: "NONE",
    ThreadReply: "THREAD_REPLY",
    ThreadRoot: "THREAD_ROOT",
    Prefix: "PREFIX",
    Suffix: "SUFFIX",
    AuthorPrefix: "AUTHOR_PREFIX",
    AuthorSuffix: "AUTHOR_SUFFIX"
  };
  var ClusterTypeEnum$inboundSchema = nativeEnumType(ClusterTypeEnum);
  var ClusterTypeEnum$outboundSchema = ClusterTypeEnum$inboundSchema;
  var ClusterTypeEnum$;
  (function(ClusterTypeEnum$2) {
    ClusterTypeEnum$2.inboundSchema = ClusterTypeEnum$inboundSchema;
    ClusterTypeEnum$2.outboundSchema = ClusterTypeEnum$outboundSchema;
  })(ClusterTypeEnum$ || (ClusterTypeEnum$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/clustergroup.js
  var ClusterGroup$inboundSchema = objectType({
    clusteredResults: arrayType(lazyType(() => SearchResult$inboundSchema)).optional(),
    clusterType: ClusterTypeEnum$inboundSchema.optional(),
    visibleCountHint: numberType().int()
  });
  var ClusterGroup$outboundSchema = objectType({
    clusteredResults: arrayType(lazyType(() => SearchResult$outboundSchema)).optional(),
    clusterType: ClusterTypeEnum$outboundSchema.optional(),
    visibleCountHint: numberType().int()
  });
  var ClusterGroup$;
  (function(ClusterGroup$2) {
    ClusterGroup$2.inboundSchema = ClusterGroup$inboundSchema;
    ClusterGroup$2.outboundSchema = ClusterGroup$outboundSchema;
  })(ClusterGroup$ || (ClusterGroup$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/pindocument.js
  var PinDocument$inboundSchema = objectType({
    queries: arrayType(stringType()).optional(),
    audienceFilters: arrayType(FacetFilter$inboundSchema).optional(),
    id: stringType().optional(),
    documentId: stringType(),
    attribution: lazyType(() => Person$inboundSchema).optional(),
    updatedBy: lazyType(() => Person$inboundSchema).optional(),
    createTime: stringType().datetime({ offset: true }).transform((v) => new Date(v)).optional(),
    updateTime: stringType().datetime({ offset: true }).transform((v) => new Date(v)).optional()
  });
  var PinDocument$outboundSchema = objectType({
    queries: arrayType(stringType()).optional(),
    audienceFilters: arrayType(FacetFilter$outboundSchema).optional(),
    id: stringType().optional(),
    documentId: stringType(),
    attribution: lazyType(() => Person$outboundSchema).optional(),
    updatedBy: lazyType(() => Person$outboundSchema).optional(),
    createTime: dateType().transform((v) => v.toISOString()).optional(),
    updateTime: dateType().transform((v) => v.toISOString()).optional()
  });
  var PinDocument$;
  (function(PinDocument$2) {
    PinDocument$2.inboundSchema = PinDocument$inboundSchema;
    PinDocument$2.outboundSchema = PinDocument$outboundSchema;
  })(PinDocument$ || (PinDocument$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/searchresultprominenceenum.js
  var SearchResultProminenceEnum = {
    Hero: "HERO",
    Promoted: "PROMOTED",
    Standard: "STANDARD"
  };
  var SearchResultProminenceEnum$inboundSchema = nativeEnumType(SearchResultProminenceEnum);
  var SearchResultProminenceEnum$outboundSchema = SearchResultProminenceEnum$inboundSchema;
  var SearchResultProminenceEnum$;
  (function(SearchResultProminenceEnum$2) {
    SearchResultProminenceEnum$2.inboundSchema = SearchResultProminenceEnum$inboundSchema;
    SearchResultProminenceEnum$2.outboundSchema = SearchResultProminenceEnum$outboundSchema;
  })(SearchResultProminenceEnum$ || (SearchResultProminenceEnum$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/searchresultsnippet.js
  var SearchResultSnippet$inboundSchema = objectType({
    mimeType: stringType().optional(),
    text: stringType().optional(),
    snippetTextOrdering: numberType().int().optional(),
    ranges: arrayType(lazyType(() => TextRange$inboundSchema)).optional(),
    url: stringType().optional(),
    snippet: stringType()
  });
  var SearchResultSnippet$outboundSchema = objectType({
    mimeType: stringType().optional(),
    text: stringType().optional(),
    snippetTextOrdering: numberType().int().optional(),
    ranges: arrayType(lazyType(() => TextRange$outboundSchema)).optional(),
    url: stringType().optional(),
    snippet: stringType()
  });
  var SearchResultSnippet$;
  (function(SearchResultSnippet$2) {
    SearchResultSnippet$2.inboundSchema = SearchResultSnippet$inboundSchema;
    SearchResultSnippet$2.outboundSchema = SearchResultSnippet$outboundSchema;
  })(SearchResultSnippet$ || (SearchResultSnippet$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/objectpermissions.js
  var ObjectPermissions$inboundSchema = objectType({
    write: WritePermission$inboundSchema.optional()
  });
  var ObjectPermissions$outboundSchema = objectType({
    write: WritePermission$outboundSchema.optional()
  });
  var ObjectPermissions$;
  (function(ObjectPermissions$2) {
    ObjectPermissions$2.inboundSchema = ObjectPermissions$inboundSchema;
    ObjectPermissions$2.outboundSchema = ObjectPermissions$outboundSchema;
  })(ObjectPermissions$ || (ObjectPermissions$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/grouptype.js
  var GroupType = {
    Department: "DEPARTMENT",
    All: "ALL",
    Team: "TEAM",
    JobTitle: "JOB_TITLE",
    RoleType: "ROLE_TYPE",
    Location: "LOCATION",
    Region: "REGION",
    ExternalGroup: "EXTERNAL_GROUP"
  };
  var GroupType$inboundSchema = nativeEnumType(GroupType);
  var GroupType$outboundSchema = GroupType$inboundSchema;
  var GroupType$;
  (function(GroupType$2) {
    GroupType$2.inboundSchema = GroupType$inboundSchema;
    GroupType$2.outboundSchema = GroupType$outboundSchema;
  })(GroupType$ || (GroupType$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/group.js
  var Group$inboundSchema = objectType({
    type: GroupType$inboundSchema,
    id: stringType(),
    name: stringType().optional(),
    datasourceInstance: stringType().optional(),
    provisioningId: stringType().optional()
  });
  var Group$outboundSchema = objectType({
    type: GroupType$outboundSchema,
    id: stringType(),
    name: stringType().optional(),
    datasourceInstance: stringType().optional(),
    provisioningId: stringType().optional()
  });
  var Group$;
  (function(Group$2) {
    Group$2.inboundSchema = Group$inboundSchema;
    Group$2.outboundSchema = Group$outboundSchema;
  })(Group$ || (Group$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/userrole.js
  var UserRole = {
    Owner: "OWNER",
    Viewer: "VIEWER",
    AnswerModerator: "ANSWER_MODERATOR",
    Editor: "EDITOR",
    Verifier: "VERIFIER"
  };
  var UserRole$inboundSchema = nativeEnumType(UserRole);
  var UserRole$outboundSchema = UserRole$inboundSchema;
  var UserRole$;
  (function(UserRole$2) {
    UserRole$2.inboundSchema = UserRole$inboundSchema;
    UserRole$2.outboundSchema = UserRole$outboundSchema;
  })(UserRole$ || (UserRole$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/userrolespecification.js
  var UserRoleSpecification$inboundSchema = objectType({
    sourceDocumentSpec: DocumentSpecUnion$inboundSchema.optional(),
    person: lazyType(() => Person$inboundSchema).optional(),
    group: Group$inboundSchema.optional(),
    role: UserRole$inboundSchema
  });
  var UserRoleSpecification$outboundSchema = objectType({
    sourceDocumentSpec: DocumentSpecUnion$outboundSchema.optional(),
    person: lazyType(() => Person$outboundSchema).optional(),
    group: Group$outboundSchema.optional(),
    role: UserRole$outboundSchema
  });
  var UserRoleSpecification$;
  (function(UserRoleSpecification$2) {
    UserRoleSpecification$2.inboundSchema = UserRoleSpecification$inboundSchema;
    UserRoleSpecification$2.outboundSchema = UserRoleSpecification$outboundSchema;
  })(UserRoleSpecification$ || (UserRoleSpecification$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/answerboard.js
  var AnswerBoard$inboundSchema = objectType({
    name: stringType(),
    description: stringType(),
    addedRoles: arrayType(lazyType(() => UserRoleSpecification$inboundSchema)).optional(),
    removedRoles: arrayType(lazyType(() => UserRoleSpecification$inboundSchema)).optional(),
    audienceFilters: arrayType(FacetFilter$inboundSchema).optional(),
    permissions: ObjectPermissions$inboundSchema.optional(),
    id: numberType().int(),
    createTime: stringType().datetime({ offset: true }).transform((v) => new Date(v)).optional(),
    updateTime: stringType().datetime({ offset: true }).transform((v) => new Date(v)).optional(),
    creator: lazyType(() => Person$inboundSchema).optional(),
    updatedBy: lazyType(() => Person$inboundSchema).optional(),
    itemCount: numberType().int().optional(),
    roles: arrayType(lazyType(() => UserRoleSpecification$inboundSchema)).optional()
  });
  var AnswerBoard$outboundSchema = objectType({
    name: stringType(),
    description: stringType(),
    addedRoles: arrayType(lazyType(() => UserRoleSpecification$outboundSchema)).optional(),
    removedRoles: arrayType(lazyType(() => UserRoleSpecification$outboundSchema)).optional(),
    audienceFilters: arrayType(FacetFilter$outboundSchema).optional(),
    permissions: ObjectPermissions$outboundSchema.optional(),
    id: numberType().int(),
    createTime: dateType().transform((v) => v.toISOString()).optional(),
    updateTime: dateType().transform((v) => v.toISOString()).optional(),
    creator: lazyType(() => Person$outboundSchema).optional(),
    updatedBy: lazyType(() => Person$outboundSchema).optional(),
    itemCount: numberType().int().optional(),
    roles: arrayType(lazyType(() => UserRoleSpecification$outboundSchema)).optional()
  });
  var AnswerBoard$;
  (function(AnswerBoard$2) {
    AnswerBoard$2.inboundSchema = AnswerBoard$inboundSchema;
    AnswerBoard$2.outboundSchema = AnswerBoard$outboundSchema;
  })(AnswerBoard$ || (AnswerBoard$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/answerlike.js
  var AnswerLike$inboundSchema = objectType({
    user: lazyType(() => Person$inboundSchema).optional(),
    createTime: stringType().datetime({ offset: true }).transform((v) => new Date(v)).optional()
  });
  var AnswerLike$outboundSchema = objectType({
    user: lazyType(() => Person$outboundSchema).optional(),
    createTime: dateType().transform((v) => v.toISOString()).optional()
  });
  var AnswerLike$;
  (function(AnswerLike$2) {
    AnswerLike$2.inboundSchema = AnswerLike$inboundSchema;
    AnswerLike$2.outboundSchema = AnswerLike$outboundSchema;
  })(AnswerLike$ || (AnswerLike$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/answerlikes.js
  var AnswerLikes$inboundSchema = objectType({
    likedBy: arrayType(lazyType(() => AnswerLike$inboundSchema)),
    likedByUser: booleanType(),
    numLikes: numberType().int()
  });
  var AnswerLikes$outboundSchema = objectType({
    likedBy: arrayType(lazyType(() => AnswerLike$outboundSchema)),
    likedByUser: booleanType(),
    numLikes: numberType().int()
  });
  var AnswerLikes$;
  (function(AnswerLikes$2) {
    AnswerLikes$2.inboundSchema = AnswerLikes$inboundSchema;
    AnswerLikes$2.outboundSchema = AnswerLikes$outboundSchema;
  })(AnswerLikes$ || (AnswerLikes$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/structuredtextitem.js
  var StructuredTextItem$inboundSchema = objectType({
    link: stringType().optional(),
    document: lazyType(() => Document$inboundSchema).optional(),
    text: stringType().optional(),
    structuredResult: lazyType(() => StructuredResult$inboundSchema).optional()
  });
  var StructuredTextItem$outboundSchema = objectType({
    link: stringType().optional(),
    document: lazyType(() => Document$outboundSchema).optional(),
    text: stringType().optional(),
    structuredResult: lazyType(() => StructuredResult$outboundSchema).optional()
  });
  var StructuredTextItem$;
  (function(StructuredTextItem$2) {
    StructuredTextItem$2.inboundSchema = StructuredTextItem$inboundSchema;
    StructuredTextItem$2.outboundSchema = StructuredTextItem$outboundSchema;
  })(StructuredTextItem$ || (StructuredTextItem$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/structuredtext.js
  var StructuredText$inboundSchema = objectType({
    text: stringType(),
    structuredList: arrayType(lazyType(() => StructuredTextItem$inboundSchema)).optional()
  });
  var StructuredText$outboundSchema = objectType({
    text: stringType(),
    structuredList: arrayType(lazyType(() => StructuredTextItem$outboundSchema)).optional()
  });
  var StructuredText$;
  (function(StructuredText$2) {
    StructuredText$2.inboundSchema = StructuredText$inboundSchema;
    StructuredText$2.outboundSchema = StructuredText$outboundSchema;
  })(StructuredText$ || (StructuredText$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/reminder.js
  var Reminder$inboundSchema = objectType({
    assignee: lazyType(() => Person$inboundSchema),
    requestor: lazyType(() => Person$inboundSchema).optional(),
    remindAt: numberType().int(),
    createdAt: numberType().int().optional(),
    reason: stringType().optional()
  });
  var Reminder$outboundSchema = objectType({
    assignee: lazyType(() => Person$outboundSchema),
    requestor: lazyType(() => Person$outboundSchema).optional(),
    remindAt: numberType().int(),
    createdAt: numberType().int().optional(),
    reason: stringType().optional()
  });
  var Reminder$;
  (function(Reminder$2) {
    Reminder$2.inboundSchema = Reminder$inboundSchema;
    Reminder$2.outboundSchema = Reminder$outboundSchema;
  })(Reminder$ || (Reminder$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/verificationmetadata.js
  var VerificationMetadata$inboundSchema = objectType({
    lastVerifier: lazyType(() => Person$inboundSchema).optional(),
    lastVerificationTs: numberType().int().optional(),
    expirationTs: numberType().int().optional(),
    document: lazyType(() => Document$inboundSchema).optional(),
    reminders: arrayType(lazyType(() => Reminder$inboundSchema)).optional(),
    lastReminder: lazyType(() => Reminder$inboundSchema).optional(),
    visitorCount: arrayType(CountInfo$inboundSchema).optional(),
    candidateVerifiers: arrayType(lazyType(() => Person$inboundSchema)).optional()
  });
  var VerificationMetadata$outboundSchema = objectType({
    lastVerifier: lazyType(() => Person$outboundSchema).optional(),
    lastVerificationTs: numberType().int().optional(),
    expirationTs: numberType().int().optional(),
    document: lazyType(() => Document$outboundSchema).optional(),
    reminders: arrayType(lazyType(() => Reminder$outboundSchema)).optional(),
    lastReminder: lazyType(() => Reminder$outboundSchema).optional(),
    visitorCount: arrayType(CountInfo$outboundSchema).optional(),
    candidateVerifiers: arrayType(lazyType(() => Person$outboundSchema)).optional()
  });
  var VerificationMetadata$;
  (function(VerificationMetadata$2) {
    VerificationMetadata$2.inboundSchema = VerificationMetadata$inboundSchema;
    VerificationMetadata$2.outboundSchema = VerificationMetadata$outboundSchema;
  })(VerificationMetadata$ || (VerificationMetadata$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/verification.js
  var State = {
    Unverified: "UNVERIFIED",
    Verified: "VERIFIED",
    Deprecated: "DEPRECATED"
  };
  var State$inboundSchema = nativeEnumType(State);
  var State$outboundSchema = State$inboundSchema;
  var State$;
  (function(State$2) {
    State$2.inboundSchema = State$inboundSchema;
    State$2.outboundSchema = State$outboundSchema;
  })(State$ || (State$ = {}));
  var Verification$inboundSchema = objectType({
    state: State$inboundSchema,
    metadata: lazyType(() => VerificationMetadata$inboundSchema).optional()
  });
  var Verification$outboundSchema = objectType({
    state: State$outboundSchema,
    metadata: lazyType(() => VerificationMetadata$outboundSchema).optional()
  });
  var Verification$;
  (function(Verification$2) {
    Verification$2.inboundSchema = Verification$inboundSchema;
    Verification$2.outboundSchema = Verification$outboundSchema;
  })(Verification$ || (Verification$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/answer.js
  var AnswerSourceType = {
    Document: "DOCUMENT",
    Assistant: "ASSISTANT"
  };
  var AnswerSourceType$inboundSchema = nativeEnumType(AnswerSourceType);
  var AnswerSourceType$outboundSchema = AnswerSourceType$inboundSchema;
  var AnswerSourceType$;
  (function(AnswerSourceType$2) {
    AnswerSourceType$2.inboundSchema = AnswerSourceType$inboundSchema;
    AnswerSourceType$2.outboundSchema = AnswerSourceType$outboundSchema;
  })(AnswerSourceType$ || (AnswerSourceType$ = {}));
  var Answer$inboundSchema = objectType({
    id: numberType().int(),
    docId: stringType().optional(),
    question: stringType().optional(),
    questionVariations: arrayType(stringType()).optional(),
    bodyText: stringType().optional(),
    boardId: numberType().int().optional(),
    audienceFilters: arrayType(FacetFilter$inboundSchema).optional(),
    addedRoles: arrayType(lazyType(() => UserRoleSpecification$inboundSchema)).optional(),
    removedRoles: arrayType(lazyType(() => UserRoleSpecification$inboundSchema)).optional(),
    roles: arrayType(lazyType(() => UserRoleSpecification$inboundSchema)).optional(),
    sourceDocumentSpec: DocumentSpecUnion$inboundSchema.optional(),
    sourceType: AnswerSourceType$inboundSchema.optional(),
    permissions: ObjectPermissions$inboundSchema.optional(),
    combinedAnswerText: lazyType(() => StructuredText$inboundSchema).optional(),
    likes: lazyType(() => AnswerLikes$inboundSchema).optional(),
    author: lazyType(() => Person$inboundSchema).optional(),
    createTime: stringType().datetime({ offset: true }).transform((v) => new Date(v)).optional(),
    updateTime: stringType().datetime({ offset: true }).transform((v) => new Date(v)).optional(),
    updatedBy: lazyType(() => Person$inboundSchema).optional(),
    verification: lazyType(() => Verification$inboundSchema).optional(),
    board: lazyType(() => AnswerBoard$inboundSchema).optional(),
    collections: arrayType(lazyType(() => Collection$inboundSchema)).optional(),
    documentCategory: stringType().optional(),
    sourceDocument: lazyType(() => Document$inboundSchema).optional()
  });
  var Answer$outboundSchema = objectType({
    id: numberType().int(),
    docId: stringType().optional(),
    question: stringType().optional(),
    questionVariations: arrayType(stringType()).optional(),
    bodyText: stringType().optional(),
    boardId: numberType().int().optional(),
    audienceFilters: arrayType(FacetFilter$outboundSchema).optional(),
    addedRoles: arrayType(lazyType(() => UserRoleSpecification$outboundSchema)).optional(),
    removedRoles: arrayType(lazyType(() => UserRoleSpecification$outboundSchema)).optional(),
    roles: arrayType(lazyType(() => UserRoleSpecification$outboundSchema)).optional(),
    sourceDocumentSpec: DocumentSpecUnion$outboundSchema.optional(),
    sourceType: AnswerSourceType$outboundSchema.optional(),
    permissions: ObjectPermissions$outboundSchema.optional(),
    combinedAnswerText: lazyType(() => StructuredText$outboundSchema).optional(),
    likes: lazyType(() => AnswerLikes$outboundSchema).optional(),
    author: lazyType(() => Person$outboundSchema).optional(),
    createTime: dateType().transform((v) => v.toISOString()).optional(),
    updateTime: dateType().transform((v) => v.toISOString()).optional(),
    updatedBy: lazyType(() => Person$outboundSchema).optional(),
    verification: lazyType(() => Verification$outboundSchema).optional(),
    board: lazyType(() => AnswerBoard$outboundSchema).optional(),
    collections: arrayType(lazyType(() => Collection$outboundSchema)).optional(),
    documentCategory: stringType().optional(),
    sourceDocument: lazyType(() => Document$outboundSchema).optional()
  });
  var Answer$;
  (function(Answer$2) {
    Answer$2.inboundSchema = Answer$inboundSchema;
    Answer$2.outboundSchema = Answer$outboundSchema;
  })(Answer$ || (Answer$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/appresult.js
  var AppResult$inboundSchema = objectType({
    datasource: stringType(),
    docType: stringType().optional(),
    mimeType: stringType().optional(),
    iconUrl: stringType().optional()
  });
  var AppResult$outboundSchema = objectType({
    datasource: stringType(),
    docType: stringType().optional(),
    mimeType: stringType().optional(),
    iconUrl: stringType().optional()
  });
  var AppResult$;
  (function(AppResult$2) {
    AppResult$2.inboundSchema = AppResult$inboundSchema;
    AppResult$2.outboundSchema = AppResult$outboundSchema;
  })(AppResult$ || (AppResult$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/codeline.js
  var CodeLine$inboundSchema = objectType({
    lineNumber: numberType().int().optional(),
    content: stringType().optional(),
    ranges: arrayType(lazyType(() => TextRange$inboundSchema)).optional()
  });
  var CodeLine$outboundSchema = objectType({
    lineNumber: numberType().int().optional(),
    content: stringType().optional(),
    ranges: arrayType(lazyType(() => TextRange$outboundSchema)).optional()
  });
  var CodeLine$;
  (function(CodeLine$2) {
    CodeLine$2.inboundSchema = CodeLine$inboundSchema;
    CodeLine$2.outboundSchema = CodeLine$outboundSchema;
  })(CodeLine$ || (CodeLine$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/code.js
  var Code$inboundSchema = objectType({
    repoName: stringType().optional(),
    fileName: stringType().optional(),
    fileUrl: stringType().optional(),
    lines: arrayType(lazyType(() => CodeLine$inboundSchema)).optional(),
    isLastMatch: booleanType().optional()
  });
  var Code$outboundSchema = objectType({
    repoName: stringType().optional(),
    fileName: stringType().optional(),
    fileUrl: stringType().optional(),
    lines: arrayType(lazyType(() => CodeLine$outboundSchema)).optional(),
    isLastMatch: booleanType().optional()
  });
  var Code$;
  (function(Code$2) {
    Code$2.inboundSchema = Code$inboundSchema;
    Code$2.outboundSchema = Code$outboundSchema;
  })(Code$ || (Code$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/customentitymetadata.js
  var CustomEntityMetadata$inboundSchema = objectType({
    customData: recordType(CustomDataValue$inboundSchema).optional()
  });
  var CustomEntityMetadata$outboundSchema = objectType({
    customData: recordType(CustomDataValue$outboundSchema).optional()
  });
  var CustomEntityMetadata$;
  (function(CustomEntityMetadata$2) {
    CustomEntityMetadata$2.inboundSchema = CustomEntityMetadata$inboundSchema;
    CustomEntityMetadata$2.outboundSchema = CustomEntityMetadata$outboundSchema;
  })(CustomEntityMetadata$ || (CustomEntityMetadata$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/customentity.js
  var CustomEntity$inboundSchema = objectType({
    permissions: ObjectPermissions$inboundSchema.optional(),
    id: stringType().optional(),
    title: stringType().optional(),
    datasource: stringType().optional(),
    objectType: stringType().optional(),
    metadata: CustomEntityMetadata$inboundSchema.optional(),
    roles: arrayType(lazyType(() => UserRoleSpecification$inboundSchema)).optional()
  });
  var CustomEntity$outboundSchema = objectType({
    permissions: ObjectPermissions$outboundSchema.optional(),
    id: stringType().optional(),
    title: stringType().optional(),
    datasource: stringType().optional(),
    objectType: stringType().optional(),
    metadata: CustomEntityMetadata$outboundSchema.optional(),
    roles: arrayType(lazyType(() => UserRoleSpecification$outboundSchema)).optional()
  });
  var CustomEntity$;
  (function(CustomEntity$2) {
    CustomEntity$2.inboundSchema = CustomEntity$inboundSchema;
    CustomEntity$2.outboundSchema = CustomEntity$outboundSchema;
  })(CustomEntity$ || (CustomEntity$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/company.js
  var Company$inboundSchema = objectType({
    name: stringType(),
    profileUrl: stringType().optional(),
    websiteUrls: arrayType(stringType()).optional(),
    logoUrl: stringType().optional(),
    location: stringType().optional(),
    phone: stringType().optional(),
    fax: stringType().optional(),
    industry: stringType().optional(),
    annualRevenue: numberType().optional(),
    numberOfEmployees: numberType().int().optional(),
    stockSymbol: stringType().optional(),
    foundedDate: stringType().transform((v) => new RFCDate(v)).optional(),
    about: stringType().optional()
  });
  var Company$outboundSchema = objectType({
    name: stringType(),
    profileUrl: stringType().optional(),
    websiteUrls: arrayType(stringType()).optional(),
    logoUrl: stringType().optional(),
    location: stringType().optional(),
    phone: stringType().optional(),
    fax: stringType().optional(),
    industry: stringType().optional(),
    annualRevenue: numberType().optional(),
    numberOfEmployees: numberType().int().optional(),
    stockSymbol: stringType().optional(),
    foundedDate: instanceOfType(RFCDate).transform((v) => v.toString()).optional(),
    about: stringType().optional()
  });
  var Company$;
  (function(Company$2) {
    Company$2.inboundSchema = Company$inboundSchema;
    Company$2.outboundSchema = Company$outboundSchema;
  })(Company$ || (Company$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/customermetadata.js
  var CustomerMetadata$inboundSchema = objectType({
    datasourceId: stringType().optional(),
    customData: recordType(CustomDataValue$inboundSchema).optional()
  });
  var CustomerMetadata$outboundSchema = objectType({
    datasourceId: stringType().optional(),
    customData: recordType(CustomDataValue$outboundSchema).optional()
  });
  var CustomerMetadata$;
  (function(CustomerMetadata$2) {
    CustomerMetadata$2.inboundSchema = CustomerMetadata$inboundSchema;
    CustomerMetadata$2.outboundSchema = CustomerMetadata$outboundSchema;
  })(CustomerMetadata$ || (CustomerMetadata$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/customer.js
  var Customer$inboundSchema = objectType({
    id: stringType(),
    domains: arrayType(stringType()).optional(),
    company: Company$inboundSchema,
    documentCounts: recordType(numberType().int()).optional(),
    poc: arrayType(lazyType(() => Person$inboundSchema)).optional(),
    metadata: CustomerMetadata$inboundSchema.optional(),
    mergedCustomers: arrayType(lazyType(() => Customer$inboundSchema)).optional(),
    startDate: stringType().transform((v) => new RFCDate(v)).optional(),
    contractAnnualRevenue: numberType().optional(),
    notes: stringType().optional()
  });
  var Customer$outboundSchema = objectType({
    id: stringType(),
    domains: arrayType(stringType()).optional(),
    company: Company$outboundSchema,
    documentCounts: recordType(numberType().int()).optional(),
    poc: arrayType(lazyType(() => Person$outboundSchema)).optional(),
    metadata: CustomerMetadata$outboundSchema.optional(),
    mergedCustomers: arrayType(lazyType(() => Customer$outboundSchema)).optional(),
    startDate: instanceOfType(RFCDate).transform((v) => v.toString()).optional(),
    contractAnnualRevenue: numberType().optional(),
    notes: stringType().optional()
  });
  var Customer$;
  (function(Customer$2) {
    Customer$2.inboundSchema = Customer$inboundSchema;
    Customer$2.outboundSchema = Customer$outboundSchema;
  })(Customer$ || (Customer$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/entitytype.js
  var EntityType = {
    Person: "PERSON",
    Project: "PROJECT",
    Customer: "CUSTOMER"
  };
  var EntityType$inboundSchema = nativeEnumType(EntityType);
  var EntityType$outboundSchema = EntityType$inboundSchema;
  var EntityType$;
  (function(EntityType$2) {
    EntityType$2.inboundSchema = EntityType$inboundSchema;
    EntityType$2.outboundSchema = EntityType$outboundSchema;
  })(EntityType$ || (EntityType$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/disambiguation.js
  var Disambiguation$inboundSchema = objectType({
    name: stringType().optional(),
    id: stringType().optional(),
    type: EntityType$inboundSchema.optional()
  });
  var Disambiguation$outboundSchema = objectType({
    name: stringType().optional(),
    id: stringType().optional(),
    type: EntityType$outboundSchema.optional()
  });
  var Disambiguation$;
  (function(Disambiguation$2) {
    Disambiguation$2.inboundSchema = Disambiguation$inboundSchema;
    Disambiguation$2.outboundSchema = Disambiguation$outboundSchema;
  })(Disambiguation$ || (Disambiguation$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/extractedqna.js
  var ExtractedQnA$inboundSchema = objectType({
    heading: stringType().optional(),
    question: stringType().optional(),
    questionResult: lazyType(() => SearchResult$inboundSchema).optional()
  });
  var ExtractedQnA$outboundSchema = objectType({
    heading: stringType().optional(),
    question: stringType().optional(),
    questionResult: lazyType(() => SearchResult$outboundSchema).optional()
  });
  var ExtractedQnA$;
  (function(ExtractedQnA$2) {
    ExtractedQnA$2.inboundSchema = ExtractedQnA$inboundSchema;
    ExtractedQnA$2.outboundSchema = ExtractedQnA$outboundSchema;
  })(ExtractedQnA$ || (ExtractedQnA$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/followupaction.js
  var FollowupAction$inboundSchema = objectType({
    actionRunId: stringType().optional(),
    actionInstanceId: stringType().optional(),
    actionId: stringType().optional(),
    parameters: recordType(stringType()).optional(),
    recommendationText: stringType().optional(),
    actionLabel: stringType().optional(),
    userConfirmationRequired: booleanType().optional()
  });
  var FollowupAction$outboundSchema = objectType({
    actionRunId: stringType().optional(),
    actionInstanceId: stringType().optional(),
    actionId: stringType().optional(),
    parameters: recordType(stringType()).optional(),
    recommendationText: stringType().optional(),
    actionLabel: stringType().optional(),
    userConfirmationRequired: booleanType().optional()
  });
  var FollowupAction$;
  (function(FollowupAction$2) {
    FollowupAction$2.inboundSchema = FollowupAction$inboundSchema;
    FollowupAction$2.outboundSchema = FollowupAction$outboundSchema;
  })(FollowupAction$ || (FollowupAction$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/generatedqna.js
  var GeneratedQnaStatus = {
    Computing: "COMPUTING",
    Disabled: "DISABLED",
    Failed: "FAILED",
    NoAnswer: "NO_ANSWER",
    Skipped: "SKIPPED",
    Streaming: "STREAMING",
    Succeeded: "SUCCEEDED",
    Timeout: "TIMEOUT"
  };
  var GeneratedQnaStatus$inboundSchema = nativeEnumType(GeneratedQnaStatus);
  var GeneratedQnaStatus$outboundSchema = GeneratedQnaStatus$inboundSchema;
  var GeneratedQnaStatus$;
  (function(GeneratedQnaStatus$2) {
    GeneratedQnaStatus$2.inboundSchema = GeneratedQnaStatus$inboundSchema;
    GeneratedQnaStatus$2.outboundSchema = GeneratedQnaStatus$outboundSchema;
  })(GeneratedQnaStatus$ || (GeneratedQnaStatus$ = {}));
  var GeneratedQna$inboundSchema = objectType({
    question: stringType().optional(),
    answer: stringType().optional(),
    followUpPrompts: arrayType(stringType()).optional(),
    followupActions: arrayType(FollowupAction$inboundSchema).optional(),
    ranges: arrayType(lazyType(() => TextRange$inboundSchema)).optional(),
    status: GeneratedQnaStatus$inboundSchema.optional(),
    cursor: stringType().optional(),
    trackingToken: stringType().optional()
  });
  var GeneratedQna$outboundSchema = objectType({
    question: stringType().optional(),
    answer: stringType().optional(),
    followUpPrompts: arrayType(stringType()).optional(),
    followupActions: arrayType(FollowupAction$outboundSchema).optional(),
    ranges: arrayType(lazyType(() => TextRange$outboundSchema)).optional(),
    status: GeneratedQnaStatus$outboundSchema.optional(),
    cursor: stringType().optional(),
    trackingToken: stringType().optional()
  });
  var GeneratedQna$;
  (function(GeneratedQna$2) {
    GeneratedQna$2.inboundSchema = GeneratedQna$inboundSchema;
    GeneratedQna$2.outboundSchema = GeneratedQna$outboundSchema;
  })(GeneratedQna$ || (GeneratedQna$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/calendarattendee.js
  var ResponseStatus = {
    Accepted: "ACCEPTED",
    Declined: "DECLINED",
    NoResponse: "NO_RESPONSE",
    Tentative: "TENTATIVE"
  };
  var ResponseStatus$inboundSchema = nativeEnumType(ResponseStatus);
  var ResponseStatus$outboundSchema = ResponseStatus$inboundSchema;
  var ResponseStatus$;
  (function(ResponseStatus$2) {
    ResponseStatus$2.inboundSchema = ResponseStatus$inboundSchema;
    ResponseStatus$2.outboundSchema = ResponseStatus$outboundSchema;
  })(ResponseStatus$ || (ResponseStatus$ = {}));
  var CalendarAttendee$inboundSchema = objectType({
    isOrganizer: booleanType().optional(),
    isInGroup: booleanType().optional(),
    person: lazyType(() => Person$inboundSchema),
    groupAttendees: arrayType(lazyType(() => CalendarAttendee$inboundSchema)).optional(),
    responseStatus: ResponseStatus$inboundSchema.optional()
  });
  var CalendarAttendee$outboundSchema = objectType({
    isOrganizer: booleanType().optional(),
    isInGroup: booleanType().optional(),
    person: lazyType(() => Person$outboundSchema),
    groupAttendees: arrayType(lazyType(() => CalendarAttendee$outboundSchema)).optional(),
    responseStatus: ResponseStatus$outboundSchema.optional()
  });
  var CalendarAttendee$;
  (function(CalendarAttendee$2) {
    CalendarAttendee$2.inboundSchema = CalendarAttendee$inboundSchema;
    CalendarAttendee$2.outboundSchema = CalendarAttendee$outboundSchema;
  })(CalendarAttendee$ || (CalendarAttendee$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/calendarattendees.js
  var CalendarAttendees$inboundSchema = objectType({
    people: arrayType(lazyType(() => CalendarAttendee$inboundSchema)).optional(),
    isLimit: booleanType().optional(),
    total: numberType().int().optional(),
    numAccepted: numberType().int().optional(),
    numDeclined: numberType().int().optional(),
    numNoResponse: numberType().int().optional(),
    numTentative: numberType().int().optional()
  });
  var CalendarAttendees$outboundSchema = objectType({
    people: arrayType(lazyType(() => CalendarAttendee$outboundSchema)).optional(),
    isLimit: booleanType().optional(),
    total: numberType().int().optional(),
    numAccepted: numberType().int().optional(),
    numDeclined: numberType().int().optional(),
    numNoResponse: numberType().int().optional(),
    numTentative: numberType().int().optional()
  });
  var CalendarAttendees$;
  (function(CalendarAttendees$2) {
    CalendarAttendees$2.inboundSchema = CalendarAttendees$inboundSchema;
    CalendarAttendees$2.outboundSchema = CalendarAttendees$outboundSchema;
  })(CalendarAttendees$ || (CalendarAttendees$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/meeting.js
  var Meeting$inboundSchema = objectType({
    id: stringType().optional(),
    title: stringType().optional(),
    description: stringType().optional(),
    url: stringType().optional(),
    startTime: stringType().datetime({ offset: true }).transform((v) => new Date(v)).optional(),
    endTime: stringType().datetime({ offset: true }).transform((v) => new Date(v)).optional(),
    attendees: lazyType(() => CalendarAttendees$inboundSchema).optional()
  });
  var Meeting$outboundSchema = objectType({
    id: stringType().optional(),
    title: stringType().optional(),
    description: stringType().optional(),
    url: stringType().optional(),
    startTime: dateType().transform((v) => v.toISOString()).optional(),
    endTime: dateType().transform((v) => v.toISOString()).optional(),
    attendees: lazyType(() => CalendarAttendees$outboundSchema).optional()
  });
  var Meeting$;
  (function(Meeting$2) {
    Meeting$2.inboundSchema = Meeting$inboundSchema;
    Meeting$2.outboundSchema = Meeting$outboundSchema;
  })(Meeting$ || (Meeting$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/relatedquestion.js
  var RelatedQuestion$inboundSchema = objectType({
    question: stringType().optional(),
    answer: stringType().optional(),
    ranges: arrayType(lazyType(() => TextRange$inboundSchema)).optional()
  });
  var RelatedQuestion$outboundSchema = objectType({
    question: stringType().optional(),
    answer: stringType().optional(),
    ranges: arrayType(lazyType(() => TextRange$outboundSchema)).optional()
  });
  var RelatedQuestion$;
  (function(RelatedQuestion$2) {
    RelatedQuestion$2.inboundSchema = RelatedQuestion$inboundSchema;
    RelatedQuestion$2.outboundSchema = RelatedQuestion$outboundSchema;
  })(RelatedQuestion$ || (RelatedQuestion$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/shortcut.js
  var Shortcut$inboundSchema = objectType({
    id: numberType().int().optional(),
    inputAlias: stringType(),
    destinationUrl: stringType().optional(),
    destinationDocumentId: stringType().optional(),
    description: stringType().optional(),
    unlisted: booleanType().optional(),
    urlTemplate: stringType().optional(),
    addedRoles: arrayType(lazyType(() => UserRoleSpecification$inboundSchema)).optional(),
    removedRoles: arrayType(lazyType(() => UserRoleSpecification$inboundSchema)).optional(),
    permissions: ObjectPermissions$inboundSchema.optional(),
    createdBy: lazyType(() => Person$inboundSchema).optional(),
    createTime: stringType().datetime({ offset: true }).transform((v) => new Date(v)).optional(),
    updatedBy: lazyType(() => Person$inboundSchema).optional(),
    updateTime: stringType().datetime({ offset: true }).transform((v) => new Date(v)).optional(),
    destinationDocument: lazyType(() => Document$inboundSchema).optional(),
    intermediateUrl: stringType().optional(),
    viewPrefix: stringType().optional(),
    isExternal: booleanType().optional(),
    editUrl: stringType().optional(),
    alias: stringType().optional(),
    title: stringType().optional(),
    roles: arrayType(lazyType(() => UserRoleSpecification$inboundSchema)).optional()
  });
  var Shortcut$outboundSchema = objectType({
    id: numberType().int().optional(),
    inputAlias: stringType(),
    destinationUrl: stringType().optional(),
    destinationDocumentId: stringType().optional(),
    description: stringType().optional(),
    unlisted: booleanType().optional(),
    urlTemplate: stringType().optional(),
    addedRoles: arrayType(lazyType(() => UserRoleSpecification$outboundSchema)).optional(),
    removedRoles: arrayType(lazyType(() => UserRoleSpecification$outboundSchema)).optional(),
    permissions: ObjectPermissions$outboundSchema.optional(),
    createdBy: lazyType(() => Person$outboundSchema).optional(),
    createTime: dateType().transform((v) => v.toISOString()).optional(),
    updatedBy: lazyType(() => Person$outboundSchema).optional(),
    updateTime: dateType().transform((v) => v.toISOString()).optional(),
    destinationDocument: lazyType(() => Document$outboundSchema).optional(),
    intermediateUrl: stringType().optional(),
    viewPrefix: stringType().optional(),
    isExternal: booleanType().optional(),
    editUrl: stringType().optional(),
    alias: stringType().optional(),
    title: stringType().optional(),
    roles: arrayType(lazyType(() => UserRoleSpecification$outboundSchema)).optional()
  });
  var Shortcut$;
  (function(Shortcut$2) {
    Shortcut$2.inboundSchema = Shortcut$inboundSchema;
    Shortcut$2.outboundSchema = Shortcut$outboundSchema;
  })(Shortcut$ || (Shortcut$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/persontoteamrelationship.js
  var PersonToTeamRelationshipRelationship = {
    Member: "MEMBER",
    Manager: "MANAGER",
    Lead: "LEAD",
    PointOfContact: "POINT_OF_CONTACT",
    Other: "OTHER"
  };
  var PersonToTeamRelationshipRelationship$inboundSchema = nativeEnumType(PersonToTeamRelationshipRelationship);
  var PersonToTeamRelationshipRelationship$outboundSchema = PersonToTeamRelationshipRelationship$inboundSchema;
  var PersonToTeamRelationshipRelationship$;
  (function(PersonToTeamRelationshipRelationship$2) {
    PersonToTeamRelationshipRelationship$2.inboundSchema = PersonToTeamRelationshipRelationship$inboundSchema;
    PersonToTeamRelationshipRelationship$2.outboundSchema = PersonToTeamRelationshipRelationship$outboundSchema;
  })(PersonToTeamRelationshipRelationship$ || (PersonToTeamRelationshipRelationship$ = {}));
  var PersonToTeamRelationship$inboundSchema = objectType({
    person: lazyType(() => Person$inboundSchema),
    relationship: PersonToTeamRelationshipRelationship$inboundSchema.default("MEMBER"),
    customRelationshipStr: stringType().optional(),
    joinDate: stringType().datetime({ offset: true }).transform((v) => new Date(v)).optional()
  });
  var PersonToTeamRelationship$outboundSchema = objectType({
    person: lazyType(() => Person$outboundSchema),
    relationship: PersonToTeamRelationshipRelationship$outboundSchema.default("MEMBER"),
    customRelationshipStr: stringType().optional(),
    joinDate: dateType().transform((v) => v.toISOString()).optional()
  });
  var PersonToTeamRelationship$;
  (function(PersonToTeamRelationship$2) {
    PersonToTeamRelationship$2.inboundSchema = PersonToTeamRelationship$inboundSchema;
    PersonToTeamRelationship$2.outboundSchema = PersonToTeamRelationship$outboundSchema;
  })(PersonToTeamRelationship$ || (PersonToTeamRelationship$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/relatedobject.js
  var RelatedObjectMetadata$inboundSchema = objectType({
    name: stringType().optional()
  });
  var RelatedObjectMetadata$outboundSchema = objectType({
    name: stringType().optional()
  });
  var RelatedObjectMetadata$;
  (function(RelatedObjectMetadata$2) {
    RelatedObjectMetadata$2.inboundSchema = RelatedObjectMetadata$inboundSchema;
    RelatedObjectMetadata$2.outboundSchema = RelatedObjectMetadata$outboundSchema;
  })(RelatedObjectMetadata$ || (RelatedObjectMetadata$ = {}));
  var RelatedObject$inboundSchema = objectType({
    id: stringType(),
    metadata: lazyType(() => RelatedObjectMetadata$inboundSchema).optional()
  });
  var RelatedObject$outboundSchema = objectType({
    id: stringType(),
    metadata: lazyType(() => RelatedObjectMetadata$outboundSchema).optional()
  });
  var RelatedObject$;
  (function(RelatedObject$2) {
    RelatedObject$2.inboundSchema = RelatedObject$inboundSchema;
    RelatedObject$2.outboundSchema = RelatedObject$outboundSchema;
  })(RelatedObject$ || (RelatedObject$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/relatedobjectedge.js
  var RelatedObjectEdge$inboundSchema = objectType({
    objects: arrayType(RelatedObject$inboundSchema).optional()
  });
  var RelatedObjectEdge$outboundSchema = objectType({
    objects: arrayType(RelatedObject$outboundSchema).optional()
  });
  var RelatedObjectEdge$;
  (function(RelatedObjectEdge$2) {
    RelatedObjectEdge$2.inboundSchema = RelatedObjectEdge$inboundSchema;
    RelatedObjectEdge$2.outboundSchema = RelatedObjectEdge$outboundSchema;
  })(RelatedObjectEdge$ || (RelatedObjectEdge$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/teamemail.js
  var TeamEmail$inboundSchema = objectType({
    email: stringType(),
    type: stringType().default("OTHER")
  });
  var TeamEmail$outboundSchema = objectType({
    email: stringType(),
    type: stringType().default("OTHER")
  });
  var TeamEmail$;
  (function(TeamEmail$2) {
    TeamEmail$2.inboundSchema = TeamEmail$inboundSchema;
    TeamEmail$2.outboundSchema = TeamEmail$outboundSchema;
  })(TeamEmail$ || (TeamEmail$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/team.js
  var TeamStatus = {
    Processed: "PROCESSED",
    QueuedForCreation: "QUEUED_FOR_CREATION",
    QueuedForDeletion: "QUEUED_FOR_DELETION"
  };
  var TeamStatus$inboundSchema = nativeEnumType(TeamStatus);
  var TeamStatus$outboundSchema = TeamStatus$inboundSchema;
  var TeamStatus$;
  (function(TeamStatus$2) {
    TeamStatus$2.inboundSchema = TeamStatus$inboundSchema;
    TeamStatus$2.outboundSchema = TeamStatus$outboundSchema;
  })(TeamStatus$ || (TeamStatus$ = {}));
  var Team$inboundSchema = objectType({
    relatedObjects: recordType(RelatedObjectEdge$inboundSchema).optional(),
    permissions: ObjectPermissions$inboundSchema.optional(),
    id: stringType(),
    name: stringType(),
    description: stringType().optional(),
    businessUnit: stringType().optional(),
    department: stringType().optional(),
    photoUrl: stringType().optional(),
    bannerUrl: stringType().optional(),
    externalLink: stringType().optional(),
    members: arrayType(lazyType(() => PersonToTeamRelationship$inboundSchema)).optional(),
    memberCount: numberType().int().optional(),
    emails: arrayType(TeamEmail$inboundSchema).optional(),
    customFields: arrayType(lazyType(() => CustomFieldData$inboundSchema)).optional(),
    datasourceProfiles: arrayType(DatasourceProfile$inboundSchema).optional(),
    datasource: stringType().optional(),
    createdFrom: stringType().optional(),
    lastUpdatedAt: stringType().datetime({ offset: true }).transform((v) => new Date(v)).optional(),
    status: TeamStatus$inboundSchema.default("PROCESSED"),
    canBeDeleted: booleanType().default(true),
    loggingId: stringType().optional()
  });
  var Team$outboundSchema = objectType({
    relatedObjects: recordType(RelatedObjectEdge$outboundSchema).optional(),
    permissions: ObjectPermissions$outboundSchema.optional(),
    id: stringType(),
    name: stringType(),
    description: stringType().optional(),
    businessUnit: stringType().optional(),
    department: stringType().optional(),
    photoUrl: stringType().optional(),
    bannerUrl: stringType().optional(),
    externalLink: stringType().optional(),
    members: arrayType(lazyType(() => PersonToTeamRelationship$outboundSchema)).optional(),
    memberCount: numberType().int().optional(),
    emails: arrayType(TeamEmail$outboundSchema).optional(),
    customFields: arrayType(lazyType(() => CustomFieldData$outboundSchema)).optional(),
    datasourceProfiles: arrayType(DatasourceProfile$outboundSchema).optional(),
    datasource: stringType().optional(),
    createdFrom: stringType().optional(),
    lastUpdatedAt: dateType().transform((v) => v.toISOString()).optional(),
    status: TeamStatus$outboundSchema.default("PROCESSED"),
    canBeDeleted: booleanType().default(true),
    loggingId: stringType().optional()
  });
  var Team$;
  (function(Team$2) {
    Team$2.inboundSchema = Team$inboundSchema;
    Team$2.outboundSchema = Team$outboundSchema;
  })(Team$ || (Team$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/structuredresult.js
  var Prominence = {
    Hero: "HERO",
    Promoted: "PROMOTED",
    Standard: "STANDARD"
  };
  var StructuredResultSource = {
    ExpertDetection: "EXPERT_DETECTION",
    EntityNlq: "ENTITY_NLQ"
  };
  var Prominence$inboundSchema = nativeEnumType(Prominence);
  var Prominence$outboundSchema = Prominence$inboundSchema;
  var Prominence$;
  (function(Prominence$2) {
    Prominence$2.inboundSchema = Prominence$inboundSchema;
    Prominence$2.outboundSchema = Prominence$outboundSchema;
  })(Prominence$ || (Prominence$ = {}));
  var StructuredResultSource$inboundSchema = nativeEnumType(StructuredResultSource);
  var StructuredResultSource$outboundSchema = StructuredResultSource$inboundSchema;
  var StructuredResultSource$;
  (function(StructuredResultSource$2) {
    StructuredResultSource$2.inboundSchema = StructuredResultSource$inboundSchema;
    StructuredResultSource$2.outboundSchema = StructuredResultSource$outboundSchema;
  })(StructuredResultSource$ || (StructuredResultSource$ = {}));
  var StructuredResult$inboundSchema = objectType({
    document: lazyType(() => Document$inboundSchema).optional(),
    person: lazyType(() => Person$inboundSchema).optional(),
    customer: lazyType(() => Customer$inboundSchema).optional(),
    team: lazyType(() => Team$inboundSchema).optional(),
    customEntity: lazyType(() => CustomEntity$inboundSchema).optional(),
    answer: lazyType(() => Answer$inboundSchema).optional(),
    generatedQna: lazyType(() => GeneratedQna$inboundSchema).optional(),
    extractedQnA: lazyType(() => ExtractedQnA$inboundSchema).optional(),
    meeting: lazyType(() => Meeting$inboundSchema).optional(),
    app: AppResult$inboundSchema.optional(),
    collection: lazyType(() => Collection$inboundSchema).optional(),
    answerBoard: lazyType(() => AnswerBoard$inboundSchema).optional(),
    code: lazyType(() => Code$inboundSchema).optional(),
    shortcut: lazyType(() => Shortcut$inboundSchema).optional(),
    querySuggestions: lazyType(() => QuerySuggestionList$inboundSchema).optional(),
    relatedDocuments: arrayType(lazyType(() => RelatedDocuments$inboundSchema)).optional(),
    relatedQuestion: lazyType(() => RelatedQuestion$inboundSchema).optional(),
    disambiguation: Disambiguation$inboundSchema.optional(),
    snippets: arrayType(lazyType(() => SearchResultSnippet$inboundSchema)).optional(),
    trackingToken: stringType().optional(),
    prominence: Prominence$inboundSchema.optional(),
    source: StructuredResultSource$inboundSchema.optional()
  });
  var StructuredResult$outboundSchema = objectType({
    document: lazyType(() => Document$outboundSchema).optional(),
    person: lazyType(() => Person$outboundSchema).optional(),
    customer: lazyType(() => Customer$outboundSchema).optional(),
    team: lazyType(() => Team$outboundSchema).optional(),
    customEntity: lazyType(() => CustomEntity$outboundSchema).optional(),
    answer: lazyType(() => Answer$outboundSchema).optional(),
    generatedQna: lazyType(() => GeneratedQna$outboundSchema).optional(),
    extractedQnA: lazyType(() => ExtractedQnA$outboundSchema).optional(),
    meeting: lazyType(() => Meeting$outboundSchema).optional(),
    app: AppResult$outboundSchema.optional(),
    collection: lazyType(() => Collection$outboundSchema).optional(),
    answerBoard: lazyType(() => AnswerBoard$outboundSchema).optional(),
    code: lazyType(() => Code$outboundSchema).optional(),
    shortcut: lazyType(() => Shortcut$outboundSchema).optional(),
    querySuggestions: lazyType(() => QuerySuggestionList$outboundSchema).optional(),
    relatedDocuments: arrayType(lazyType(() => RelatedDocuments$outboundSchema)).optional(),
    relatedQuestion: lazyType(() => RelatedQuestion$outboundSchema).optional(),
    disambiguation: Disambiguation$outboundSchema.optional(),
    snippets: arrayType(lazyType(() => SearchResultSnippet$outboundSchema)).optional(),
    trackingToken: stringType().optional(),
    prominence: Prominence$outboundSchema.optional(),
    source: StructuredResultSource$outboundSchema.optional()
  });
  var StructuredResult$;
  (function(StructuredResult$2) {
    StructuredResult$2.inboundSchema = StructuredResult$inboundSchema;
    StructuredResult$2.outboundSchema = StructuredResult$outboundSchema;
  })(StructuredResult$ || (StructuredResult$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/searchresult.js
  var SearchResult$inboundSchema = objectType({
    structuredResults: arrayType(lazyType(() => StructuredResult$inboundSchema)).optional(),
    trackingToken: stringType().optional(),
    document: lazyType(() => Document$inboundSchema).optional(),
    title: stringType().optional(),
    url: stringType(),
    nativeAppUrl: stringType().optional(),
    snippets: arrayType(lazyType(() => SearchResultSnippet$inboundSchema)).optional(),
    fullText: stringType().optional(),
    fullTextList: arrayType(stringType()).optional(),
    relatedResults: arrayType(lazyType(() => RelatedDocuments$inboundSchema)).optional(),
    clusteredResults: arrayType(lazyType(() => SearchResult$inboundSchema)).optional(),
    allClusteredResults: arrayType(lazyType(() => ClusterGroup$inboundSchema)).optional(),
    attachmentCount: numberType().int().optional(),
    attachments: arrayType(lazyType(() => SearchResult$inboundSchema)).optional(),
    backlinkResults: arrayType(lazyType(() => SearchResult$inboundSchema)).optional(),
    clusterType: ClusterTypeEnum$inboundSchema.optional(),
    mustIncludeSuggestions: lazyType(() => QuerySuggestionList$inboundSchema).optional(),
    querySuggestion: lazyType(() => QuerySuggestion$inboundSchema).optional(),
    prominence: SearchResultProminenceEnum$inboundSchema.optional(),
    attachmentContext: stringType().optional(),
    pins: arrayType(lazyType(() => PinDocument$inboundSchema)).optional()
  });
  var SearchResult$outboundSchema = objectType({
    structuredResults: arrayType(lazyType(() => StructuredResult$outboundSchema)).optional(),
    trackingToken: stringType().optional(),
    document: lazyType(() => Document$outboundSchema).optional(),
    title: stringType().optional(),
    url: stringType(),
    nativeAppUrl: stringType().optional(),
    snippets: arrayType(lazyType(() => SearchResultSnippet$outboundSchema)).optional(),
    fullText: stringType().optional(),
    fullTextList: arrayType(stringType()).optional(),
    relatedResults: arrayType(lazyType(() => RelatedDocuments$outboundSchema)).optional(),
    clusteredResults: arrayType(lazyType(() => SearchResult$outboundSchema)).optional(),
    allClusteredResults: arrayType(lazyType(() => ClusterGroup$outboundSchema)).optional(),
    attachmentCount: numberType().int().optional(),
    attachments: arrayType(lazyType(() => SearchResult$outboundSchema)).optional(),
    backlinkResults: arrayType(lazyType(() => SearchResult$outboundSchema)).optional(),
    clusterType: ClusterTypeEnum$outboundSchema.optional(),
    mustIncludeSuggestions: lazyType(() => QuerySuggestionList$outboundSchema).optional(),
    querySuggestion: lazyType(() => QuerySuggestion$outboundSchema).optional(),
    prominence: SearchResultProminenceEnum$outboundSchema.optional(),
    attachmentContext: stringType().optional(),
    pins: arrayType(lazyType(() => PinDocument$outboundSchema)).optional()
  });
  var SearchResult$;
  (function(SearchResult$2) {
    SearchResult$2.inboundSchema = SearchResult$inboundSchema;
    SearchResult$2.outboundSchema = SearchResult$outboundSchema;
  })(SearchResult$ || (SearchResult$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/relateddocuments.js
  var Relation = {
    Attachment: "ATTACHMENT",
    Canonical: "CANONICAL",
    Case: "CASE",
    ContactLower: "contact",
    ContactUpper: "CONTACT",
    ConversationMessages: "CONVERSATION_MESSAGES",
    Expert: "EXPERT",
    From: "FROM",
    Highlight: "HIGHLIGHT",
    OpportunityLower: "opportunity",
    OpportunityUpper: "OPPORTUNITY",
    Recent: "RECENT",
    Source: "SOURCE",
    Ticket: "TICKET",
    Transcript: "TRANSCRIPT",
    With: "WITH"
  };
  var Relation$inboundSchema = nativeEnumType(Relation);
  var Relation$outboundSchema = Relation$inboundSchema;
  var Relation$;
  (function(Relation$2) {
    Relation$2.inboundSchema = Relation$inboundSchema;
    Relation$2.outboundSchema = Relation$outboundSchema;
  })(Relation$ || (Relation$ = {}));
  var RelatedDocuments$inboundSchema = objectType({
    relation: Relation$inboundSchema.optional(),
    associatedEntityId: stringType().optional(),
    querySuggestion: lazyType(() => QuerySuggestion$inboundSchema).optional(),
    documents: arrayType(lazyType(() => Document$inboundSchema)).optional(),
    results: arrayType(lazyType(() => SearchResult$inboundSchema)).optional()
  });
  var RelatedDocuments$outboundSchema = objectType({
    relation: Relation$outboundSchema.optional(),
    associatedEntityId: stringType().optional(),
    querySuggestion: lazyType(() => QuerySuggestion$outboundSchema).optional(),
    documents: arrayType(lazyType(() => Document$outboundSchema)).optional(),
    results: arrayType(lazyType(() => SearchResult$outboundSchema)).optional()
  });
  var RelatedDocuments$;
  (function(RelatedDocuments$2) {
    RelatedDocuments$2.inboundSchema = RelatedDocuments$inboundSchema;
    RelatedDocuments$2.outboundSchema = RelatedDocuments$outboundSchema;
  })(RelatedDocuments$ || (RelatedDocuments$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/person.js
  var Person$inboundSchema = objectType({
    name: stringType(),
    obfuscatedId: stringType(),
    relatedDocuments: arrayType(lazyType(() => RelatedDocuments$inboundSchema)).optional(),
    metadata: lazyType(() => PersonMetadata$inboundSchema).optional()
  });
  var Person$outboundSchema = objectType({
    name: stringType(),
    obfuscatedId: stringType(),
    relatedDocuments: arrayType(lazyType(() => RelatedDocuments$outboundSchema)).optional(),
    metadata: lazyType(() => PersonMetadata$outboundSchema).optional()
  });
  var Person$;
  (function(Person$2) {
    Person$2.inboundSchema = Person$inboundSchema;
    Person$2.outboundSchema = Person$outboundSchema;
  })(Person$ || (Person$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/reaction.js
  var Reaction$inboundSchema = objectType({
    type: stringType().optional(),
    count: numberType().int().optional(),
    reactors: arrayType(lazyType(() => Person$inboundSchema)).optional(),
    reactedByViewer: booleanType().optional()
  });
  var Reaction$outboundSchema = objectType({
    type: stringType().optional(),
    count: numberType().int().optional(),
    reactors: arrayType(lazyType(() => Person$outboundSchema)).optional(),
    reactedByViewer: booleanType().optional()
  });
  var Reaction$;
  (function(Reaction$2) {
    Reaction$2.inboundSchema = Reaction$inboundSchema;
    Reaction$2.outboundSchema = Reaction$outboundSchema;
  })(Reaction$ || (Reaction$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/share.js
  var Share$inboundSchema = objectType({
    numDaysAgo: numberType().int(),
    sharer: lazyType(() => Person$inboundSchema).optional(),
    sharingDocument: lazyType(() => Document$inboundSchema).optional()
  });
  var Share$outboundSchema = objectType({
    numDaysAgo: numberType().int(),
    sharer: lazyType(() => Person$outboundSchema).optional(),
    sharingDocument: lazyType(() => Document$outboundSchema).optional()
  });
  var Share$;
  (function(Share$2) {
    Share$2.inboundSchema = Share$inboundSchema;
    Share$2.outboundSchema = Share$outboundSchema;
  })(Share$ || (Share$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/documentinteractions.js
  var DocumentInteractions$inboundSchema = objectType({
    numComments: numberType().int().optional(),
    numReactions: numberType().int().optional(),
    reactions: arrayType(stringType()).optional(),
    reacts: arrayType(lazyType(() => Reaction$inboundSchema)).optional(),
    shares: arrayType(lazyType(() => Share$inboundSchema)).optional(),
    visitorCount: CountInfo$inboundSchema.optional()
  });
  var DocumentInteractions$outboundSchema = objectType({
    numComments: numberType().int().optional(),
    numReactions: numberType().int().optional(),
    reactions: arrayType(stringType()).optional(),
    reacts: arrayType(lazyType(() => Reaction$outboundSchema)).optional(),
    shares: arrayType(lazyType(() => Share$outboundSchema)).optional(),
    visitorCount: CountInfo$outboundSchema.optional()
  });
  var DocumentInteractions$;
  (function(DocumentInteractions$2) {
    DocumentInteractions$2.inboundSchema = DocumentInteractions$inboundSchema;
    DocumentInteractions$2.outboundSchema = DocumentInteractions$outboundSchema;
  })(DocumentInteractions$ || (DocumentInteractions$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/documentvisibility.js
  var DocumentVisibility = {
    Private: "PRIVATE",
    SpecificPeopleAndGroups: "SPECIFIC_PEOPLE_AND_GROUPS",
    DomainLink: "DOMAIN_LINK",
    DomainVisible: "DOMAIN_VISIBLE",
    PublicLink: "PUBLIC_LINK",
    PublicVisible: "PUBLIC_VISIBLE"
  };
  var DocumentVisibility$inboundSchema = nativeEnumType(DocumentVisibility);
  var DocumentVisibility$outboundSchema = DocumentVisibility$inboundSchema;
  var DocumentVisibility$;
  (function(DocumentVisibility$2) {
    DocumentVisibility$2.inboundSchema = DocumentVisibility$inboundSchema;
    DocumentVisibility$2.outboundSchema = DocumentVisibility$outboundSchema;
  })(DocumentVisibility$ || (DocumentVisibility$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/indexstatus.js
  var IndexStatus$inboundSchema = objectType({
    lastCrawledTime: stringType().datetime({ offset: true }).transform((v) => new Date(v)).optional(),
    lastIndexedTime: stringType().datetime({ offset: true }).transform((v) => new Date(v)).optional()
  });
  var IndexStatus$outboundSchema = objectType({
    lastCrawledTime: dateType().transform((v) => v.toISOString()).optional(),
    lastIndexedTime: dateType().transform((v) => v.toISOString()).optional()
  });
  var IndexStatus$;
  (function(IndexStatus$2) {
    IndexStatus$2.inboundSchema = IndexStatus$inboundSchema;
    IndexStatus$2.outboundSchema = IndexStatus$outboundSchema;
  })(IndexStatus$ || (IndexStatus$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/thumbnail.js
  var Thumbnail$inboundSchema = objectType({
    photoId: stringType().optional(),
    url: stringType().optional()
  });
  var Thumbnail$outboundSchema = objectType({
    photoId: stringType().optional(),
    url: stringType().optional()
  });
  var Thumbnail$;
  (function(Thumbnail$2) {
    Thumbnail$2.inboundSchema = Thumbnail$inboundSchema;
    Thumbnail$2.outboundSchema = Thumbnail$outboundSchema;
  })(Thumbnail$ || (Thumbnail$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/viewerinfo.js
  var Role = {
    AnswerModerator: "ANSWER_MODERATOR",
    Owner: "OWNER",
    Viewer: "VIEWER"
  };
  var Role$inboundSchema = nativeEnumType(Role);
  var Role$outboundSchema = Role$inboundSchema;
  var Role$;
  (function(Role$2) {
    Role$2.inboundSchema = Role$inboundSchema;
    Role$2.outboundSchema = Role$outboundSchema;
  })(Role$ || (Role$ = {}));
  var ViewerInfo$inboundSchema = objectType({
    role: Role$inboundSchema.optional(),
    lastViewedTime: stringType().datetime({ offset: true }).transform((v) => new Date(v)).optional()
  });
  var ViewerInfo$outboundSchema = objectType({
    role: Role$outboundSchema.optional(),
    lastViewedTime: dateType().transform((v) => v.toISOString()).optional()
  });
  var ViewerInfo$;
  (function(ViewerInfo$2) {
    ViewerInfo$2.inboundSchema = ViewerInfo$inboundSchema;
    ViewerInfo$2.outboundSchema = ViewerInfo$outboundSchema;
  })(ViewerInfo$ || (ViewerInfo$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/documentmetadata.js
  var DocumentMetadata$inboundSchema = objectType({
    datasource: stringType().optional(),
    datasourceInstance: stringType().optional(),
    objectType: stringType().optional(),
    container: stringType().optional(),
    containerId: stringType().optional(),
    superContainerId: stringType().optional(),
    parentId: stringType().optional(),
    mimeType: stringType().optional(),
    documentId: stringType().optional(),
    loggingId: stringType().optional(),
    documentIdHash: stringType().optional(),
    createTime: stringType().datetime({ offset: true }).transform((v) => new Date(v)).optional(),
    updateTime: stringType().datetime({ offset: true }).transform((v) => new Date(v)).optional(),
    author: lazyType(() => Person$inboundSchema).optional(),
    owner: lazyType(() => Person$inboundSchema).optional(),
    mentionedPeople: arrayType(lazyType(() => Person$inboundSchema)).optional(),
    visibility: DocumentVisibility$inboundSchema.optional(),
    components: arrayType(stringType()).optional(),
    status: stringType().optional(),
    statusCategory: stringType().optional(),
    pins: arrayType(lazyType(() => PinDocument$inboundSchema)).optional(),
    priority: stringType().optional(),
    assignedTo: lazyType(() => Person$inboundSchema).optional(),
    updatedBy: lazyType(() => Person$inboundSchema).optional(),
    labels: arrayType(stringType()).optional(),
    collections: arrayType(lazyType(() => Collection$inboundSchema)).optional(),
    datasourceId: stringType().optional(),
    interactions: lazyType(() => DocumentInteractions$inboundSchema).optional(),
    verification: lazyType(() => Verification$inboundSchema).optional(),
    viewerInfo: ViewerInfo$inboundSchema.optional(),
    permissions: ObjectPermissions$inboundSchema.optional(),
    visitCount: CountInfo$inboundSchema.optional(),
    shortcuts: arrayType(lazyType(() => Shortcut$inboundSchema)).optional(),
    path: stringType().optional(),
    customData: recordType(CustomDataValue$inboundSchema).optional(),
    documentCategory: stringType().optional(),
    contactPerson: lazyType(() => Person$inboundSchema).optional(),
    thumbnail: Thumbnail$inboundSchema.optional(),
    indexStatus: IndexStatus$inboundSchema.optional(),
    ancestors: arrayType(lazyType(() => Document$inboundSchema)).optional()
  });
  var DocumentMetadata$outboundSchema = objectType({
    datasource: stringType().optional(),
    datasourceInstance: stringType().optional(),
    objectType: stringType().optional(),
    container: stringType().optional(),
    containerId: stringType().optional(),
    superContainerId: stringType().optional(),
    parentId: stringType().optional(),
    mimeType: stringType().optional(),
    documentId: stringType().optional(),
    loggingId: stringType().optional(),
    documentIdHash: stringType().optional(),
    createTime: dateType().transform((v) => v.toISOString()).optional(),
    updateTime: dateType().transform((v) => v.toISOString()).optional(),
    author: lazyType(() => Person$outboundSchema).optional(),
    owner: lazyType(() => Person$outboundSchema).optional(),
    mentionedPeople: arrayType(lazyType(() => Person$outboundSchema)).optional(),
    visibility: DocumentVisibility$outboundSchema.optional(),
    components: arrayType(stringType()).optional(),
    status: stringType().optional(),
    statusCategory: stringType().optional(),
    pins: arrayType(lazyType(() => PinDocument$outboundSchema)).optional(),
    priority: stringType().optional(),
    assignedTo: lazyType(() => Person$outboundSchema).optional(),
    updatedBy: lazyType(() => Person$outboundSchema).optional(),
    labels: arrayType(stringType()).optional(),
    collections: arrayType(lazyType(() => Collection$outboundSchema)).optional(),
    datasourceId: stringType().optional(),
    interactions: lazyType(() => DocumentInteractions$outboundSchema).optional(),
    verification: lazyType(() => Verification$outboundSchema).optional(),
    viewerInfo: ViewerInfo$outboundSchema.optional(),
    permissions: ObjectPermissions$outboundSchema.optional(),
    visitCount: CountInfo$outboundSchema.optional(),
    shortcuts: arrayType(lazyType(() => Shortcut$outboundSchema)).optional(),
    path: stringType().optional(),
    customData: recordType(CustomDataValue$outboundSchema).optional(),
    documentCategory: stringType().optional(),
    contactPerson: lazyType(() => Person$outboundSchema).optional(),
    thumbnail: Thumbnail$outboundSchema.optional(),
    indexStatus: IndexStatus$outboundSchema.optional(),
    ancestors: arrayType(lazyType(() => Document$outboundSchema)).optional()
  });
  var DocumentMetadata$;
  (function(DocumentMetadata$2) {
    DocumentMetadata$2.inboundSchema = DocumentMetadata$inboundSchema;
    DocumentMetadata$2.outboundSchema = DocumentMetadata$outboundSchema;
  })(DocumentMetadata$ || (DocumentMetadata$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/documentsection.js
  var DocumentSection$inboundSchema = objectType({
    title: stringType().optional(),
    url: stringType().optional()
  });
  var DocumentSection$outboundSchema = objectType({
    title: stringType().optional(),
    url: stringType().optional()
  });
  var DocumentSection$;
  (function(DocumentSection$2) {
    DocumentSection$2.inboundSchema = DocumentSection$inboundSchema;
    DocumentSection$2.outboundSchema = DocumentSection$outboundSchema;
  })(DocumentSection$ || (DocumentSection$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/document.js
  var Document$inboundSchema = objectType({
    id: stringType().optional(),
    datasource: stringType().optional(),
    connectorType: ConnectorType$inboundSchema.optional(),
    docType: stringType().optional(),
    content: DocumentContent$inboundSchema.optional(),
    containerDocument: lazyType(() => Document$inboundSchema).optional(),
    parentDocument: lazyType(() => Document$inboundSchema).optional(),
    title: stringType().optional(),
    url: stringType().optional(),
    metadata: lazyType(() => DocumentMetadata$inboundSchema).optional(),
    sections: arrayType(DocumentSection$inboundSchema).optional()
  });
  var Document$outboundSchema = objectType({
    id: stringType().optional(),
    datasource: stringType().optional(),
    connectorType: ConnectorType$outboundSchema.optional(),
    docType: stringType().optional(),
    content: DocumentContent$outboundSchema.optional(),
    containerDocument: lazyType(() => Document$outboundSchema).optional(),
    parentDocument: lazyType(() => Document$outboundSchema).optional(),
    title: stringType().optional(),
    url: stringType().optional(),
    metadata: lazyType(() => DocumentMetadata$outboundSchema).optional(),
    sections: arrayType(DocumentSection$outboundSchema).optional()
  });
  var Document$;
  (function(Document$2) {
    Document$2.inboundSchema = Document$inboundSchema;
    Document$2.outboundSchema = Document$outboundSchema;
  })(Document$ || (Document$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/collectionitem.js
  var CollectionItemItemType = {
    Document: "DOCUMENT",
    Text: "TEXT",
    Url: "URL",
    Collection: "COLLECTION"
  };
  var CollectionItemItemType$inboundSchema = nativeEnumType(CollectionItemItemType);
  var CollectionItemItemType$outboundSchema = CollectionItemItemType$inboundSchema;
  var CollectionItemItemType$;
  (function(CollectionItemItemType$2) {
    CollectionItemItemType$2.inboundSchema = CollectionItemItemType$inboundSchema;
    CollectionItemItemType$2.outboundSchema = CollectionItemItemType$outboundSchema;
  })(CollectionItemItemType$ || (CollectionItemItemType$ = {}));
  var CollectionItem$inboundSchema = objectType({
    name: stringType().optional(),
    description: stringType().optional(),
    icon: stringType().optional(),
    collectionId: numberType().int(),
    documentId: stringType().optional(),
    url: stringType().optional(),
    itemId: stringType().optional(),
    createdBy: lazyType(() => Person$inboundSchema).optional(),
    createdAt: stringType().datetime({ offset: true }).transform((v) => new Date(v)).optional(),
    document: lazyType(() => Document$inboundSchema).optional(),
    shortcut: lazyType(() => Shortcut$inboundSchema).optional(),
    collection: lazyType(() => Collection$inboundSchema).optional(),
    itemType: CollectionItemItemType$inboundSchema
  });
  var CollectionItem$outboundSchema = objectType({
    name: stringType().optional(),
    description: stringType().optional(),
    icon: stringType().optional(),
    collectionId: numberType().int(),
    documentId: stringType().optional(),
    url: stringType().optional(),
    itemId: stringType().optional(),
    createdBy: lazyType(() => Person$outboundSchema).optional(),
    createdAt: dateType().transform((v) => v.toISOString()).optional(),
    document: lazyType(() => Document$outboundSchema).optional(),
    shortcut: lazyType(() => Shortcut$outboundSchema).optional(),
    collection: lazyType(() => Collection$outboundSchema).optional(),
    itemType: CollectionItemItemType$outboundSchema
  });
  var CollectionItem$;
  (function(CollectionItem$2) {
    CollectionItem$2.inboundSchema = CollectionItem$inboundSchema;
    CollectionItem$2.outboundSchema = CollectionItem$outboundSchema;
  })(CollectionItem$ || (CollectionItem$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/collectionpinnablecategories.js
  var CollectionPinnableCategories = {
    CompanyResource: "COMPANY_RESOURCE",
    DepartmentResource: "DEPARTMENT_RESOURCE",
    TeamResource: "TEAM_RESOURCE"
  };
  var CollectionPinnableCategories$inboundSchema = nativeEnumType(CollectionPinnableCategories);
  var CollectionPinnableCategories$outboundSchema = CollectionPinnableCategories$inboundSchema;
  var CollectionPinnableCategories$;
  (function(CollectionPinnableCategories$2) {
    CollectionPinnableCategories$2.inboundSchema = CollectionPinnableCategories$inboundSchema;
    CollectionPinnableCategories$2.outboundSchema = CollectionPinnableCategories$outboundSchema;
  })(CollectionPinnableCategories$ || (CollectionPinnableCategories$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/collectionpinnabletargets.js
  var CollectionPinnableTargets = {
    ResourceCard: "RESOURCE_CARD",
    TeamProfilePage: "TEAM_PROFILE_PAGE"
  };
  var CollectionPinnableTargets$inboundSchema = nativeEnumType(CollectionPinnableTargets);
  var CollectionPinnableTargets$outboundSchema = CollectionPinnableTargets$inboundSchema;
  var CollectionPinnableTargets$;
  (function(CollectionPinnableTargets$2) {
    CollectionPinnableTargets$2.inboundSchema = CollectionPinnableTargets$inboundSchema;
    CollectionPinnableTargets$2.outboundSchema = CollectionPinnableTargets$outboundSchema;
  })(CollectionPinnableTargets$ || (CollectionPinnableTargets$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/collectionpintarget.js
  var CollectionPinTarget$inboundSchema = objectType({
    category: CollectionPinnableCategories$inboundSchema,
    value: stringType().optional(),
    target: CollectionPinnableTargets$inboundSchema.optional()
  });
  var CollectionPinTarget$outboundSchema = objectType({
    category: CollectionPinnableCategories$outboundSchema,
    value: stringType().optional(),
    target: CollectionPinnableTargets$outboundSchema.optional()
  });
  var CollectionPinTarget$;
  (function(CollectionPinTarget$2) {
    CollectionPinTarget$2.inboundSchema = CollectionPinTarget$inboundSchema;
    CollectionPinTarget$2.outboundSchema = CollectionPinTarget$outboundSchema;
  })(CollectionPinTarget$ || (CollectionPinTarget$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/collectionpinmetadata.js
  var CollectionPinMetadata$inboundSchema = objectType({
    id: numberType().int(),
    target: CollectionPinTarget$inboundSchema
  });
  var CollectionPinMetadata$outboundSchema = objectType({
    id: numberType().int(),
    target: CollectionPinTarget$outboundSchema
  });
  var CollectionPinMetadata$;
  (function(CollectionPinMetadata$2) {
    CollectionPinMetadata$2.inboundSchema = CollectionPinMetadata$inboundSchema;
    CollectionPinMetadata$2.outboundSchema = CollectionPinMetadata$outboundSchema;
  })(CollectionPinMetadata$ || (CollectionPinMetadata$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/collectionpinnedmetadata.js
  var CollectionPinnedMetadata$inboundSchema = objectType({
    existingPins: arrayType(CollectionPinTarget$inboundSchema).optional(),
    eligiblePins: arrayType(CollectionPinMetadata$inboundSchema).optional()
  });
  var CollectionPinnedMetadata$outboundSchema = objectType({
    existingPins: arrayType(CollectionPinTarget$outboundSchema).optional(),
    eligiblePins: arrayType(CollectionPinMetadata$outboundSchema).optional()
  });
  var CollectionPinnedMetadata$;
  (function(CollectionPinnedMetadata$2) {
    CollectionPinnedMetadata$2.inboundSchema = CollectionPinnedMetadata$inboundSchema;
    CollectionPinnedMetadata$2.outboundSchema = CollectionPinnedMetadata$outboundSchema;
  })(CollectionPinnedMetadata$ || (CollectionPinnedMetadata$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/collection.js
  var Collection$inboundSchema = objectType({
    name: stringType(),
    description: stringType(),
    addedRoles: arrayType(lazyType(() => UserRoleSpecification$inboundSchema)).optional(),
    removedRoles: arrayType(lazyType(() => UserRoleSpecification$inboundSchema)).optional(),
    audienceFilters: arrayType(FacetFilter$inboundSchema).optional(),
    icon: stringType().optional(),
    adminLocked: booleanType().optional(),
    parentId: numberType().int().optional(),
    thumbnail: Thumbnail$inboundSchema.optional(),
    allowedDatasource: stringType().optional(),
    permissions: ObjectPermissions$inboundSchema.optional(),
    id: numberType().int(),
    createTime: stringType().datetime({ offset: true }).transform((v) => new Date(v)).optional(),
    updateTime: stringType().datetime({ offset: true }).transform((v) => new Date(v)).optional(),
    creator: lazyType(() => Person$inboundSchema).optional(),
    updatedBy: lazyType(() => Person$inboundSchema).optional(),
    itemCount: numberType().int().optional(),
    childCount: numberType().int().optional(),
    items: arrayType(lazyType(() => CollectionItem$inboundSchema)).optional(),
    pinMetadata: CollectionPinnedMetadata$inboundSchema.optional(),
    shortcuts: arrayType(stringType()).optional(),
    children: arrayType(lazyType(() => Collection$inboundSchema)).optional(),
    roles: arrayType(lazyType(() => UserRoleSpecification$inboundSchema)).optional()
  });
  var Collection$outboundSchema = objectType({
    name: stringType(),
    description: stringType(),
    addedRoles: arrayType(lazyType(() => UserRoleSpecification$outboundSchema)).optional(),
    removedRoles: arrayType(lazyType(() => UserRoleSpecification$outboundSchema)).optional(),
    audienceFilters: arrayType(FacetFilter$outboundSchema).optional(),
    icon: stringType().optional(),
    adminLocked: booleanType().optional(),
    parentId: numberType().int().optional(),
    thumbnail: Thumbnail$outboundSchema.optional(),
    allowedDatasource: stringType().optional(),
    permissions: ObjectPermissions$outboundSchema.optional(),
    id: numberType().int(),
    createTime: dateType().transform((v) => v.toISOString()).optional(),
    updateTime: dateType().transform((v) => v.toISOString()).optional(),
    creator: lazyType(() => Person$outboundSchema).optional(),
    updatedBy: lazyType(() => Person$outboundSchema).optional(),
    itemCount: numberType().int().optional(),
    childCount: numberType().int().optional(),
    items: arrayType(lazyType(() => CollectionItem$outboundSchema)).optional(),
    pinMetadata: CollectionPinnedMetadata$outboundSchema.optional(),
    shortcuts: arrayType(stringType()).optional(),
    children: arrayType(lazyType(() => Collection$outboundSchema)).optional(),
    roles: arrayType(lazyType(() => UserRoleSpecification$outboundSchema)).optional()
  });
  var Collection$;
  (function(Collection$2) {
    Collection$2.inboundSchema = Collection$inboundSchema;
    Collection$2.outboundSchema = Collection$outboundSchema;
  })(Collection$ || (Collection$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/addcollectionitemsresponse.js
  var AddCollectionItemsResponse$inboundSchema = objectType({
    collection: Collection$inboundSchema.optional(),
    error: AddCollectionItemsError$inboundSchema.optional()
  });
  var AddCollectionItemsResponse$outboundSchema = objectType({
    collection: Collection$outboundSchema.optional(),
    error: AddCollectionItemsError$outboundSchema.optional()
  });
  var AddCollectionItemsResponse$;
  (function(AddCollectionItemsResponse$2) {
    AddCollectionItemsResponse$2.inboundSchema = AddCollectionItemsResponse$inboundSchema;
    AddCollectionItemsResponse$2.outboundSchema = AddCollectionItemsResponse$outboundSchema;
  })(AddCollectionItemsResponse$ || (AddCollectionItemsResponse$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/additionalfielddefinition.js
  var Value$inboundSchema = objectType({});
  var Value$outboundSchema = objectType({});
  var Value$;
  (function(Value$2) {
    Value$2.inboundSchema = Value$inboundSchema;
    Value$2.outboundSchema = Value$outboundSchema;
  })(Value$ || (Value$ = {}));
  var AdditionalFieldDefinition$inboundSchema = objectType({
    key: stringType().optional(),
    value: arrayType(lazyType(() => Value$inboundSchema)).optional()
  });
  var AdditionalFieldDefinition$outboundSchema = objectType({
    key: stringType().optional(),
    value: arrayType(lazyType(() => Value$outboundSchema)).optional()
  });
  var AdditionalFieldDefinition$;
  (function(AdditionalFieldDefinition$2) {
    AdditionalFieldDefinition$2.inboundSchema = AdditionalFieldDefinition$inboundSchema;
    AdditionalFieldDefinition$2.outboundSchema = AdditionalFieldDefinition$outboundSchema;
  })(AdditionalFieldDefinition$ || (AdditionalFieldDefinition$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/agent.js
  var AgentMetadata$inboundSchema = objectType({});
  var AgentMetadata$outboundSchema = objectType({});
  var AgentMetadata$;
  (function(AgentMetadata$2) {
    AgentMetadata$2.inboundSchema = AgentMetadata$inboundSchema;
    AgentMetadata$2.outboundSchema = AgentMetadata$outboundSchema;
  })(AgentMetadata$ || (AgentMetadata$ = {}));
  var AgentCapabilities$inboundSchema = collectExtraKeys(objectType({
    "ap.io.messages": booleanType().optional(),
    "ap.io.streaming": booleanType().optional()
  }).catchall(anyType()), "additionalProperties", true).transform((v) => {
    return remap(v, {
      "ap.io.messages": "apIoMessages",
      "ap.io.streaming": "apIoStreaming"
    });
  });
  var AgentCapabilities$outboundSchema = objectType({
    apIoMessages: booleanType().optional(),
    apIoStreaming: booleanType().optional(),
    additionalProperties: recordType(anyType())
  }).transform((v) => {
    return {
      ...v.additionalProperties,
      ...remap(v, {
        apIoMessages: "ap.io.messages",
        apIoStreaming: "ap.io.streaming",
        additionalProperties: null
      })
    };
  });
  var AgentCapabilities$;
  (function(AgentCapabilities$2) {
    AgentCapabilities$2.inboundSchema = AgentCapabilities$inboundSchema;
    AgentCapabilities$2.outboundSchema = AgentCapabilities$outboundSchema;
  })(AgentCapabilities$ || (AgentCapabilities$ = {}));
  var Agent$inboundSchema = objectType({
    agent_id: stringType(),
    name: stringType(),
    description: stringType().optional(),
    metadata: lazyType(() => AgentMetadata$inboundSchema).optional(),
    capabilities: lazyType(() => AgentCapabilities$inboundSchema)
  }).transform((v) => {
    return remap(v, {
      "agent_id": "agentId"
    });
  });
  var Agent$outboundSchema = objectType({
    agentId: stringType(),
    name: stringType(),
    description: stringType().optional(),
    metadata: lazyType(() => AgentMetadata$outboundSchema).optional(),
    capabilities: lazyType(() => AgentCapabilities$outboundSchema)
  }).transform((v) => {
    return remap(v, {
      agentId: "agent_id"
    });
  });
  var Agent$;
  (function(Agent$2) {
    Agent$2.inboundSchema = Agent$inboundSchema;
    Agent$2.outboundSchema = Agent$outboundSchema;
  })(Agent$ || (Agent$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/toolsets.js
  var ToolSets$inboundSchema = objectType({
    enableWebSearch: booleanType().optional(),
    enableCompanyTools: booleanType().optional()
  });
  var ToolSets$outboundSchema = objectType({
    enableWebSearch: booleanType().optional(),
    enableCompanyTools: booleanType().optional()
  });
  var ToolSets$;
  (function(ToolSets$2) {
    ToolSets$2.inboundSchema = ToolSets$inboundSchema;
    ToolSets$2.outboundSchema = ToolSets$outboundSchema;
  })(ToolSets$ || (ToolSets$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/agentconfig.js
  var AgentEnum = {
    Default: "DEFAULT",
    Gpt: "GPT",
    Universal: "UNIVERSAL",
    Fast: "FAST",
    Advanced: "ADVANCED"
  };
  var Mode = {
    Default: "DEFAULT",
    Quick: "QUICK"
  };
  var AgentEnum$inboundSchema = nativeEnumType(AgentEnum);
  var AgentEnum$outboundSchema = AgentEnum$inboundSchema;
  var AgentEnum$;
  (function(AgentEnum$2) {
    AgentEnum$2.inboundSchema = AgentEnum$inboundSchema;
    AgentEnum$2.outboundSchema = AgentEnum$outboundSchema;
  })(AgentEnum$ || (AgentEnum$ = {}));
  var Mode$inboundSchema = nativeEnumType(Mode);
  var Mode$outboundSchema = Mode$inboundSchema;
  var Mode$;
  (function(Mode$2) {
    Mode$2.inboundSchema = Mode$inboundSchema;
    Mode$2.outboundSchema = Mode$outboundSchema;
  })(Mode$ || (Mode$ = {}));
  var AgentConfig$inboundSchema = objectType({
    agent: AgentEnum$inboundSchema.optional(),
    toolSets: ToolSets$inboundSchema.optional(),
    mode: Mode$inboundSchema.optional()
  });
  var AgentConfig$outboundSchema = objectType({
    agent: AgentEnum$outboundSchema.optional(),
    toolSets: ToolSets$outboundSchema.optional(),
    mode: Mode$outboundSchema.optional()
  });
  var AgentConfig$;
  (function(AgentConfig$2) {
    AgentConfig$2.inboundSchema = AgentConfig$inboundSchema;
    AgentConfig$2.outboundSchema = AgentConfig$outboundSchema;
  })(AgentConfig$ || (AgentConfig$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/agentexecutionstatus.js
  var AgentExecutionStatus = {
    Error: "error",
    Success: "success"
  };
  var AgentExecutionStatus$inboundSchema = nativeEnumType(AgentExecutionStatus);
  var AgentExecutionStatus$outboundSchema = AgentExecutionStatus$inboundSchema;
  var AgentExecutionStatus$;
  (function(AgentExecutionStatus$2) {
    AgentExecutionStatus$2.inboundSchema = AgentExecutionStatus$inboundSchema;
    AgentExecutionStatus$2.outboundSchema = AgentExecutionStatus$outboundSchema;
  })(AgentExecutionStatus$ || (AgentExecutionStatus$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/contenttype.js
  var ContentType = {
    Text: "text"
  };
  var ContentType$inboundSchema = nativeEnumType(ContentType);
  var ContentType$outboundSchema = ContentType$inboundSchema;
  var ContentType$;
  (function(ContentType$2) {
    ContentType$2.inboundSchema = ContentType$inboundSchema;
    ContentType$2.outboundSchema = ContentType$outboundSchema;
  })(ContentType$ || (ContentType$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/message.js
  var MessageTextBlock$inboundSchema = objectType({
    text: stringType(),
    type: ContentType$inboundSchema
  });
  var MessageTextBlock$outboundSchema = objectType({
    text: stringType(),
    type: ContentType$outboundSchema
  });
  var MessageTextBlock$;
  (function(MessageTextBlock$2) {
    MessageTextBlock$2.inboundSchema = MessageTextBlock$inboundSchema;
    MessageTextBlock$2.outboundSchema = MessageTextBlock$outboundSchema;
  })(MessageTextBlock$ || (MessageTextBlock$ = {}));
  var Message$inboundSchema = objectType({
    role: stringType().optional(),
    content: arrayType(lazyType(() => MessageTextBlock$inboundSchema)).optional()
  });
  var Message$outboundSchema = objectType({
    role: stringType().optional(),
    content: arrayType(lazyType(() => MessageTextBlock$outboundSchema)).optional()
  });
  var Message$;
  (function(Message$2) {
    Message$2.inboundSchema = Message$inboundSchema;
    Message$2.outboundSchema = Message$outboundSchema;
  })(Message$ || (Message$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/agentrun.js
  var AgentRun$inboundSchema = objectType({
    agent_id: stringType(),
    input: recordType(anyType()).optional(),
    messages: arrayType(Message$inboundSchema).optional(),
    metadata: recordType(anyType()).optional(),
    status: AgentExecutionStatus$inboundSchema.optional()
  }).transform((v) => {
    return remap(v, {
      "agent_id": "agentId"
    });
  });
  var AgentRun$outboundSchema = objectType({
    agentId: stringType(),
    input: recordType(anyType()).optional(),
    messages: arrayType(Message$outboundSchema).optional(),
    metadata: recordType(anyType()).optional(),
    status: AgentExecutionStatus$outboundSchema.optional()
  }).transform((v) => {
    return remap(v, {
      agentId: "agent_id"
    });
  });
  var AgentRun$;
  (function(AgentRun$2) {
    AgentRun$2.inboundSchema = AgentRun$inboundSchema;
    AgentRun$2.outboundSchema = AgentRun$outboundSchema;
  })(AgentRun$ || (AgentRun$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/agentruncreate.js
  var AgentRunCreate$inboundSchema = objectType({
    agent_id: stringType(),
    input: recordType(anyType()).optional(),
    messages: arrayType(Message$inboundSchema).optional(),
    metadata: recordType(anyType()).optional()
  }).transform((v) => {
    return remap(v, {
      "agent_id": "agentId"
    });
  });
  var AgentRunCreate$outboundSchema = objectType({
    agentId: stringType(),
    input: recordType(anyType()).optional(),
    messages: arrayType(Message$outboundSchema).optional(),
    metadata: recordType(anyType()).optional()
  }).transform((v) => {
    return remap(v, {
      agentId: "agent_id"
    });
  });
  var AgentRunCreate$;
  (function(AgentRunCreate$2) {
    AgentRunCreate$2.inboundSchema = AgentRunCreate$inboundSchema;
    AgentRunCreate$2.outboundSchema = AgentRunCreate$outboundSchema;
  })(AgentRunCreate$ || (AgentRunCreate$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/agentrunwaitresponse.js
  var AgentRunWaitResponse$inboundSchema = objectType({
    run: AgentRun$inboundSchema.optional(),
    messages: arrayType(Message$inboundSchema).optional()
  });
  var AgentRunWaitResponse$outboundSchema = objectType({
    run: AgentRun$outboundSchema.optional(),
    messages: arrayType(Message$outboundSchema).optional()
  });
  var AgentRunWaitResponse$;
  (function(AgentRunWaitResponse$2) {
    AgentRunWaitResponse$2.inboundSchema = AgentRunWaitResponse$inboundSchema;
    AgentRunWaitResponse$2.outboundSchema = AgentRunWaitResponse$outboundSchema;
  })(AgentRunWaitResponse$ || (AgentRunWaitResponse$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/agentschemas.js
  var InputSchema$inboundSchema = objectType({});
  var InputSchema$outboundSchema = objectType({});
  var InputSchema$;
  (function(InputSchema$2) {
    InputSchema$2.inboundSchema = InputSchema$inboundSchema;
    InputSchema$2.outboundSchema = InputSchema$outboundSchema;
  })(InputSchema$ || (InputSchema$ = {}));
  var OutputSchema$inboundSchema = objectType({});
  var OutputSchema$outboundSchema = objectType({});
  var OutputSchema$;
  (function(OutputSchema$2) {
    OutputSchema$2.inboundSchema = OutputSchema$inboundSchema;
    OutputSchema$2.outboundSchema = OutputSchema$outboundSchema;
  })(OutputSchema$ || (OutputSchema$ = {}));
  var AgentSchemas$inboundSchema = objectType({
    agent_id: stringType(),
    input_schema: lazyType(() => InputSchema$inboundSchema),
    output_schema: lazyType(() => OutputSchema$inboundSchema)
  }).transform((v) => {
    return remap(v, {
      "agent_id": "agentId",
      "input_schema": "inputSchema",
      "output_schema": "outputSchema"
    });
  });
  var AgentSchemas$outboundSchema = objectType({
    agentId: stringType(),
    inputSchema: lazyType(() => InputSchema$outboundSchema),
    outputSchema: lazyType(() => OutputSchema$outboundSchema)
  }).transform((v) => {
    return remap(v, {
      agentId: "agent_id",
      inputSchema: "input_schema",
      outputSchema: "output_schema"
    });
  });
  var AgentSchemas$;
  (function(AgentSchemas$2) {
    AgentSchemas$2.inboundSchema = AgentSchemas$inboundSchema;
    AgentSchemas$2.outboundSchema = AgentSchemas$outboundSchema;
  })(AgentSchemas$ || (AgentSchemas$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/agentsinsightsv2request.js
  var AgentsInsightsV2Request$inboundSchema = objectType({
    agentIds: arrayType(stringType()).optional(),
    departments: arrayType(stringType()).optional(),
    dayRange: Period$inboundSchema.optional()
  });
  var AgentsInsightsV2Request$outboundSchema = objectType({
    agentIds: arrayType(stringType()).optional(),
    departments: arrayType(stringType()).optional(),
    dayRange: Period$outboundSchema.optional()
  });
  var AgentsInsightsV2Request$;
  (function(AgentsInsightsV2Request$2) {
    AgentsInsightsV2Request$2.inboundSchema = AgentsInsightsV2Request$inboundSchema;
    AgentsInsightsV2Request$2.outboundSchema = AgentsInsightsV2Request$outboundSchema;
  })(AgentsInsightsV2Request$ || (AgentsInsightsV2Request$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/aiappactioncounts.js
  var AiAppActionCounts$inboundSchema = collectExtraKeys(objectType({
    totalSlackbotResponses: numberType().int().optional(),
    totalSlackbotResponsesShared: numberType().int().optional(),
    totalSlackbotResponsesNotHelpful: numberType().int().optional(),
    totalChatMessages: numberType().int().optional(),
    totalUpvotes: numberType().int().optional(),
    totalDownvotes: numberType().int().optional()
  }).catchall(numberType().int()), "additionalProperties", true);
  var AiAppActionCounts$outboundSchema = objectType({
    totalSlackbotResponses: numberType().int().optional(),
    totalSlackbotResponsesShared: numberType().int().optional(),
    totalSlackbotResponsesNotHelpful: numberType().int().optional(),
    totalChatMessages: numberType().int().optional(),
    totalUpvotes: numberType().int().optional(),
    totalDownvotes: numberType().int().optional(),
    additionalProperties: recordType(numberType().int())
  }).transform((v) => {
    return {
      ...v.additionalProperties,
      ...remap(v, {
        additionalProperties: null
      })
    };
  });
  var AiAppActionCounts$;
  (function(AiAppActionCounts$2) {
    AiAppActionCounts$2.inboundSchema = AiAppActionCounts$inboundSchema;
    AiAppActionCounts$2.outboundSchema = AiAppActionCounts$outboundSchema;
  })(AiAppActionCounts$ || (AiAppActionCounts$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/useractivityinsight.js
  var ActivityEnum = {
    All: "ALL",
    Search: "SEARCH"
  };
  var ActivityEnum$inboundSchema = nativeEnumType(ActivityEnum);
  var ActivityEnum$outboundSchema = ActivityEnum$inboundSchema;
  var ActivityEnum$;
  (function(ActivityEnum$2) {
    ActivityEnum$2.inboundSchema = ActivityEnum$inboundSchema;
    ActivityEnum$2.outboundSchema = ActivityEnum$outboundSchema;
  })(ActivityEnum$ || (ActivityEnum$ = {}));
  var UserActivityInsight$inboundSchema = objectType({
    user: Person$inboundSchema,
    activity: ActivityEnum$inboundSchema,
    lastActivityTimestamp: numberType().int().optional(),
    activityCount: CountInfo$inboundSchema.optional(),
    activeDayCount: CountInfo$inboundSchema.optional()
  });
  var UserActivityInsight$outboundSchema = objectType({
    user: Person$outboundSchema,
    activity: ActivityEnum$outboundSchema,
    lastActivityTimestamp: numberType().int().optional(),
    activityCount: CountInfo$outboundSchema.optional(),
    activeDayCount: CountInfo$outboundSchema.optional()
  });
  var UserActivityInsight$;
  (function(UserActivityInsight$2) {
    UserActivityInsight$2.inboundSchema = UserActivityInsight$inboundSchema;
    UserActivityInsight$2.outboundSchema = UserActivityInsight$outboundSchema;
  })(UserActivityInsight$ || (UserActivityInsight$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/aiappsinsightsresponse.js
  var AiAppsInsightsResponse$inboundSchema = objectType({
    lastLogTimestamp: numberType().int().optional(),
    aiAppInsights: arrayType(UserActivityInsight$inboundSchema).optional(),
    totalActiveUsers: numberType().int().optional(),
    actionCounts: AiAppActionCounts$inboundSchema.optional(),
    departments: arrayType(stringType()).optional()
  });
  var AiAppsInsightsResponse$outboundSchema = objectType({
    lastLogTimestamp: numberType().int().optional(),
    aiAppInsights: arrayType(UserActivityInsight$outboundSchema).optional(),
    totalActiveUsers: numberType().int().optional(),
    actionCounts: AiAppActionCounts$outboundSchema.optional(),
    departments: arrayType(stringType()).optional()
  });
  var AiAppsInsightsResponse$;
  (function(AiAppsInsightsResponse$2) {
    AiAppsInsightsResponse$2.inboundSchema = AiAppsInsightsResponse$inboundSchema;
    AiAppsInsightsResponse$2.outboundSchema = AiAppsInsightsResponse$outboundSchema;
  })(AiAppsInsightsResponse$ || (AiAppsInsightsResponse$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/aiinsightsresponse.js
  var AiInsightsResponse$inboundSchema = objectType({
    lastLogTimestamp: numberType().int().optional(),
    assistantInsights: arrayType(UserActivityInsight$inboundSchema).optional(),
    totalActiveAssistantUsers: numberType().int().optional(),
    totalChatMessages: numberType().int().optional(),
    totalAiSummarizations: numberType().int().optional(),
    totalAiAnswers: numberType().int().optional(),
    totalUpvotes: numberType().int().optional(),
    totalDownvotes: numberType().int().optional(),
    totalGleanbotResponses: numberType().int().optional(),
    totalGleanbotResponsesShared: numberType().int().optional(),
    totalGleanbotResponsesNotHelpful: numberType().int().optional(),
    departments: arrayType(stringType()).optional()
  });
  var AiInsightsResponse$outboundSchema = objectType({
    lastLogTimestamp: numberType().int().optional(),
    assistantInsights: arrayType(UserActivityInsight$outboundSchema).optional(),
    totalActiveAssistantUsers: numberType().int().optional(),
    totalChatMessages: numberType().int().optional(),
    totalAiSummarizations: numberType().int().optional(),
    totalAiAnswers: numberType().int().optional(),
    totalUpvotes: numberType().int().optional(),
    totalDownvotes: numberType().int().optional(),
    totalGleanbotResponses: numberType().int().optional(),
    totalGleanbotResponsesShared: numberType().int().optional(),
    totalGleanbotResponsesNotHelpful: numberType().int().optional(),
    departments: arrayType(stringType()).optional()
  });
  var AiInsightsResponse$;
  (function(AiInsightsResponse$2) {
    AiInsightsResponse$2.inboundSchema = AiInsightsResponse$inboundSchema;
    AiInsightsResponse$2.outboundSchema = AiInsightsResponse$outboundSchema;
  })(AiInsightsResponse$ || (AiInsightsResponse$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/allowlistoptions.js
  var AllowlistOptions$inboundSchema = objectType({
    terms: arrayType(stringType()).optional()
  });
  var AllowlistOptions$outboundSchema = objectType({
    terms: arrayType(stringType()).optional()
  });
  var AllowlistOptions$;
  (function(AllowlistOptions$2) {
    AllowlistOptions$2.inboundSchema = AllowlistOptions$inboundSchema;
    AllowlistOptions$2.outboundSchema = AllowlistOptions$outboundSchema;
  })(AllowlistOptions$ || (AllowlistOptions$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/announcement.js
  var AnnouncementChannel = {
    Main: "MAIN",
    SocialFeed: "SOCIAL_FEED"
  };
  var AnnouncementPostType = {
    Text: "TEXT",
    Link: "LINK"
  };
  var AnnouncementChannel$inboundSchema = nativeEnumType(AnnouncementChannel);
  var AnnouncementChannel$outboundSchema = AnnouncementChannel$inboundSchema;
  var AnnouncementChannel$;
  (function(AnnouncementChannel$2) {
    AnnouncementChannel$2.inboundSchema = AnnouncementChannel$inboundSchema;
    AnnouncementChannel$2.outboundSchema = AnnouncementChannel$outboundSchema;
  })(AnnouncementChannel$ || (AnnouncementChannel$ = {}));
  var AnnouncementPostType$inboundSchema = nativeEnumType(AnnouncementPostType);
  var AnnouncementPostType$outboundSchema = AnnouncementPostType$inboundSchema;
  var AnnouncementPostType$;
  (function(AnnouncementPostType$2) {
    AnnouncementPostType$2.inboundSchema = AnnouncementPostType$inboundSchema;
    AnnouncementPostType$2.outboundSchema = AnnouncementPostType$outboundSchema;
  })(AnnouncementPostType$ || (AnnouncementPostType$ = {}));
  var AnnouncementViewerInfo$inboundSchema = objectType({
    isDismissed: booleanType().optional(),
    isRead: booleanType().optional()
  });
  var AnnouncementViewerInfo$outboundSchema = objectType({
    isDismissed: booleanType().optional(),
    isRead: booleanType().optional()
  });
  var AnnouncementViewerInfo$;
  (function(AnnouncementViewerInfo$2) {
    AnnouncementViewerInfo$2.inboundSchema = AnnouncementViewerInfo$inboundSchema;
    AnnouncementViewerInfo$2.outboundSchema = AnnouncementViewerInfo$outboundSchema;
  })(AnnouncementViewerInfo$ || (AnnouncementViewerInfo$ = {}));
  var Announcement$inboundSchema = objectType({
    startTime: stringType().datetime({ offset: true }).transform((v) => new Date(v)).optional(),
    endTime: stringType().datetime({ offset: true }).transform((v) => new Date(v)).optional(),
    title: stringType().optional(),
    body: StructuredText$inboundSchema.optional(),
    emoji: stringType().optional(),
    thumbnail: Thumbnail$inboundSchema.optional(),
    banner: Thumbnail$inboundSchema.optional(),
    audienceFilters: arrayType(FacetFilter$inboundSchema).optional(),
    sourceDocumentId: stringType().optional(),
    hideAttribution: booleanType().optional(),
    channel: AnnouncementChannel$inboundSchema.optional(),
    postType: AnnouncementPostType$inboundSchema.optional(),
    isPrioritized: booleanType().optional(),
    viewUrl: stringType().optional(),
    draftId: numberType().int().optional(),
    permissions: ObjectPermissions$inboundSchema.optional(),
    id: numberType().int().optional(),
    author: Person$inboundSchema.optional(),
    createTimestamp: numberType().int().optional(),
    lastUpdateTimestamp: numberType().int().optional(),
    updatedBy: Person$inboundSchema.optional(),
    viewerInfo: lazyType(() => AnnouncementViewerInfo$inboundSchema).optional(),
    sourceDocument: Document$inboundSchema.optional(),
    isPublished: booleanType().optional()
  });
  var Announcement$outboundSchema = objectType({
    startTime: dateType().transform((v) => v.toISOString()).optional(),
    endTime: dateType().transform((v) => v.toISOString()).optional(),
    title: stringType().optional(),
    body: StructuredText$outboundSchema.optional(),
    emoji: stringType().optional(),
    thumbnail: Thumbnail$outboundSchema.optional(),
    banner: Thumbnail$outboundSchema.optional(),
    audienceFilters: arrayType(FacetFilter$outboundSchema).optional(),
    sourceDocumentId: stringType().optional(),
    hideAttribution: booleanType().optional(),
    channel: AnnouncementChannel$outboundSchema.optional(),
    postType: AnnouncementPostType$outboundSchema.optional(),
    isPrioritized: booleanType().optional(),
    viewUrl: stringType().optional(),
    draftId: numberType().int().optional(),
    permissions: ObjectPermissions$outboundSchema.optional(),
    id: numberType().int().optional(),
    author: Person$outboundSchema.optional(),
    createTimestamp: numberType().int().optional(),
    lastUpdateTimestamp: numberType().int().optional(),
    updatedBy: Person$outboundSchema.optional(),
    viewerInfo: lazyType(() => AnnouncementViewerInfo$outboundSchema).optional(),
    sourceDocument: Document$outboundSchema.optional(),
    isPublished: booleanType().optional()
  });
  var Announcement$;
  (function(Announcement$2) {
    Announcement$2.inboundSchema = Announcement$inboundSchema;
    Announcement$2.outboundSchema = Announcement$outboundSchema;
  })(Announcement$ || (Announcement$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/structuredtextmutableproperties.js
  var StructuredTextMutableProperties$inboundSchema = objectType({
    text: stringType()
  });
  var StructuredTextMutableProperties$outboundSchema = objectType({
    text: stringType()
  });
  var StructuredTextMutableProperties$;
  (function(StructuredTextMutableProperties$2) {
    StructuredTextMutableProperties$2.inboundSchema = StructuredTextMutableProperties$inboundSchema;
    StructuredTextMutableProperties$2.outboundSchema = StructuredTextMutableProperties$outboundSchema;
  })(StructuredTextMutableProperties$ || (StructuredTextMutableProperties$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/answercreationdata.js
  var AnswerCreationDataSourceType = {
    Document: "DOCUMENT",
    Assistant: "ASSISTANT"
  };
  var AnswerCreationDataSourceType$inboundSchema = nativeEnumType(AnswerCreationDataSourceType);
  var AnswerCreationDataSourceType$outboundSchema = AnswerCreationDataSourceType$inboundSchema;
  var AnswerCreationDataSourceType$;
  (function(AnswerCreationDataSourceType$2) {
    AnswerCreationDataSourceType$2.inboundSchema = AnswerCreationDataSourceType$inboundSchema;
    AnswerCreationDataSourceType$2.outboundSchema = AnswerCreationDataSourceType$outboundSchema;
  })(AnswerCreationDataSourceType$ || (AnswerCreationDataSourceType$ = {}));
  var AnswerCreationData$inboundSchema = objectType({
    question: stringType().optional(),
    questionVariations: arrayType(stringType()).optional(),
    bodyText: stringType().optional(),
    boardId: numberType().int().optional(),
    audienceFilters: arrayType(FacetFilter$inboundSchema).optional(),
    addedRoles: arrayType(UserRoleSpecification$inboundSchema).optional(),
    removedRoles: arrayType(UserRoleSpecification$inboundSchema).optional(),
    roles: arrayType(UserRoleSpecification$inboundSchema).optional(),
    sourceDocumentSpec: DocumentSpecUnion$inboundSchema.optional(),
    sourceType: AnswerCreationDataSourceType$inboundSchema.optional(),
    addedCollections: arrayType(numberType().int()).optional(),
    combinedAnswerText: StructuredTextMutableProperties$inboundSchema.optional()
  });
  var AnswerCreationData$outboundSchema = objectType({
    question: stringType().optional(),
    questionVariations: arrayType(stringType()).optional(),
    bodyText: stringType().optional(),
    boardId: numberType().int().optional(),
    audienceFilters: arrayType(FacetFilter$outboundSchema).optional(),
    addedRoles: arrayType(UserRoleSpecification$outboundSchema).optional(),
    removedRoles: arrayType(UserRoleSpecification$outboundSchema).optional(),
    roles: arrayType(UserRoleSpecification$outboundSchema).optional(),
    sourceDocumentSpec: DocumentSpecUnion$outboundSchema.optional(),
    sourceType: AnswerCreationDataSourceType$outboundSchema.optional(),
    addedCollections: arrayType(numberType().int()).optional(),
    combinedAnswerText: StructuredTextMutableProperties$outboundSchema.optional()
  });
  var AnswerCreationData$;
  (function(AnswerCreationData$2) {
    AnswerCreationData$2.inboundSchema = AnswerCreationData$inboundSchema;
    AnswerCreationData$2.outboundSchema = AnswerCreationData$outboundSchema;
  })(AnswerCreationData$ || (AnswerCreationData$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/answerresult.js
  var AnswerResult$inboundSchema = objectType({
    answer: Answer$inboundSchema,
    trackingToken: stringType().optional()
  });
  var AnswerResult$outboundSchema = objectType({
    answer: Answer$outboundSchema,
    trackingToken: stringType().optional()
  });
  var AnswerResult$;
  (function(AnswerResult$2) {
    AnswerResult$2.inboundSchema = AnswerResult$inboundSchema;
    AnswerResult$2.outboundSchema = AnswerResult$outboundSchema;
  })(AnswerResult$ || (AnswerResult$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/authconfig.js
  var AuthConfigType = {
    None: "NONE",
    OauthUser: "OAUTH_USER",
    OauthAdmin: "OAUTH_ADMIN",
    ApiKey: "API_KEY",
    BasicAuth: "BASIC_AUTH",
    Dwd: "DWD"
  };
  var GrantType = {
    AuthCode: "AUTH_CODE",
    ClientCredentials: "CLIENT_CREDENTIALS"
  };
  var AuthConfigStatus = {
    AwaitingAuth: "AWAITING_AUTH",
    Authorized: "AUTHORIZED",
    AuthDisabled: "AUTH_DISABLED"
  };
  var AuthConfigType$inboundSchema = nativeEnumType(AuthConfigType);
  var AuthConfigType$outboundSchema = AuthConfigType$inboundSchema;
  var AuthConfigType$;
  (function(AuthConfigType$2) {
    AuthConfigType$2.inboundSchema = AuthConfigType$inboundSchema;
    AuthConfigType$2.outboundSchema = AuthConfigType$outboundSchema;
  })(AuthConfigType$ || (AuthConfigType$ = {}));
  var GrantType$inboundSchema = nativeEnumType(GrantType);
  var GrantType$outboundSchema = GrantType$inboundSchema;
  var GrantType$;
  (function(GrantType$2) {
    GrantType$2.inboundSchema = GrantType$inboundSchema;
    GrantType$2.outboundSchema = GrantType$outboundSchema;
  })(GrantType$ || (GrantType$ = {}));
  var AuthConfigStatus$inboundSchema = nativeEnumType(AuthConfigStatus);
  var AuthConfigStatus$outboundSchema = AuthConfigStatus$inboundSchema;
  var AuthConfigStatus$;
  (function(AuthConfigStatus$2) {
    AuthConfigStatus$2.inboundSchema = AuthConfigStatus$inboundSchema;
    AuthConfigStatus$2.outboundSchema = AuthConfigStatus$outboundSchema;
  })(AuthConfigStatus$ || (AuthConfigStatus$ = {}));
  var AuthConfig$inboundSchema = objectType({
    isOnPrem: booleanType().optional(),
    usesCentralAuth: booleanType().optional(),
    type: AuthConfigType$inboundSchema.optional(),
    grantType: GrantType$inboundSchema.optional(),
    status: AuthConfigStatus$inboundSchema.optional(),
    client_url: stringType().optional(),
    scopes: arrayType(stringType()).optional(),
    audiences: arrayType(stringType()).optional(),
    authorization_url: stringType().optional(),
    lastAuthorizedAt: stringType().datetime({ offset: true }).transform((v) => new Date(v)).optional()
  }).transform((v) => {
    return remap(v, {
      "client_url": "clientUrl",
      "authorization_url": "authorizationUrl"
    });
  });
  var AuthConfig$outboundSchema = objectType({
    isOnPrem: booleanType().optional(),
    usesCentralAuth: booleanType().optional(),
    type: AuthConfigType$outboundSchema.optional(),
    grantType: GrantType$outboundSchema.optional(),
    status: AuthConfigStatus$outboundSchema.optional(),
    clientUrl: stringType().optional(),
    scopes: arrayType(stringType()).optional(),
    audiences: arrayType(stringType()).optional(),
    authorizationUrl: stringType().optional(),
    lastAuthorizedAt: dateType().transform((v) => v.toISOString()).optional()
  }).transform((v) => {
    return remap(v, {
      clientUrl: "client_url",
      authorizationUrl: "authorization_url"
    });
  });
  var AuthConfig$;
  (function(AuthConfig$2) {
    AuthConfig$2.inboundSchema = AuthConfig$inboundSchema;
    AuthConfig$2.outboundSchema = AuthConfig$outboundSchema;
  })(AuthConfig$ || (AuthConfig$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/sessioninfo.js
  var SessionInfo$inboundSchema = objectType({
    sessionTrackingToken: stringType().optional(),
    tabId: stringType().optional(),
    lastSeen: stringType().datetime({ offset: true }).transform((v) => new Date(v)).optional(),
    lastQuery: stringType().optional()
  });
  var SessionInfo$outboundSchema = objectType({
    sessionTrackingToken: stringType().optional(),
    tabId: stringType().optional(),
    lastSeen: dateType().transform((v) => v.toISOString()).optional(),
    lastQuery: stringType().optional()
  });
  var SessionInfo$;
  (function(SessionInfo$2) {
    SessionInfo$2.inboundSchema = SessionInfo$inboundSchema;
    SessionInfo$2.outboundSchema = SessionInfo$outboundSchema;
  })(SessionInfo$ || (SessionInfo$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/autocompleterequest.js
  var AutocompleteRequestResultType = {
    AdditionalDocument: "ADDITIONAL_DOCUMENT",
    App: "APP",
    BrowserHistory: "BROWSER_HISTORY",
    Datasource: "DATASOURCE",
    Document: "DOCUMENT",
    Entity: "ENTITY",
    Golink: "GOLINK",
    History: "HISTORY",
    NewChat: "NEW_CHAT",
    Operator: "OPERATOR",
    OperatorValue: "OPERATOR_VALUE",
    Quicklink: "QUICKLINK",
    Suggestion: "SUGGESTION"
  };
  var AutocompleteRequestResultType$inboundSchema = nativeEnumType(AutocompleteRequestResultType);
  var AutocompleteRequestResultType$outboundSchema = AutocompleteRequestResultType$inboundSchema;
  var AutocompleteRequestResultType$;
  (function(AutocompleteRequestResultType$2) {
    AutocompleteRequestResultType$2.inboundSchema = AutocompleteRequestResultType$inboundSchema;
    AutocompleteRequestResultType$2.outboundSchema = AutocompleteRequestResultType$outboundSchema;
  })(AutocompleteRequestResultType$ || (AutocompleteRequestResultType$ = {}));
  var AutocompleteRequest$inboundSchema = objectType({
    trackingToken: stringType().optional(),
    sessionInfo: SessionInfo$inboundSchema.optional(),
    query: stringType().optional(),
    datasourcesFilter: arrayType(stringType()).optional(),
    datasource: stringType().optional(),
    resultTypes: arrayType(AutocompleteRequestResultType$inboundSchema).optional(),
    resultSize: numberType().int().optional(),
    authTokens: arrayType(AuthToken$inboundSchema).optional()
  });
  var AutocompleteRequest$outboundSchema = objectType({
    trackingToken: stringType().optional(),
    sessionInfo: SessionInfo$outboundSchema.optional(),
    query: stringType().optional(),
    datasourcesFilter: arrayType(stringType()).optional(),
    datasource: stringType().optional(),
    resultTypes: arrayType(AutocompleteRequestResultType$outboundSchema).optional(),
    resultSize: numberType().int().optional(),
    authTokens: arrayType(AuthToken$outboundSchema).optional()
  });
  var AutocompleteRequest$;
  (function(AutocompleteRequest$2) {
    AutocompleteRequest$2.inboundSchema = AutocompleteRequest$inboundSchema;
    AutocompleteRequest$2.outboundSchema = AutocompleteRequest$outboundSchema;
  })(AutocompleteRequest$ || (AutocompleteRequest$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/operatorscope.js
  var OperatorScope$inboundSchema = objectType({
    datasource: stringType().optional(),
    docType: stringType().optional()
  });
  var OperatorScope$outboundSchema = objectType({
    datasource: stringType().optional(),
    docType: stringType().optional()
  });
  var OperatorScope$;
  (function(OperatorScope$2) {
    OperatorScope$2.inboundSchema = OperatorScope$inboundSchema;
    OperatorScope$2.outboundSchema = OperatorScope$outboundSchema;
  })(OperatorScope$ || (OperatorScope$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/operatormetadata.js
  var OperatorType = {
    Text: "TEXT",
    Double: "DOUBLE",
    Date: "DATE",
    User: "USER"
  };
  var OperatorType$inboundSchema = nativeEnumType(OperatorType);
  var OperatorType$outboundSchema = OperatorType$inboundSchema;
  var OperatorType$;
  (function(OperatorType$2) {
    OperatorType$2.inboundSchema = OperatorType$inboundSchema;
    OperatorType$2.outboundSchema = OperatorType$outboundSchema;
  })(OperatorType$ || (OperatorType$ = {}));
  var OperatorMetadata$inboundSchema = objectType({
    name: stringType(),
    isCustom: booleanType().optional(),
    operatorType: OperatorType$inboundSchema.optional(),
    helpText: stringType().optional(),
    scopes: arrayType(OperatorScope$inboundSchema).optional(),
    value: stringType().optional(),
    displayValue: stringType().optional()
  });
  var OperatorMetadata$outboundSchema = objectType({
    name: stringType(),
    isCustom: booleanType().optional(),
    operatorType: OperatorType$outboundSchema.optional(),
    helpText: stringType().optional(),
    scopes: arrayType(OperatorScope$outboundSchema).optional(),
    value: stringType().optional(),
    displayValue: stringType().optional()
  });
  var OperatorMetadata$;
  (function(OperatorMetadata$2) {
    OperatorMetadata$2.inboundSchema = OperatorMetadata$inboundSchema;
    OperatorMetadata$2.outboundSchema = OperatorMetadata$outboundSchema;
  })(OperatorMetadata$ || (OperatorMetadata$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/quicklink.js
  var Scope = {
    AppCard: "APP_CARD",
    AutocompleteExactMatch: "AUTOCOMPLETE_EXACT_MATCH",
    AutocompleteFuzzyMatch: "AUTOCOMPLETE_FUZZY_MATCH",
    AutocompleteZeroQuery: "AUTOCOMPLETE_ZERO_QUERY",
    NewTabPage: "NEW_TAB_PAGE"
  };
  var Scope$inboundSchema = nativeEnumType(Scope);
  var Scope$outboundSchema = Scope$inboundSchema;
  var Scope$;
  (function(Scope$2) {
    Scope$2.inboundSchema = Scope$inboundSchema;
    Scope$2.outboundSchema = Scope$outboundSchema;
  })(Scope$ || (Scope$ = {}));
  var Quicklink$inboundSchema = objectType({
    name: stringType().optional(),
    shortName: stringType().optional(),
    url: stringType().optional(),
    iconConfig: IconConfig$inboundSchema.optional(),
    id: stringType().optional(),
    scopes: arrayType(Scope$inboundSchema).optional()
  });
  var Quicklink$outboundSchema = objectType({
    name: stringType().optional(),
    shortName: stringType().optional(),
    url: stringType().optional(),
    iconConfig: IconConfig$outboundSchema.optional(),
    id: stringType().optional(),
    scopes: arrayType(Scope$outboundSchema).optional()
  });
  var Quicklink$;
  (function(Quicklink$2) {
    Quicklink$2.inboundSchema = Quicklink$inboundSchema;
    Quicklink$2.outboundSchema = Quicklink$outboundSchema;
  })(Quicklink$ || (Quicklink$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/autocompleteresult.js
  var AutocompleteResultResultType = {
    AdditionalDocument: "ADDITIONAL_DOCUMENT",
    App: "APP",
    BrowserHistory: "BROWSER_HISTORY",
    Datasource: "DATASOURCE",
    Document: "DOCUMENT",
    Entity: "ENTITY",
    Golink: "GOLINK",
    History: "HISTORY",
    NewChat: "NEW_CHAT",
    Operator: "OPERATOR",
    OperatorValue: "OPERATOR_VALUE",
    Quicklink: "QUICKLINK",
    Suggestion: "SUGGESTION"
  };
  var AutocompleteResultResultType$inboundSchema = nativeEnumType(AutocompleteResultResultType);
  var AutocompleteResultResultType$outboundSchema = AutocompleteResultResultType$inboundSchema;
  var AutocompleteResultResultType$;
  (function(AutocompleteResultResultType$2) {
    AutocompleteResultResultType$2.inboundSchema = AutocompleteResultResultType$inboundSchema;
    AutocompleteResultResultType$2.outboundSchema = AutocompleteResultResultType$outboundSchema;
  })(AutocompleteResultResultType$ || (AutocompleteResultResultType$ = {}));
  var AutocompleteResult$inboundSchema = objectType({
    result: stringType(),
    keywords: arrayType(stringType()).optional(),
    resultType: AutocompleteResultResultType$inboundSchema.optional(),
    score: numberType().optional(),
    operatorMetadata: OperatorMetadata$inboundSchema.optional(),
    quicklink: Quicklink$inboundSchema.optional(),
    document: Document$inboundSchema.optional(),
    url: stringType().optional(),
    structuredResult: StructuredResult$inboundSchema.optional(),
    trackingToken: stringType().optional(),
    ranges: arrayType(TextRange$inboundSchema).optional()
  });
  var AutocompleteResult$outboundSchema = objectType({
    result: stringType(),
    keywords: arrayType(stringType()).optional(),
    resultType: AutocompleteResultResultType$outboundSchema.optional(),
    score: numberType().optional(),
    operatorMetadata: OperatorMetadata$outboundSchema.optional(),
    quicklink: Quicklink$outboundSchema.optional(),
    document: Document$outboundSchema.optional(),
    url: stringType().optional(),
    structuredResult: StructuredResult$outboundSchema.optional(),
    trackingToken: stringType().optional(),
    ranges: arrayType(TextRange$outboundSchema).optional()
  });
  var AutocompleteResult$;
  (function(AutocompleteResult$2) {
    AutocompleteResult$2.inboundSchema = AutocompleteResult$inboundSchema;
    AutocompleteResult$2.outboundSchema = AutocompleteResult$outboundSchema;
  })(AutocompleteResult$ || (AutocompleteResult$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/autocompleteresultgroup.js
  var AutocompleteResultGroup$inboundSchema = objectType({
    startIndex: numberType().int().optional(),
    endIndex: numberType().int().optional(),
    title: stringType().optional()
  });
  var AutocompleteResultGroup$outboundSchema = objectType({
    startIndex: numberType().int().optional(),
    endIndex: numberType().int().optional(),
    title: stringType().optional()
  });
  var AutocompleteResultGroup$;
  (function(AutocompleteResultGroup$2) {
    AutocompleteResultGroup$2.inboundSchema = AutocompleteResultGroup$inboundSchema;
    AutocompleteResultGroup$2.outboundSchema = AutocompleteResultGroup$outboundSchema;
  })(AutocompleteResultGroup$ || (AutocompleteResultGroup$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/errormessage.js
  var ErrorMessage$inboundSchema = objectType({
    source: stringType().optional(),
    errorMessage: stringType().optional()
  });
  var ErrorMessage$outboundSchema = objectType({
    source: stringType().optional(),
    errorMessage: stringType().optional()
  });
  var ErrorMessage$;
  (function(ErrorMessage$2) {
    ErrorMessage$2.inboundSchema = ErrorMessage$inboundSchema;
    ErrorMessage$2.outboundSchema = ErrorMessage$outboundSchema;
  })(ErrorMessage$ || (ErrorMessage$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/invalidoperatorvalueerror.js
  var InvalidOperatorValueError$inboundSchema = objectType({
    key: stringType().optional(),
    value: stringType().optional()
  });
  var InvalidOperatorValueError$outboundSchema = objectType({
    key: stringType().optional(),
    value: stringType().optional()
  });
  var InvalidOperatorValueError$;
  (function(InvalidOperatorValueError$2) {
    InvalidOperatorValueError$2.inboundSchema = InvalidOperatorValueError$inboundSchema;
    InvalidOperatorValueError$2.outboundSchema = InvalidOperatorValueError$outboundSchema;
  })(InvalidOperatorValueError$ || (InvalidOperatorValueError$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/gleandataerror.js
  var GleanDataError$inboundSchema = objectType({
    badGmailToken: booleanType().optional(),
    badOutlookToken: booleanType().optional(),
    invalidOperators: arrayType(InvalidOperatorValueError$inboundSchema).optional(),
    errorMessages: arrayType(ErrorMessage$inboundSchema).optional()
  });
  var GleanDataError$outboundSchema = objectType({
    badGmailToken: booleanType().optional(),
    badOutlookToken: booleanType().optional(),
    invalidOperators: arrayType(InvalidOperatorValueError$outboundSchema).optional(),
    errorMessages: arrayType(ErrorMessage$outboundSchema).optional()
  });
  var GleanDataError$;
  (function(GleanDataError$3) {
    GleanDataError$3.inboundSchema = GleanDataError$inboundSchema;
    GleanDataError$3.outboundSchema = GleanDataError$outboundSchema;
  })(GleanDataError$ || (GleanDataError$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/autocompleteresponse.js
  var AutocompleteResponse$inboundSchema = objectType({
    experimentIds: arrayType(numberType().int()).optional(),
    trackingToken: stringType().optional(),
    sessionInfo: SessionInfo$inboundSchema.optional(),
    results: arrayType(AutocompleteResult$inboundSchema).optional(),
    groups: arrayType(AutocompleteResultGroup$inboundSchema).optional(),
    errorInfo: GleanDataError$inboundSchema.optional(),
    backendTimeMillis: numberType().int().optional()
  }).transform((v) => {
    return remap(v, {
      "errorInfo": "gleanDataError"
    });
  });
  var AutocompleteResponse$outboundSchema = objectType({
    experimentIds: arrayType(numberType().int()).optional(),
    trackingToken: stringType().optional(),
    sessionInfo: SessionInfo$outboundSchema.optional(),
    results: arrayType(AutocompleteResult$outboundSchema).optional(),
    groups: arrayType(AutocompleteResultGroup$outboundSchema).optional(),
    gleanDataError: GleanDataError$outboundSchema.optional(),
    backendTimeMillis: numberType().int().optional()
  }).transform((v) => {
    return remap(v, {
      gleanDataError: "errorInfo"
    });
  });
  var AutocompleteResponse$;
  (function(AutocompleteResponse$2) {
    AutocompleteResponse$2.inboundSchema = AutocompleteResponse$inboundSchema;
    AutocompleteResponse$2.outboundSchema = AutocompleteResponse$outboundSchema;
  })(AutocompleteResponse$ || (AutocompleteResponse$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/contentdefinition.js
  var ContentDefinition$inboundSchema = objectType({
    mimeType: stringType(),
    textContent: stringType().optional(),
    binaryContent: stringType().optional()
  });
  var ContentDefinition$outboundSchema = objectType({
    mimeType: stringType(),
    textContent: stringType().optional(),
    binaryContent: stringType().optional()
  });
  var ContentDefinition$;
  (function(ContentDefinition$2) {
    ContentDefinition$2.inboundSchema = ContentDefinition$inboundSchema;
    ContentDefinition$2.outboundSchema = ContentDefinition$outboundSchema;
  })(ContentDefinition$ || (ContentDefinition$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/userreferencedefinition.js
  var UserReferenceDefinition$inboundSchema = objectType({
    email: stringType().optional(),
    datasourceUserId: stringType().optional(),
    name: stringType().optional()
  });
  var UserReferenceDefinition$outboundSchema = objectType({
    email: stringType().optional(),
    datasourceUserId: stringType().optional(),
    name: stringType().optional()
  });
  var UserReferenceDefinition$;
  (function(UserReferenceDefinition$2) {
    UserReferenceDefinition$2.inboundSchema = UserReferenceDefinition$inboundSchema;
    UserReferenceDefinition$2.outboundSchema = UserReferenceDefinition$outboundSchema;
  })(UserReferenceDefinition$ || (UserReferenceDefinition$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/commentdefinition.js
  var CommentDefinition$inboundSchema = objectType({
    id: stringType(),
    author: UserReferenceDefinition$inboundSchema.optional(),
    content: ContentDefinition$inboundSchema.optional(),
    createdAt: numberType().int().optional(),
    updatedAt: numberType().int().optional(),
    updatedBy: UserReferenceDefinition$inboundSchema.optional()
  });
  var CommentDefinition$outboundSchema = objectType({
    id: stringType(),
    author: UserReferenceDefinition$outboundSchema.optional(),
    content: ContentDefinition$outboundSchema.optional(),
    createdAt: numberType().int().optional(),
    updatedAt: numberType().int().optional(),
    updatedBy: UserReferenceDefinition$outboundSchema.optional()
  });
  var CommentDefinition$;
  (function(CommentDefinition$2) {
    CommentDefinition$2.inboundSchema = CommentDefinition$inboundSchema;
    CommentDefinition$2.outboundSchema = CommentDefinition$outboundSchema;
  })(CommentDefinition$ || (CommentDefinition$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/customproperty.js
  var CustomProperty$inboundSchema = objectType({
    name: stringType().optional(),
    value: anyType().optional()
  });
  var CustomProperty$outboundSchema = objectType({
    name: stringType().optional(),
    value: anyType().optional()
  });
  var CustomProperty$;
  (function(CustomProperty$2) {
    CustomProperty$2.inboundSchema = CustomProperty$inboundSchema;
    CustomProperty$2.outboundSchema = CustomProperty$outboundSchema;
  })(CustomProperty$ || (CustomProperty$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/documentinteractionsdefinition.js
  var DocumentInteractionsDefinition$inboundSchema = objectType({
    numViews: numberType().int().optional(),
    numLikes: numberType().int().optional(),
    numComments: numberType().int().optional()
  });
  var DocumentInteractionsDefinition$outboundSchema = objectType({
    numViews: numberType().int().optional(),
    numLikes: numberType().int().optional(),
    numComments: numberType().int().optional()
  });
  var DocumentInteractionsDefinition$;
  (function(DocumentInteractionsDefinition$2) {
    DocumentInteractionsDefinition$2.inboundSchema = DocumentInteractionsDefinition$inboundSchema;
    DocumentInteractionsDefinition$2.outboundSchema = DocumentInteractionsDefinition$outboundSchema;
  })(DocumentInteractionsDefinition$ || (DocumentInteractionsDefinition$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/permissionsgroupintersectiondefinition.js
  var PermissionsGroupIntersectionDefinition$inboundSchema = objectType({
    requiredGroups: arrayType(stringType()).optional()
  });
  var PermissionsGroupIntersectionDefinition$outboundSchema = objectType({
    requiredGroups: arrayType(stringType()).optional()
  });
  var PermissionsGroupIntersectionDefinition$;
  (function(PermissionsGroupIntersectionDefinition$2) {
    PermissionsGroupIntersectionDefinition$2.inboundSchema = PermissionsGroupIntersectionDefinition$inboundSchema;
    PermissionsGroupIntersectionDefinition$2.outboundSchema = PermissionsGroupIntersectionDefinition$outboundSchema;
  })(PermissionsGroupIntersectionDefinition$ || (PermissionsGroupIntersectionDefinition$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/documentpermissionsdefinition.js
  var DocumentPermissionsDefinition$inboundSchema = objectType({
    allowedUsers: arrayType(UserReferenceDefinition$inboundSchema).optional(),
    allowedGroups: arrayType(stringType()).optional(),
    allowedGroupIntersections: arrayType(PermissionsGroupIntersectionDefinition$inboundSchema).optional(),
    allowAnonymousAccess: booleanType().optional(),
    allowAllDatasourceUsersAccess: booleanType().optional()
  });
  var DocumentPermissionsDefinition$outboundSchema = objectType({
    allowedUsers: arrayType(UserReferenceDefinition$outboundSchema).optional(),
    allowedGroups: arrayType(stringType()).optional(),
    allowedGroupIntersections: arrayType(PermissionsGroupIntersectionDefinition$outboundSchema).optional(),
    allowAnonymousAccess: booleanType().optional(),
    allowAllDatasourceUsersAccess: booleanType().optional()
  });
  var DocumentPermissionsDefinition$;
  (function(DocumentPermissionsDefinition$2) {
    DocumentPermissionsDefinition$2.inboundSchema = DocumentPermissionsDefinition$inboundSchema;
    DocumentPermissionsDefinition$2.outboundSchema = DocumentPermissionsDefinition$outboundSchema;
  })(DocumentPermissionsDefinition$ || (DocumentPermissionsDefinition$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/documentdefinition.js
  var DocumentDefinition$inboundSchema = objectType({
    title: stringType().optional(),
    filename: stringType().optional(),
    container: stringType().optional(),
    containerDatasourceId: stringType().optional(),
    containerObjectType: stringType().optional(),
    datasource: stringType(),
    objectType: stringType().optional(),
    viewURL: stringType().optional(),
    id: stringType().optional(),
    summary: ContentDefinition$inboundSchema.optional(),
    body: ContentDefinition$inboundSchema.optional(),
    author: UserReferenceDefinition$inboundSchema.optional(),
    owner: UserReferenceDefinition$inboundSchema.optional(),
    permissions: DocumentPermissionsDefinition$inboundSchema.optional(),
    createdAt: numberType().int().optional(),
    updatedAt: numberType().int().optional(),
    updatedBy: UserReferenceDefinition$inboundSchema.optional(),
    tags: arrayType(stringType()).optional(),
    interactions: DocumentInteractionsDefinition$inboundSchema.optional(),
    status: stringType().optional(),
    additionalUrls: arrayType(stringType()).optional(),
    comments: arrayType(CommentDefinition$inboundSchema).optional(),
    customProperties: arrayType(CustomProperty$inboundSchema).optional()
  });
  var DocumentDefinition$outboundSchema = objectType({
    title: stringType().optional(),
    filename: stringType().optional(),
    container: stringType().optional(),
    containerDatasourceId: stringType().optional(),
    containerObjectType: stringType().optional(),
    datasource: stringType(),
    objectType: stringType().optional(),
    viewURL: stringType().optional(),
    id: stringType().optional(),
    summary: ContentDefinition$outboundSchema.optional(),
    body: ContentDefinition$outboundSchema.optional(),
    author: UserReferenceDefinition$outboundSchema.optional(),
    owner: UserReferenceDefinition$outboundSchema.optional(),
    permissions: DocumentPermissionsDefinition$outboundSchema.optional(),
    createdAt: numberType().int().optional(),
    updatedAt: numberType().int().optional(),
    updatedBy: UserReferenceDefinition$outboundSchema.optional(),
    tags: arrayType(stringType()).optional(),
    interactions: DocumentInteractionsDefinition$outboundSchema.optional(),
    status: stringType().optional(),
    additionalUrls: arrayType(stringType()).optional(),
    comments: arrayType(CommentDefinition$outboundSchema).optional(),
    customProperties: arrayType(CustomProperty$outboundSchema).optional()
  });
  var DocumentDefinition$;
  (function(DocumentDefinition$2) {
    DocumentDefinition$2.inboundSchema = DocumentDefinition$inboundSchema;
    DocumentDefinition$2.outboundSchema = DocumentDefinition$outboundSchema;
  })(DocumentDefinition$ || (DocumentDefinition$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/bulkindexdocumentsrequest.js
  var BulkIndexDocumentsRequest$inboundSchema = objectType({
    uploadId: stringType(),
    isFirstPage: booleanType().optional(),
    isLastPage: booleanType().optional(),
    forceRestartUpload: booleanType().optional(),
    datasource: stringType(),
    documents: arrayType(DocumentDefinition$inboundSchema),
    disableStaleDocumentDeletionCheck: booleanType().optional()
  });
  var BulkIndexDocumentsRequest$outboundSchema = objectType({
    uploadId: stringType(),
    isFirstPage: booleanType().optional(),
    isLastPage: booleanType().optional(),
    forceRestartUpload: booleanType().optional(),
    datasource: stringType(),
    documents: arrayType(DocumentDefinition$outboundSchema),
    disableStaleDocumentDeletionCheck: booleanType().optional()
  });
  var BulkIndexDocumentsRequest$;
  (function(BulkIndexDocumentsRequest$2) {
    BulkIndexDocumentsRequest$2.inboundSchema = BulkIndexDocumentsRequest$inboundSchema;
    BulkIndexDocumentsRequest$2.outboundSchema = BulkIndexDocumentsRequest$outboundSchema;
  })(BulkIndexDocumentsRequest$ || (BulkIndexDocumentsRequest$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/employeeteaminfo.js
  var EmployeeTeamInfo$inboundSchema = objectType({
    id: stringType().optional(),
    name: stringType().optional(),
    url: stringType().optional()
  });
  var EmployeeTeamInfo$outboundSchema = objectType({
    id: stringType().optional(),
    name: stringType().optional(),
    url: stringType().optional()
  });
  var EmployeeTeamInfo$;
  (function(EmployeeTeamInfo$2) {
    EmployeeTeamInfo$2.inboundSchema = EmployeeTeamInfo$inboundSchema;
    EmployeeTeamInfo$2.outboundSchema = EmployeeTeamInfo$outboundSchema;
  })(EmployeeTeamInfo$ || (EmployeeTeamInfo$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/entityrelationship.js
  var EntityRelationship$inboundSchema = objectType({
    name: stringType(),
    email: stringType()
  });
  var EntityRelationship$outboundSchema = objectType({
    name: stringType(),
    email: stringType()
  });
  var EntityRelationship$;
  (function(EntityRelationship$2) {
    EntityRelationship$2.inboundSchema = EntityRelationship$inboundSchema;
    EntityRelationship$2.outboundSchema = EntityRelationship$outboundSchema;
  })(EntityRelationship$ || (EntityRelationship$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/socialnetworkdefinition.js
  var SocialNetworkDefinition$inboundSchema = objectType({
    name: stringType().optional(),
    profileName: stringType().optional(),
    profileUrl: stringType().optional()
  });
  var SocialNetworkDefinition$outboundSchema = objectType({
    name: stringType().optional(),
    profileName: stringType().optional(),
    profileUrl: stringType().optional()
  });
  var SocialNetworkDefinition$;
  (function(SocialNetworkDefinition$2) {
    SocialNetworkDefinition$2.inboundSchema = SocialNetworkDefinition$inboundSchema;
    SocialNetworkDefinition$2.outboundSchema = SocialNetworkDefinition$outboundSchema;
  })(SocialNetworkDefinition$ || (SocialNetworkDefinition$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/employeeinfodefinition.js
  var EmployeeInfoDefinition$inboundSchema = objectType({
    email: stringType(),
    firstName: stringType().optional(),
    lastName: stringType().optional(),
    preferredName: stringType().optional(),
    id: stringType().optional(),
    phoneNumber: stringType().optional(),
    location: stringType().optional(),
    structuredLocation: StructuredLocation$inboundSchema.optional(),
    title: stringType().optional(),
    photoUrl: stringType().optional(),
    businessUnit: stringType().optional(),
    department: stringType(),
    datasourceProfiles: arrayType(DatasourceProfile$inboundSchema).optional(),
    teams: arrayType(EmployeeTeamInfo$inboundSchema).optional(),
    startDate: stringType().transform((v) => new RFCDate(v)).optional(),
    endDate: stringType().transform((v) => new RFCDate(v)).optional(),
    bio: stringType().optional(),
    pronoun: stringType().optional(),
    alsoKnownAs: arrayType(stringType()).optional(),
    profileUrl: stringType().optional(),
    socialNetworks: arrayType(SocialNetworkDefinition$inboundSchema).optional(),
    managerEmail: stringType().optional(),
    managerId: stringType().optional(),
    type: stringType().default("FULL_TIME"),
    relationships: arrayType(EntityRelationship$inboundSchema).optional(),
    status: stringType().default("CURRENT"),
    additionalFields: arrayType(AdditionalFieldDefinition$inboundSchema).optional()
  });
  var EmployeeInfoDefinition$outboundSchema = objectType({
    email: stringType(),
    firstName: stringType().optional(),
    lastName: stringType().optional(),
    preferredName: stringType().optional(),
    id: stringType().optional(),
    phoneNumber: stringType().optional(),
    location: stringType().optional(),
    structuredLocation: StructuredLocation$outboundSchema.optional(),
    title: stringType().optional(),
    photoUrl: stringType().optional(),
    businessUnit: stringType().optional(),
    department: stringType(),
    datasourceProfiles: arrayType(DatasourceProfile$outboundSchema).optional(),
    teams: arrayType(EmployeeTeamInfo$outboundSchema).optional(),
    startDate: instanceOfType(RFCDate).transform((v) => v.toString()).optional(),
    endDate: instanceOfType(RFCDate).transform((v) => v.toString()).optional(),
    bio: stringType().optional(),
    pronoun: stringType().optional(),
    alsoKnownAs: arrayType(stringType()).optional(),
    profileUrl: stringType().optional(),
    socialNetworks: arrayType(SocialNetworkDefinition$outboundSchema).optional(),
    managerEmail: stringType().optional(),
    managerId: stringType().optional(),
    type: stringType().default("FULL_TIME"),
    relationships: arrayType(EntityRelationship$outboundSchema).optional(),
    status: stringType().default("CURRENT"),
    additionalFields: arrayType(AdditionalFieldDefinition$outboundSchema).optional()
  });
  var EmployeeInfoDefinition$;
  (function(EmployeeInfoDefinition$2) {
    EmployeeInfoDefinition$2.inboundSchema = EmployeeInfoDefinition$inboundSchema;
    EmployeeInfoDefinition$2.outboundSchema = EmployeeInfoDefinition$outboundSchema;
  })(EmployeeInfoDefinition$ || (EmployeeInfoDefinition$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/bulkindexemployeesrequest.js
  var BulkIndexEmployeesRequest$inboundSchema = objectType({
    uploadId: stringType(),
    isFirstPage: booleanType().optional(),
    isLastPage: booleanType().optional(),
    forceRestartUpload: booleanType().optional(),
    employees: arrayType(EmployeeInfoDefinition$inboundSchema),
    disableStaleDataDeletionCheck: booleanType().optional()
  });
  var BulkIndexEmployeesRequest$outboundSchema = objectType({
    uploadId: stringType(),
    isFirstPage: booleanType().optional(),
    isLastPage: booleanType().optional(),
    forceRestartUpload: booleanType().optional(),
    employees: arrayType(EmployeeInfoDefinition$outboundSchema),
    disableStaleDataDeletionCheck: booleanType().optional()
  });
  var BulkIndexEmployeesRequest$;
  (function(BulkIndexEmployeesRequest$2) {
    BulkIndexEmployeesRequest$2.inboundSchema = BulkIndexEmployeesRequest$inboundSchema;
    BulkIndexEmployeesRequest$2.outboundSchema = BulkIndexEmployeesRequest$outboundSchema;
  })(BulkIndexEmployeesRequest$ || (BulkIndexEmployeesRequest$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/datasourcegroupdefinition.js
  var DatasourceGroupDefinition$inboundSchema = objectType({
    name: stringType()
  });
  var DatasourceGroupDefinition$outboundSchema = objectType({
    name: stringType()
  });
  var DatasourceGroupDefinition$;
  (function(DatasourceGroupDefinition$2) {
    DatasourceGroupDefinition$2.inboundSchema = DatasourceGroupDefinition$inboundSchema;
    DatasourceGroupDefinition$2.outboundSchema = DatasourceGroupDefinition$outboundSchema;
  })(DatasourceGroupDefinition$ || (DatasourceGroupDefinition$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/bulkindexgroupsrequest.js
  var BulkIndexGroupsRequest$inboundSchema = objectType({
    uploadId: stringType(),
    isFirstPage: booleanType().optional(),
    isLastPage: booleanType().optional(),
    forceRestartUpload: booleanType().optional(),
    datasource: stringType(),
    groups: arrayType(DatasourceGroupDefinition$inboundSchema),
    disableStaleDataDeletionCheck: booleanType().optional()
  });
  var BulkIndexGroupsRequest$outboundSchema = objectType({
    uploadId: stringType(),
    isFirstPage: booleanType().optional(),
    isLastPage: booleanType().optional(),
    forceRestartUpload: booleanType().optional(),
    datasource: stringType(),
    groups: arrayType(DatasourceGroupDefinition$outboundSchema),
    disableStaleDataDeletionCheck: booleanType().optional()
  });
  var BulkIndexGroupsRequest$;
  (function(BulkIndexGroupsRequest$2) {
    BulkIndexGroupsRequest$2.inboundSchema = BulkIndexGroupsRequest$inboundSchema;
    BulkIndexGroupsRequest$2.outboundSchema = BulkIndexGroupsRequest$outboundSchema;
  })(BulkIndexGroupsRequest$ || (BulkIndexGroupsRequest$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/datasourcebulkmembershipdefinition.js
  var DatasourceBulkMembershipDefinition$inboundSchema = objectType({
    memberUserId: stringType().optional(),
    memberGroupName: stringType().optional()
  });
  var DatasourceBulkMembershipDefinition$outboundSchema = objectType({
    memberUserId: stringType().optional(),
    memberGroupName: stringType().optional()
  });
  var DatasourceBulkMembershipDefinition$;
  (function(DatasourceBulkMembershipDefinition$2) {
    DatasourceBulkMembershipDefinition$2.inboundSchema = DatasourceBulkMembershipDefinition$inboundSchema;
    DatasourceBulkMembershipDefinition$2.outboundSchema = DatasourceBulkMembershipDefinition$outboundSchema;
  })(DatasourceBulkMembershipDefinition$ || (DatasourceBulkMembershipDefinition$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/bulkindexmembershipsrequest.js
  var BulkIndexMembershipsRequest$inboundSchema = objectType({
    uploadId: stringType(),
    isFirstPage: booleanType().optional(),
    isLastPage: booleanType().optional(),
    forceRestartUpload: booleanType().optional(),
    datasource: stringType(),
    group: stringType().optional(),
    memberships: arrayType(DatasourceBulkMembershipDefinition$inboundSchema)
  });
  var BulkIndexMembershipsRequest$outboundSchema = objectType({
    uploadId: stringType(),
    isFirstPage: booleanType().optional(),
    isLastPage: booleanType().optional(),
    forceRestartUpload: booleanType().optional(),
    datasource: stringType(),
    group: stringType().optional(),
    memberships: arrayType(DatasourceBulkMembershipDefinition$outboundSchema)
  });
  var BulkIndexMembershipsRequest$;
  (function(BulkIndexMembershipsRequest$2) {
    BulkIndexMembershipsRequest$2.inboundSchema = BulkIndexMembershipsRequest$inboundSchema;
    BulkIndexMembershipsRequest$2.outboundSchema = BulkIndexMembershipsRequest$outboundSchema;
  })(BulkIndexMembershipsRequest$ || (BulkIndexMembershipsRequest$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/externalshortcut.js
  var ExternalShortcut$inboundSchema = objectType({
    inputAlias: stringType(),
    description: stringType().optional(),
    destinationUrl: stringType(),
    createdBy: stringType(),
    createTime: numberType().int().optional(),
    updatedBy: stringType().optional(),
    updateTime: numberType().int().optional(),
    title: stringType().optional(),
    intermediateUrl: stringType(),
    decayedVisitScore: numberType().optional(),
    editUrl: stringType().optional()
  });
  var ExternalShortcut$outboundSchema = objectType({
    inputAlias: stringType(),
    description: stringType().optional(),
    destinationUrl: stringType(),
    createdBy: stringType(),
    createTime: numberType().int().optional(),
    updatedBy: stringType().optional(),
    updateTime: numberType().int().optional(),
    title: stringType().optional(),
    intermediateUrl: stringType(),
    decayedVisitScore: numberType().optional(),
    editUrl: stringType().optional()
  });
  var ExternalShortcut$;
  (function(ExternalShortcut$2) {
    ExternalShortcut$2.inboundSchema = ExternalShortcut$inboundSchema;
    ExternalShortcut$2.outboundSchema = ExternalShortcut$outboundSchema;
  })(ExternalShortcut$ || (ExternalShortcut$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/bulkindexshortcutsrequest.js
  var BulkIndexShortcutsRequest$inboundSchema = objectType({
    uploadId: stringType(),
    isFirstPage: booleanType().optional(),
    isLastPage: booleanType().optional(),
    forceRestartUpload: booleanType().optional(),
    shortcuts: arrayType(ExternalShortcut$inboundSchema)
  });
  var BulkIndexShortcutsRequest$outboundSchema = objectType({
    uploadId: stringType(),
    isFirstPage: booleanType().optional(),
    isLastPage: booleanType().optional(),
    forceRestartUpload: booleanType().optional(),
    shortcuts: arrayType(ExternalShortcut$outboundSchema)
  });
  var BulkIndexShortcutsRequest$;
  (function(BulkIndexShortcutsRequest$2) {
    BulkIndexShortcutsRequest$2.inboundSchema = BulkIndexShortcutsRequest$inboundSchema;
    BulkIndexShortcutsRequest$2.outboundSchema = BulkIndexShortcutsRequest$outboundSchema;
  })(BulkIndexShortcutsRequest$ || (BulkIndexShortcutsRequest$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/teammember.js
  var TeamMember$inboundSchema = objectType({
    email: stringType(),
    relationship: stringType().default("MEMBER"),
    join_date: stringType().transform((v) => new RFCDate(v)).optional()
  }).transform((v) => {
    return remap(v, {
      "join_date": "joinDate"
    });
  });
  var TeamMember$outboundSchema = objectType({
    email: stringType(),
    relationship: stringType().default("MEMBER"),
    joinDate: instanceOfType(RFCDate).transform((v) => v.toString()).optional()
  }).transform((v) => {
    return remap(v, {
      joinDate: "join_date"
    });
  });
  var TeamMember$;
  (function(TeamMember$2) {
    TeamMember$2.inboundSchema = TeamMember$inboundSchema;
    TeamMember$2.outboundSchema = TeamMember$outboundSchema;
  })(TeamMember$ || (TeamMember$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/teaminfodefinition.js
  var TeamInfoDefinition$inboundSchema = objectType({
    id: stringType(),
    name: stringType(),
    description: stringType().optional(),
    businessUnit: stringType().optional(),
    department: stringType().optional(),
    photoUrl: stringType().optional(),
    externalLink: stringType().optional(),
    emails: arrayType(TeamEmail$inboundSchema).optional(),
    datasourceProfiles: arrayType(DatasourceProfile$inboundSchema).optional(),
    members: arrayType(TeamMember$inboundSchema),
    additionalFields: arrayType(AdditionalFieldDefinition$inboundSchema).optional()
  });
  var TeamInfoDefinition$outboundSchema = objectType({
    id: stringType(),
    name: stringType(),
    description: stringType().optional(),
    businessUnit: stringType().optional(),
    department: stringType().optional(),
    photoUrl: stringType().optional(),
    externalLink: stringType().optional(),
    emails: arrayType(TeamEmail$outboundSchema).optional(),
    datasourceProfiles: arrayType(DatasourceProfile$outboundSchema).optional(),
    members: arrayType(TeamMember$outboundSchema),
    additionalFields: arrayType(AdditionalFieldDefinition$outboundSchema).optional()
  });
  var TeamInfoDefinition$;
  (function(TeamInfoDefinition$2) {
    TeamInfoDefinition$2.inboundSchema = TeamInfoDefinition$inboundSchema;
    TeamInfoDefinition$2.outboundSchema = TeamInfoDefinition$outboundSchema;
  })(TeamInfoDefinition$ || (TeamInfoDefinition$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/bulkindexteamsrequest.js
  var BulkIndexTeamsRequest$inboundSchema = objectType({
    uploadId: stringType(),
    isFirstPage: booleanType().optional(),
    isLastPage: booleanType().optional(),
    forceRestartUpload: booleanType().optional(),
    teams: arrayType(TeamInfoDefinition$inboundSchema)
  });
  var BulkIndexTeamsRequest$outboundSchema = objectType({
    uploadId: stringType(),
    isFirstPage: booleanType().optional(),
    isLastPage: booleanType().optional(),
    forceRestartUpload: booleanType().optional(),
    teams: arrayType(TeamInfoDefinition$outboundSchema)
  });
  var BulkIndexTeamsRequest$;
  (function(BulkIndexTeamsRequest$2) {
    BulkIndexTeamsRequest$2.inboundSchema = BulkIndexTeamsRequest$inboundSchema;
    BulkIndexTeamsRequest$2.outboundSchema = BulkIndexTeamsRequest$outboundSchema;
  })(BulkIndexTeamsRequest$ || (BulkIndexTeamsRequest$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/datasourceuserdefinition.js
  var DatasourceUserDefinition$inboundSchema = objectType({
    email: stringType(),
    userId: stringType().optional(),
    name: stringType(),
    isActive: booleanType().optional()
  });
  var DatasourceUserDefinition$outboundSchema = objectType({
    email: stringType(),
    userId: stringType().optional(),
    name: stringType(),
    isActive: booleanType().optional()
  });
  var DatasourceUserDefinition$;
  (function(DatasourceUserDefinition$2) {
    DatasourceUserDefinition$2.inboundSchema = DatasourceUserDefinition$inboundSchema;
    DatasourceUserDefinition$2.outboundSchema = DatasourceUserDefinition$outboundSchema;
  })(DatasourceUserDefinition$ || (DatasourceUserDefinition$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/bulkindexusersrequest.js
  var BulkIndexUsersRequest$inboundSchema = objectType({
    uploadId: stringType(),
    isFirstPage: booleanType().optional(),
    isLastPage: booleanType().optional(),
    forceRestartUpload: booleanType().optional(),
    datasource: stringType(),
    users: arrayType(DatasourceUserDefinition$inboundSchema),
    disableStaleDataDeletionCheck: booleanType().optional()
  });
  var BulkIndexUsersRequest$outboundSchema = objectType({
    uploadId: stringType(),
    isFirstPage: booleanType().optional(),
    isLastPage: booleanType().optional(),
    forceRestartUpload: booleanType().optional(),
    datasource: stringType(),
    users: arrayType(DatasourceUserDefinition$outboundSchema),
    disableStaleDataDeletionCheck: booleanType().optional()
  });
  var BulkIndexUsersRequest$;
  (function(BulkIndexUsersRequest$2) {
    BulkIndexUsersRequest$2.inboundSchema = BulkIndexUsersRequest$inboundSchema;
    BulkIndexUsersRequest$2.outboundSchema = BulkIndexUsersRequest$outboundSchema;
  })(BulkIndexUsersRequest$ || (BulkIndexUsersRequest$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/bulkuploadhistoryevent.js
  var BulkUploadHistoryEventStatus = {
    Active: "ACTIVE",
    Successful: "SUCCESSFUL"
  };
  var ProcessingState = {
    Unavailable: "UNAVAILABLE",
    UploadStarted: "UPLOAD STARTED",
    UploadInProgress: "UPLOAD IN PROGRESS",
    UploadCompleted: "UPLOAD COMPLETED",
    DeletionPaused: "DELETION PAUSED",
    IndexingCompleted: "INDEXING COMPLETED"
  };
  var BulkUploadHistoryEventStatus$inboundSchema = nativeEnumType(BulkUploadHistoryEventStatus);
  var BulkUploadHistoryEventStatus$outboundSchema = BulkUploadHistoryEventStatus$inboundSchema;
  var BulkUploadHistoryEventStatus$;
  (function(BulkUploadHistoryEventStatus$2) {
    BulkUploadHistoryEventStatus$2.inboundSchema = BulkUploadHistoryEventStatus$inboundSchema;
    BulkUploadHistoryEventStatus$2.outboundSchema = BulkUploadHistoryEventStatus$outboundSchema;
  })(BulkUploadHistoryEventStatus$ || (BulkUploadHistoryEventStatus$ = {}));
  var ProcessingState$inboundSchema = nativeEnumType(ProcessingState);
  var ProcessingState$outboundSchema = ProcessingState$inboundSchema;
  var ProcessingState$;
  (function(ProcessingState$2) {
    ProcessingState$2.inboundSchema = ProcessingState$inboundSchema;
    ProcessingState$2.outboundSchema = ProcessingState$outboundSchema;
  })(ProcessingState$ || (ProcessingState$ = {}));
  var BulkUploadHistoryEvent$inboundSchema = objectType({
    uploadId: stringType().optional(),
    startTime: stringType().optional(),
    endTime: stringType().optional(),
    status: BulkUploadHistoryEventStatus$inboundSchema.optional(),
    processingState: ProcessingState$inboundSchema.optional()
  });
  var BulkUploadHistoryEvent$outboundSchema = objectType({
    uploadId: stringType().optional(),
    startTime: stringType().optional(),
    endTime: stringType().optional(),
    status: BulkUploadHistoryEventStatus$outboundSchema.optional(),
    processingState: ProcessingState$outboundSchema.optional()
  });
  var BulkUploadHistoryEvent$;
  (function(BulkUploadHistoryEvent$2) {
    BulkUploadHistoryEvent$2.inboundSchema = BulkUploadHistoryEvent$inboundSchema;
    BulkUploadHistoryEvent$2.outboundSchema = BulkUploadHistoryEvent$outboundSchema;
  })(BulkUploadHistoryEvent$ || (BulkUploadHistoryEvent$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/conferencedata.js
  var Provider = {
    Zoom: "ZOOM",
    Hangouts: "HANGOUTS"
  };
  var ConferenceDataSource = {
    NativeConference: "NATIVE_CONFERENCE",
    Location: "LOCATION",
    Description: "DESCRIPTION"
  };
  var Provider$inboundSchema = nativeEnumType(Provider);
  var Provider$outboundSchema = Provider$inboundSchema;
  var Provider$;
  (function(Provider$2) {
    Provider$2.inboundSchema = Provider$inboundSchema;
    Provider$2.outboundSchema = Provider$outboundSchema;
  })(Provider$ || (Provider$ = {}));
  var ConferenceDataSource$inboundSchema = nativeEnumType(ConferenceDataSource);
  var ConferenceDataSource$outboundSchema = ConferenceDataSource$inboundSchema;
  var ConferenceDataSource$;
  (function(ConferenceDataSource$2) {
    ConferenceDataSource$2.inboundSchema = ConferenceDataSource$inboundSchema;
    ConferenceDataSource$2.outboundSchema = ConferenceDataSource$outboundSchema;
  })(ConferenceDataSource$ || (ConferenceDataSource$ = {}));
  var ConferenceData$inboundSchema = objectType({
    provider: Provider$inboundSchema,
    uri: stringType(),
    source: ConferenceDataSource$inboundSchema.optional()
  });
  var ConferenceData$outboundSchema = objectType({
    provider: Provider$outboundSchema,
    uri: stringType(),
    source: ConferenceDataSource$outboundSchema.optional()
  });
  var ConferenceData$;
  (function(ConferenceData$2) {
    ConferenceData$2.inboundSchema = ConferenceData$inboundSchema;
    ConferenceData$2.outboundSchema = ConferenceData$outboundSchema;
  })(ConferenceData$ || (ConferenceData$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/eventclassificationname.js
  var EventClassificationName = {
    ExternalEvent: "External Event"
  };
  var EventClassificationName$inboundSchema = nativeEnumType(EventClassificationName);
  var EventClassificationName$outboundSchema = EventClassificationName$inboundSchema;
  var EventClassificationName$;
  (function(EventClassificationName$2) {
    EventClassificationName$2.inboundSchema = EventClassificationName$inboundSchema;
    EventClassificationName$2.outboundSchema = EventClassificationName$outboundSchema;
  })(EventClassificationName$ || (EventClassificationName$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/eventstrategyname.js
  var EventStrategyName = {
    CustomerCard: "customerCard",
    News: "news",
    Call: "call",
    Email: "email",
    MeetingNotes: "meetingNotes",
    LinkedIn: "linkedIn",
    RelevantDocuments: "relevantDocuments",
    ChatFollowUps: "chatFollowUps",
    Conversations: "conversations"
  };
  var EventStrategyName$inboundSchema = nativeEnumType(EventStrategyName);
  var EventStrategyName$outboundSchema = EventStrategyName$inboundSchema;
  var EventStrategyName$;
  (function(EventStrategyName$2) {
    EventStrategyName$2.inboundSchema = EventStrategyName$inboundSchema;
    EventStrategyName$2.outboundSchema = EventStrategyName$outboundSchema;
  })(EventStrategyName$ || (EventStrategyName$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/eventclassification.js
  var EventClassification$inboundSchema = objectType({
    name: EventClassificationName$inboundSchema.optional(),
    strategies: arrayType(EventStrategyName$inboundSchema).optional()
  });
  var EventClassification$outboundSchema = objectType({
    name: EventClassificationName$outboundSchema.optional(),
    strategies: arrayType(EventStrategyName$outboundSchema).optional()
  });
  var EventClassification$;
  (function(EventClassification$2) {
    EventClassification$2.inboundSchema = EventClassification$inboundSchema;
    EventClassification$2.outboundSchema = EventClassification$outboundSchema;
  })(EventClassification$ || (EventClassification$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/generatedattachmentcontent.js
  var GeneratedAttachmentContent$inboundSchema = objectType({
    displayHeader: stringType().optional(),
    text: stringType().optional()
  });
  var GeneratedAttachmentContent$outboundSchema = objectType({
    displayHeader: stringType().optional(),
    text: stringType().optional()
  });
  var GeneratedAttachmentContent$;
  (function(GeneratedAttachmentContent$2) {
    GeneratedAttachmentContent$2.inboundSchema = GeneratedAttachmentContent$inboundSchema;
    GeneratedAttachmentContent$2.outboundSchema = GeneratedAttachmentContent$outboundSchema;
  })(GeneratedAttachmentContent$ || (GeneratedAttachmentContent$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/structuredlink.js
  var StructuredLink$inboundSchema = objectType({
    name: stringType().optional(),
    url: stringType().optional(),
    iconConfig: IconConfig$inboundSchema.optional()
  });
  var StructuredLink$outboundSchema = objectType({
    name: stringType().optional(),
    url: stringType().optional(),
    iconConfig: IconConfig$outboundSchema.optional()
  });
  var StructuredLink$;
  (function(StructuredLink$2) {
    StructuredLink$2.inboundSchema = StructuredLink$inboundSchema;
    StructuredLink$2.outboundSchema = StructuredLink$outboundSchema;
  })(StructuredLink$ || (StructuredLink$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/generatedattachment.js
  var GeneratedAttachment$inboundSchema = objectType({
    strategyName: EventStrategyName$inboundSchema.optional(),
    documents: arrayType(Document$inboundSchema).optional(),
    person: Person$inboundSchema.optional(),
    customer: Customer$inboundSchema.optional(),
    externalLinks: arrayType(StructuredLink$inboundSchema).optional(),
    content: arrayType(GeneratedAttachmentContent$inboundSchema).optional()
  });
  var GeneratedAttachment$outboundSchema = objectType({
    strategyName: EventStrategyName$outboundSchema.optional(),
    documents: arrayType(Document$outboundSchema).optional(),
    person: Person$outboundSchema.optional(),
    customer: Customer$outboundSchema.optional(),
    externalLinks: arrayType(StructuredLink$outboundSchema).optional(),
    content: arrayType(GeneratedAttachmentContent$outboundSchema).optional()
  });
  var GeneratedAttachment$;
  (function(GeneratedAttachment$2) {
    GeneratedAttachment$2.inboundSchema = GeneratedAttachment$inboundSchema;
    GeneratedAttachment$2.outboundSchema = GeneratedAttachment$outboundSchema;
  })(GeneratedAttachment$ || (GeneratedAttachment$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/calendarevent.js
  var CalendarEventEventType = {
    Default: "DEFAULT",
    OutOfOffice: "OUT_OF_OFFICE"
  };
  var CalendarEventEventType$inboundSchema = nativeEnumType(CalendarEventEventType);
  var CalendarEventEventType$outboundSchema = CalendarEventEventType$inboundSchema;
  var CalendarEventEventType$;
  (function(CalendarEventEventType$2) {
    CalendarEventEventType$2.inboundSchema = CalendarEventEventType$inboundSchema;
    CalendarEventEventType$2.outboundSchema = CalendarEventEventType$outboundSchema;
  })(CalendarEventEventType$ || (CalendarEventEventType$ = {}));
  var CalendarEvent$inboundSchema = objectType({
    time: TimeInterval$inboundSchema.optional(),
    eventType: CalendarEventEventType$inboundSchema.optional(),
    id: stringType(),
    url: stringType(),
    attendees: CalendarAttendees$inboundSchema.optional(),
    location: stringType().optional(),
    conferenceData: ConferenceData$inboundSchema.optional(),
    description: stringType().optional(),
    datasource: stringType().optional(),
    hasTranscript: booleanType().optional(),
    transcriptUrl: stringType().optional(),
    classifications: arrayType(EventClassification$inboundSchema).optional(),
    generatedAttachments: arrayType(GeneratedAttachment$inboundSchema).optional()
  });
  var CalendarEvent$outboundSchema = objectType({
    time: TimeInterval$outboundSchema.optional(),
    eventType: CalendarEventEventType$outboundSchema.optional(),
    id: stringType(),
    url: stringType(),
    attendees: CalendarAttendees$outboundSchema.optional(),
    location: stringType().optional(),
    conferenceData: ConferenceData$outboundSchema.optional(),
    description: stringType().optional(),
    datasource: stringType().optional(),
    hasTranscript: booleanType().optional(),
    transcriptUrl: stringType().optional(),
    classifications: arrayType(EventClassification$outboundSchema).optional(),
    generatedAttachments: arrayType(GeneratedAttachment$outboundSchema).optional()
  });
  var CalendarEvent$;
  (function(CalendarEvent$2) {
    CalendarEvent$2.inboundSchema = CalendarEvent$inboundSchema;
    CalendarEvent$2.outboundSchema = CalendarEvent$outboundSchema;
  })(CalendarEvent$ || (CalendarEvent$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/canonicalizingregextype.js
  var CanonicalizingRegexType$inboundSchema = objectType({
    matchRegex: stringType().optional(),
    rewriteRegex: stringType().optional()
  });
  var CanonicalizingRegexType$outboundSchema = objectType({
    matchRegex: stringType().optional(),
    rewriteRegex: stringType().optional()
  });
  var CanonicalizingRegexType$;
  (function(CanonicalizingRegexType$2) {
    CanonicalizingRegexType$2.inboundSchema = CanonicalizingRegexType$inboundSchema;
    CanonicalizingRegexType$2.outboundSchema = CanonicalizingRegexType$outboundSchema;
  })(CanonicalizingRegexType$ || (CanonicalizingRegexType$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/chatfilefailurereason.js
  var ChatFileFailureReason = {
    ParseFailed: "PARSE_FAILED",
    AvScanFailed: "AV_SCAN_FAILED",
    FileTooSmall: "FILE_TOO_SMALL",
    FileTooLarge: "FILE_TOO_LARGE",
    FileExtensionUnsupported: "FILE_EXTENSION_UNSUPPORTED",
    FileMetadataValidationFail: "FILE_METADATA_VALIDATION_FAIL",
    FileProcessingTimedOut: "FILE_PROCESSING_TIMED_OUT"
  };
  var ChatFileFailureReason$inboundSchema = nativeEnumType(ChatFileFailureReason);
  var ChatFileFailureReason$outboundSchema = ChatFileFailureReason$inboundSchema;
  var ChatFileFailureReason$;
  (function(ChatFileFailureReason$2) {
    ChatFileFailureReason$2.inboundSchema = ChatFileFailureReason$inboundSchema;
    ChatFileFailureReason$2.outboundSchema = ChatFileFailureReason$outboundSchema;
  })(ChatFileFailureReason$ || (ChatFileFailureReason$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/chatfilestatus.js
  var ChatFileStatus = {
    Processing: "PROCESSING",
    Processed: "PROCESSED",
    Failed: "FAILED",
    Deleted: "DELETED"
  };
  var ChatFileStatus$inboundSchema = nativeEnumType(ChatFileStatus);
  var ChatFileStatus$outboundSchema = ChatFileStatus$inboundSchema;
  var ChatFileStatus$;
  (function(ChatFileStatus$2) {
    ChatFileStatus$2.inboundSchema = ChatFileStatus$inboundSchema;
    ChatFileStatus$2.outboundSchema = ChatFileStatus$outboundSchema;
  })(ChatFileStatus$ || (ChatFileStatus$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/chatfilemetadata.js
  var ChatFileMetadata$inboundSchema = objectType({
    status: ChatFileStatus$inboundSchema.optional(),
    uploadTime: numberType().int().optional(),
    processedSize: numberType().int().optional(),
    failureReason: ChatFileFailureReason$inboundSchema.optional(),
    mimeType: stringType().optional()
  });
  var ChatFileMetadata$outboundSchema = objectType({
    status: ChatFileStatus$outboundSchema.optional(),
    uploadTime: numberType().int().optional(),
    processedSize: numberType().int().optional(),
    failureReason: ChatFileFailureReason$outboundSchema.optional(),
    mimeType: stringType().optional()
  });
  var ChatFileMetadata$;
  (function(ChatFileMetadata$2) {
    ChatFileMetadata$2.inboundSchema = ChatFileMetadata$inboundSchema;
    ChatFileMetadata$2.outboundSchema = ChatFileMetadata$outboundSchema;
  })(ChatFileMetadata$ || (ChatFileMetadata$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/chatfile.js
  var ChatFile$inboundSchema = objectType({
    id: stringType().optional(),
    url: stringType().optional(),
    name: stringType().optional(),
    metadata: ChatFileMetadata$inboundSchema.optional()
  });
  var ChatFile$outboundSchema = objectType({
    id: stringType().optional(),
    url: stringType().optional(),
    name: stringType().optional(),
    metadata: ChatFileMetadata$outboundSchema.optional()
  });
  var ChatFile$;
  (function(ChatFile$2) {
    ChatFile$2.inboundSchema = ChatFile$inboundSchema;
    ChatFile$2.outboundSchema = ChatFile$outboundSchema;
  })(ChatFile$ || (ChatFile$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/referencerange.js
  var ReferenceRange$inboundSchema = objectType({
    textRange: TextRange$inboundSchema.optional(),
    snippets: arrayType(SearchResultSnippet$inboundSchema).optional()
  });
  var ReferenceRange$outboundSchema = objectType({
    textRange: TextRange$outboundSchema.optional(),
    snippets: arrayType(SearchResultSnippet$outboundSchema).optional()
  });
  var ReferenceRange$;
  (function(ReferenceRange$2) {
    ReferenceRange$2.inboundSchema = ReferenceRange$inboundSchema;
    ReferenceRange$2.outboundSchema = ReferenceRange$outboundSchema;
  })(ReferenceRange$ || (ReferenceRange$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/chatmessagecitation.js
  var ChatMessageCitation$inboundSchema = objectType({
    trackingToken: stringType().optional(),
    sourceDocument: Document$inboundSchema.optional(),
    sourceFile: ChatFile$inboundSchema.optional(),
    sourcePerson: Person$inboundSchema.optional(),
    referenceRanges: arrayType(ReferenceRange$inboundSchema).optional()
  });
  var ChatMessageCitation$outboundSchema = objectType({
    trackingToken: stringType().optional(),
    sourceDocument: Document$outboundSchema.optional(),
    sourceFile: ChatFile$outboundSchema.optional(),
    sourcePerson: Person$outboundSchema.optional(),
    referenceRanges: arrayType(ReferenceRange$outboundSchema).optional()
  });
  var ChatMessageCitation$;
  (function(ChatMessageCitation$2) {
    ChatMessageCitation$2.inboundSchema = ChatMessageCitation$inboundSchema;
    ChatMessageCitation$2.outboundSchema = ChatMessageCitation$outboundSchema;
  })(ChatMessageCitation$ || (ChatMessageCitation$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/personobject.js
  var PersonObject$inboundSchema = objectType({
    name: stringType(),
    obfuscatedId: stringType()
  });
  var PersonObject$outboundSchema = objectType({
    name: stringType(),
    obfuscatedId: stringType()
  });
  var PersonObject$;
  (function(PersonObject$2) {
    PersonObject$2.inboundSchema = PersonObject$inboundSchema;
    PersonObject$2.outboundSchema = PersonObject$outboundSchema;
  })(PersonObject$ || (PersonObject$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/toolmetadata.js
  var ToolMetadataType = {
    Retrieval: "RETRIEVAL",
    Action: "ACTION"
  };
  var KnowledgeType = {
    NeutralKnowledge: "NEUTRAL_KNOWLEDGE",
    CompanyKnowledge: "COMPANY_KNOWLEDGE",
    WorldKnowledge: "WORLD_KNOWLEDGE"
  };
  var WriteActionType = {
    Redirect: "REDIRECT",
    Execution: "EXECUTION"
  };
  var AuthType = {
    None: "NONE",
    OauthUser: "OAUTH_USER",
    OauthAdmin: "OAUTH_ADMIN",
    ApiKey: "API_KEY",
    BasicAuth: "BASIC_AUTH",
    Dwd: "DWD"
  };
  var ToolMetadataType$inboundSchema = nativeEnumType(ToolMetadataType);
  var ToolMetadataType$outboundSchema = ToolMetadataType$inboundSchema;
  var ToolMetadataType$;
  (function(ToolMetadataType$2) {
    ToolMetadataType$2.inboundSchema = ToolMetadataType$inboundSchema;
    ToolMetadataType$2.outboundSchema = ToolMetadataType$outboundSchema;
  })(ToolMetadataType$ || (ToolMetadataType$ = {}));
  var KnowledgeType$inboundSchema = nativeEnumType(KnowledgeType);
  var KnowledgeType$outboundSchema = KnowledgeType$inboundSchema;
  var KnowledgeType$;
  (function(KnowledgeType$2) {
    KnowledgeType$2.inboundSchema = KnowledgeType$inboundSchema;
    KnowledgeType$2.outboundSchema = KnowledgeType$outboundSchema;
  })(KnowledgeType$ || (KnowledgeType$ = {}));
  var WriteActionType$inboundSchema = nativeEnumType(WriteActionType);
  var WriteActionType$outboundSchema = WriteActionType$inboundSchema;
  var WriteActionType$;
  (function(WriteActionType$2) {
    WriteActionType$2.inboundSchema = WriteActionType$inboundSchema;
    WriteActionType$2.outboundSchema = WriteActionType$outboundSchema;
  })(WriteActionType$ || (WriteActionType$ = {}));
  var AuthType$inboundSchema = nativeEnumType(AuthType);
  var AuthType$outboundSchema = AuthType$inboundSchema;
  var AuthType$;
  (function(AuthType$2) {
    AuthType$2.inboundSchema = AuthType$inboundSchema;
    AuthType$2.outboundSchema = AuthType$outboundSchema;
  })(AuthType$ || (AuthType$ = {}));
  var ToolMetadata$inboundSchema = objectType({
    type: ToolMetadataType$inboundSchema,
    name: stringType(),
    displayName: stringType(),
    toolId: stringType().optional(),
    displayDescription: stringType(),
    logoUrl: stringType().optional(),
    objectName: stringType().optional(),
    knowledgeType: KnowledgeType$inboundSchema.optional(),
    createdBy: PersonObject$inboundSchema.optional(),
    lastUpdatedBy: PersonObject$inboundSchema.optional(),
    createdAt: stringType().datetime({ offset: true }).transform((v) => new Date(v)).optional(),
    lastUpdatedAt: stringType().datetime({ offset: true }).transform((v) => new Date(v)).optional(),
    writeActionType: WriteActionType$inboundSchema.optional(),
    authType: AuthType$inboundSchema.optional(),
    auth: AuthConfig$inboundSchema.optional(),
    permissions: ObjectPermissions$inboundSchema.optional(),
    usageInstructions: stringType().optional(),
    isSetupFinished: booleanType().optional()
  });
  var ToolMetadata$outboundSchema = objectType({
    type: ToolMetadataType$outboundSchema,
    name: stringType(),
    displayName: stringType(),
    toolId: stringType().optional(),
    displayDescription: stringType(),
    logoUrl: stringType().optional(),
    objectName: stringType().optional(),
    knowledgeType: KnowledgeType$outboundSchema.optional(),
    createdBy: PersonObject$outboundSchema.optional(),
    lastUpdatedBy: PersonObject$outboundSchema.optional(),
    createdAt: dateType().transform((v) => v.toISOString()).optional(),
    lastUpdatedAt: dateType().transform((v) => v.toISOString()).optional(),
    writeActionType: WriteActionType$outboundSchema.optional(),
    authType: AuthType$outboundSchema.optional(),
    auth: AuthConfig$outboundSchema.optional(),
    permissions: ObjectPermissions$outboundSchema.optional(),
    usageInstructions: stringType().optional(),
    isSetupFinished: booleanType().optional()
  });
  var ToolMetadata$;
  (function(ToolMetadata$2) {
    ToolMetadata$2.inboundSchema = ToolMetadata$inboundSchema;
    ToolMetadata$2.outboundSchema = ToolMetadata$outboundSchema;
  })(ToolMetadata$ || (ToolMetadata$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/possiblevalue.js
  var PossibleValue$inboundSchema = objectType({
    value: stringType().optional(),
    label: stringType().optional()
  });
  var PossibleValue$outboundSchema = objectType({
    value: stringType().optional(),
    label: stringType().optional()
  });
  var PossibleValue$;
  (function(PossibleValue$2) {
    PossibleValue$2.inboundSchema = PossibleValue$inboundSchema;
    PossibleValue$2.outboundSchema = PossibleValue$outboundSchema;
  })(PossibleValue$ || (PossibleValue$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/writeactionparameter.js
  var WriteActionParameterType = {
    Unknown: "UNKNOWN",
    Integer: "INTEGER",
    String: "STRING",
    Boolean: "BOOLEAN"
  };
  var WriteActionParameterType$inboundSchema = nativeEnumType(WriteActionParameterType);
  var WriteActionParameterType$outboundSchema = WriteActionParameterType$inboundSchema;
  var WriteActionParameterType$;
  (function(WriteActionParameterType$2) {
    WriteActionParameterType$2.inboundSchema = WriteActionParameterType$inboundSchema;
    WriteActionParameterType$2.outboundSchema = WriteActionParameterType$outboundSchema;
  })(WriteActionParameterType$ || (WriteActionParameterType$ = {}));
  var WriteActionParameter$inboundSchema = objectType({
    type: WriteActionParameterType$inboundSchema.optional(),
    displayName: stringType().optional(),
    value: stringType().optional(),
    isRequired: booleanType().optional(),
    description: stringType().optional(),
    possibleValues: arrayType(PossibleValue$inboundSchema).optional()
  });
  var WriteActionParameter$outboundSchema = objectType({
    type: WriteActionParameterType$outboundSchema.optional(),
    displayName: stringType().optional(),
    value: stringType().optional(),
    isRequired: booleanType().optional(),
    description: stringType().optional(),
    possibleValues: arrayType(PossibleValue$outboundSchema).optional()
  });
  var WriteActionParameter$;
  (function(WriteActionParameter$2) {
    WriteActionParameter$2.inboundSchema = WriteActionParameter$inboundSchema;
    WriteActionParameter$2.outboundSchema = WriteActionParameter$outboundSchema;
  })(WriteActionParameter$ || (WriteActionParameter$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/toolinfo.js
  var ToolInfo$inboundSchema = objectType({
    metadata: ToolMetadata$inboundSchema.optional(),
    parameters: recordType(WriteActionParameter$inboundSchema).optional()
  });
  var ToolInfo$outboundSchema = objectType({
    metadata: ToolMetadata$outboundSchema.optional(),
    parameters: recordType(WriteActionParameter$outboundSchema).optional()
  });
  var ToolInfo$;
  (function(ToolInfo$2) {
    ToolInfo$2.inboundSchema = ToolInfo$inboundSchema;
    ToolInfo$2.outboundSchema = ToolInfo$outboundSchema;
  })(ToolInfo$ || (ToolInfo$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/chatmessagefragment.js
  var ChatMessageFragment$inboundSchema = objectType({
    structuredResults: arrayType(StructuredResult$inboundSchema).optional(),
    trackingToken: stringType().optional(),
    text: stringType().optional(),
    querySuggestion: QuerySuggestion$inboundSchema.optional(),
    file: ChatFile$inboundSchema.optional(),
    action: ToolInfo$inboundSchema.optional(),
    citation: ChatMessageCitation$inboundSchema.optional()
  });
  var ChatMessageFragment$outboundSchema = objectType({
    structuredResults: arrayType(StructuredResult$outboundSchema).optional(),
    trackingToken: stringType().optional(),
    text: stringType().optional(),
    querySuggestion: QuerySuggestion$outboundSchema.optional(),
    file: ChatFile$outboundSchema.optional(),
    action: ToolInfo$outboundSchema.optional(),
    citation: ChatMessageCitation$outboundSchema.optional()
  });
  var ChatMessageFragment$;
  (function(ChatMessageFragment$2) {
    ChatMessageFragment$2.inboundSchema = ChatMessageFragment$inboundSchema;
    ChatMessageFragment$2.outboundSchema = ChatMessageFragment$outboundSchema;
  })(ChatMessageFragment$ || (ChatMessageFragment$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/chatmessage.js
  var Author = {
    User: "USER",
    GleanAi: "GLEAN_AI"
  };
  var MessageType = {
    Update: "UPDATE",
    Content: "CONTENT",
    Context: "CONTEXT",
    Debug: "DEBUG",
    DebugExternal: "DEBUG_EXTERNAL",
    Error: "ERROR",
    Heading: "HEADING",
    Warning: "WARNING",
    ServerTool: "SERVER_TOOL"
  };
  var Author$inboundSchema = nativeEnumType(Author);
  var Author$outboundSchema = Author$inboundSchema;
  var Author$;
  (function(Author$2) {
    Author$2.inboundSchema = Author$inboundSchema;
    Author$2.outboundSchema = Author$outboundSchema;
  })(Author$ || (Author$ = {}));
  var MessageType$inboundSchema = nativeEnumType(MessageType);
  var MessageType$outboundSchema = MessageType$inboundSchema;
  var MessageType$;
  (function(MessageType$2) {
    MessageType$2.inboundSchema = MessageType$inboundSchema;
    MessageType$2.outboundSchema = MessageType$outboundSchema;
  })(MessageType$ || (MessageType$ = {}));
  var ChatMessage$inboundSchema = objectType({
    agentConfig: AgentConfig$inboundSchema.optional(),
    author: Author$inboundSchema.default("USER"),
    citations: arrayType(ChatMessageCitation$inboundSchema).optional(),
    uploadedFileIds: arrayType(stringType()).optional(),
    fragments: arrayType(ChatMessageFragment$inboundSchema).optional(),
    ts: stringType().optional(),
    messageId: stringType().optional(),
    messageTrackingToken: stringType().optional(),
    messageType: MessageType$inboundSchema.default("CONTENT"),
    hasMoreFragments: booleanType().optional()
  });
  var ChatMessage$outboundSchema = objectType({
    agentConfig: AgentConfig$outboundSchema.optional(),
    author: Author$outboundSchema.default("USER"),
    citations: arrayType(ChatMessageCitation$outboundSchema).optional(),
    uploadedFileIds: arrayType(stringType()).optional(),
    fragments: arrayType(ChatMessageFragment$outboundSchema).optional(),
    ts: stringType().optional(),
    messageId: stringType().optional(),
    messageTrackingToken: stringType().optional(),
    messageType: MessageType$outboundSchema.default("CONTENT"),
    hasMoreFragments: booleanType().optional()
  });
  var ChatMessage$;
  (function(ChatMessage$2) {
    ChatMessage$2.inboundSchema = ChatMessage$inboundSchema;
    ChatMessage$2.outboundSchema = ChatMessage$outboundSchema;
  })(ChatMessage$ || (ChatMessage$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/chat.js
  var Chat$inboundSchema = objectType({
    id: stringType().optional(),
    createTime: numberType().int().optional(),
    createdBy: Person$inboundSchema.optional(),
    updateTime: numberType().int().optional(),
    name: stringType().optional(),
    applicationId: stringType().optional(),
    applicationName: stringType().optional(),
    icon: IconConfig$inboundSchema.optional(),
    permissions: ObjectPermissions$inboundSchema.optional(),
    messages: arrayType(ChatMessage$inboundSchema).optional(),
    roles: arrayType(UserRoleSpecification$inboundSchema).optional()
  });
  var Chat$outboundSchema = objectType({
    id: stringType().optional(),
    createTime: numberType().int().optional(),
    createdBy: Person$outboundSchema.optional(),
    updateTime: numberType().int().optional(),
    name: stringType().optional(),
    applicationId: stringType().optional(),
    applicationName: stringType().optional(),
    icon: IconConfig$outboundSchema.optional(),
    permissions: ObjectPermissions$outboundSchema.optional(),
    messages: arrayType(ChatMessage$outboundSchema).optional(),
    roles: arrayType(UserRoleSpecification$outboundSchema).optional()
  });
  var Chat$;
  (function(Chat$2) {
    Chat$2.inboundSchema = Chat$inboundSchema;
    Chat$2.outboundSchema = Chat$outboundSchema;
  })(Chat$ || (Chat$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/chatmetadata.js
  var ChatMetadata$inboundSchema = objectType({
    id: stringType().optional(),
    createTime: numberType().int().optional(),
    createdBy: Person$inboundSchema.optional(),
    updateTime: numberType().int().optional(),
    name: stringType().optional(),
    applicationId: stringType().optional(),
    applicationName: stringType().optional(),
    icon: IconConfig$inboundSchema.optional()
  });
  var ChatMetadata$outboundSchema = objectType({
    id: stringType().optional(),
    createTime: numberType().int().optional(),
    createdBy: Person$outboundSchema.optional(),
    updateTime: numberType().int().optional(),
    name: stringType().optional(),
    applicationId: stringType().optional(),
    applicationName: stringType().optional(),
    icon: IconConfig$outboundSchema.optional()
  });
  var ChatMetadata$;
  (function(ChatMetadata$2) {
    ChatMetadata$2.inboundSchema = ChatMetadata$inboundSchema;
    ChatMetadata$2.outboundSchema = ChatMetadata$outboundSchema;
  })(ChatMetadata$ || (ChatMetadata$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/chatmetadataresult.js
  var ChatMetadataResult$inboundSchema = objectType({
    chat: ChatMetadata$inboundSchema.optional(),
    trackingToken: stringType().optional()
  });
  var ChatMetadataResult$outboundSchema = objectType({
    chat: ChatMetadata$outboundSchema.optional(),
    trackingToken: stringType().optional()
  });
  var ChatMetadataResult$;
  (function(ChatMetadataResult$2) {
    ChatMetadataResult$2.inboundSchema = ChatMetadataResult$inboundSchema;
    ChatMetadataResult$2.outboundSchema = ChatMetadataResult$outboundSchema;
  })(ChatMetadataResult$ || (ChatMetadataResult$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/chatrestrictionfilters.js
  var ChatRestrictionFilters$inboundSchema = objectType({
    containerSpecs: arrayType(DocumentSpecUnion$inboundSchema).optional(),
    documentSpecs: arrayType(DocumentSpecUnion$inboundSchema).optional(),
    datasourceInstances: arrayType(stringType()).optional()
  });
  var ChatRestrictionFilters$outboundSchema = objectType({
    containerSpecs: arrayType(DocumentSpecUnion$outboundSchema).optional(),
    documentSpecs: arrayType(DocumentSpecUnion$outboundSchema).optional(),
    datasourceInstances: arrayType(stringType()).optional()
  });
  var ChatRestrictionFilters$;
  (function(ChatRestrictionFilters$2) {
    ChatRestrictionFilters$2.inboundSchema = ChatRestrictionFilters$inboundSchema;
    ChatRestrictionFilters$2.outboundSchema = ChatRestrictionFilters$outboundSchema;
  })(ChatRestrictionFilters$ || (ChatRestrictionFilters$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/chatrequest.js
  var ChatRequest$inboundSchema = objectType({
    saveChat: booleanType().optional(),
    chatId: stringType().optional(),
    messages: arrayType(ChatMessage$inboundSchema),
    agentConfig: AgentConfig$inboundSchema.optional(),
    inclusions: ChatRestrictionFilters$inboundSchema.optional(),
    exclusions: ChatRestrictionFilters$inboundSchema.optional(),
    timeoutMillis: numberType().int().optional(),
    sessionInfo: SessionInfo$inboundSchema.optional(),
    applicationId: stringType().optional(),
    agentId: stringType().optional(),
    stream: booleanType().optional()
  });
  var ChatRequest$outboundSchema = objectType({
    saveChat: booleanType().optional(),
    chatId: stringType().optional(),
    messages: arrayType(ChatMessage$outboundSchema),
    agentConfig: AgentConfig$outboundSchema.optional(),
    inclusions: ChatRestrictionFilters$outboundSchema.optional(),
    exclusions: ChatRestrictionFilters$outboundSchema.optional(),
    timeoutMillis: numberType().int().optional(),
    sessionInfo: SessionInfo$outboundSchema.optional(),
    applicationId: stringType().optional(),
    agentId: stringType().optional(),
    stream: booleanType().optional()
  });
  var ChatRequest$;
  (function(ChatRequest$3) {
    ChatRequest$3.inboundSchema = ChatRequest$inboundSchema;
    ChatRequest$3.outboundSchema = ChatRequest$outboundSchema;
  })(ChatRequest$ || (ChatRequest$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/chatresponse.js
  var ChatResponse$inboundSchema = objectType({
    messages: arrayType(ChatMessage$inboundSchema).optional(),
    chatId: stringType().optional(),
    followUpPrompts: arrayType(stringType()).optional(),
    backendTimeMillis: numberType().int().optional(),
    chatSessionTrackingToken: stringType().optional()
  });
  var ChatResponse$outboundSchema = objectType({
    messages: arrayType(ChatMessage$outboundSchema).optional(),
    chatId: stringType().optional(),
    followUpPrompts: arrayType(stringType()).optional(),
    backendTimeMillis: numberType().int().optional(),
    chatSessionTrackingToken: stringType().optional()
  });
  var ChatResponse$;
  (function(ChatResponse$2) {
    ChatResponse$2.inboundSchema = ChatResponse$inboundSchema;
    ChatResponse$2.outboundSchema = ChatResponse$outboundSchema;
  })(ChatResponse$ || (ChatResponse$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/chatresult.js
  var ChatResult$inboundSchema = objectType({
    chat: Chat$inboundSchema.optional(),
    trackingToken: stringType().optional()
  });
  var ChatResult$outboundSchema = objectType({
    chat: Chat$outboundSchema.optional(),
    trackingToken: stringType().optional()
  });
  var ChatResult$;
  (function(ChatResult$2) {
    ChatResult$2.inboundSchema = ChatResult$inboundSchema;
    ChatResult$2.outboundSchema = ChatResult$outboundSchema;
  })(ChatResult$ || (ChatResult$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/chatsuggestion.js
  var ChatSuggestion$inboundSchema = objectType({
    query: stringType().optional(),
    feature: stringType().optional()
  });
  var ChatSuggestion$outboundSchema = objectType({
    query: stringType().optional(),
    feature: stringType().optional()
  });
  var ChatSuggestion$;
  (function(ChatSuggestion$2) {
    ChatSuggestion$2.inboundSchema = ChatSuggestion$inboundSchema;
    ChatSuggestion$2.outboundSchema = ChatSuggestion$outboundSchema;
  })(ChatSuggestion$ || (ChatSuggestion$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/chatzerostatesuggestionoptions.js
  var ChatZeroStateSuggestionOptions$inboundSchema = objectType({
    applicationId: stringType().optional()
  });
  var ChatZeroStateSuggestionOptions$outboundSchema = objectType({
    applicationId: stringType().optional()
  });
  var ChatZeroStateSuggestionOptions$;
  (function(ChatZeroStateSuggestionOptions$2) {
    ChatZeroStateSuggestionOptions$2.inboundSchema = ChatZeroStateSuggestionOptions$inboundSchema;
    ChatZeroStateSuggestionOptions$2.outboundSchema = ChatZeroStateSuggestionOptions$outboundSchema;
  })(ChatZeroStateSuggestionOptions$ || (ChatZeroStateSuggestionOptions$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/checkdocumentaccessrequest.js
  var CheckDocumentAccessRequest$inboundSchema = objectType({
    datasource: stringType(),
    objectType: stringType(),
    docId: stringType(),
    userEmail: stringType()
  });
  var CheckDocumentAccessRequest$outboundSchema = objectType({
    datasource: stringType(),
    objectType: stringType(),
    docId: stringType(),
    userEmail: stringType()
  });
  var CheckDocumentAccessRequest$;
  (function(CheckDocumentAccessRequest$2) {
    CheckDocumentAccessRequest$2.inboundSchema = CheckDocumentAccessRequest$inboundSchema;
    CheckDocumentAccessRequest$2.outboundSchema = CheckDocumentAccessRequest$outboundSchema;
  })(CheckDocumentAccessRequest$ || (CheckDocumentAccessRequest$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/checkdocumentaccessresponse.js
  var CheckDocumentAccessResponse$inboundSchema = objectType({
    hasAccess: booleanType().optional()
  });
  var CheckDocumentAccessResponse$outboundSchema = objectType({
    hasAccess: booleanType().optional()
  });
  var CheckDocumentAccessResponse$;
  (function(CheckDocumentAccessResponse$2) {
    CheckDocumentAccessResponse$2.inboundSchema = CheckDocumentAccessResponse$inboundSchema;
    CheckDocumentAccessResponse$2.outboundSchema = CheckDocumentAccessResponse$outboundSchema;
  })(CheckDocumentAccessResponse$ || (CheckDocumentAccessResponse$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/collectionerror.js
  var CollectionErrorErrorCode = {
    NameExists: "NAME_EXISTS",
    NotFound: "NOT_FOUND",
    CollectionPinned: "COLLECTION_PINNED",
    ConcurrentHierarchyEdit: "CONCURRENT_HIERARCHY_EDIT",
    HeightViolation: "HEIGHT_VIOLATION",
    WidthViolation: "WIDTH_VIOLATION",
    NoPermissions: "NO_PERMISSIONS"
  };
  var CollectionErrorErrorCode$inboundSchema = nativeEnumType(CollectionErrorErrorCode);
  var CollectionErrorErrorCode$outboundSchema = CollectionErrorErrorCode$inboundSchema;
  var CollectionErrorErrorCode$;
  (function(CollectionErrorErrorCode$2) {
    CollectionErrorErrorCode$2.inboundSchema = CollectionErrorErrorCode$inboundSchema;
    CollectionErrorErrorCode$2.outboundSchema = CollectionErrorErrorCode$outboundSchema;
  })(CollectionErrorErrorCode$ || (CollectionErrorErrorCode$ = {}));
  var CollectionError$inboundSchema = objectType({
    errorCode: CollectionErrorErrorCode$inboundSchema
  });
  var CollectionError$outboundSchema = objectType({
    errorCode: CollectionErrorErrorCode$outboundSchema
  });
  var CollectionError$;
  (function(CollectionError$3) {
    CollectionError$3.inboundSchema = CollectionError$inboundSchema;
    CollectionError$3.outboundSchema = CollectionError$outboundSchema;
  })(CollectionError$ || (CollectionError$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/documentinsight.js
  var DocumentInsight$inboundSchema = objectType({
    document: Document$inboundSchema,
    viewCount: CountInfo$inboundSchema.optional(),
    visitorCount: CountInfo$inboundSchema.optional()
  });
  var DocumentInsight$outboundSchema = objectType({
    document: Document$outboundSchema,
    viewCount: CountInfo$outboundSchema.optional(),
    visitorCount: CountInfo$outboundSchema.optional()
  });
  var DocumentInsight$;
  (function(DocumentInsight$2) {
    DocumentInsight$2.inboundSchema = DocumentInsight$inboundSchema;
    DocumentInsight$2.outboundSchema = DocumentInsight$outboundSchema;
  })(DocumentInsight$ || (DocumentInsight$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/contentinsightsresponse.js
  var ContentInsightsResponse$inboundSchema = objectType({
    lastLogTimestamp: numberType().int().optional(),
    documentInsights: arrayType(DocumentInsight$inboundSchema).optional(),
    departments: arrayType(stringType()).optional(),
    minDepartmentSizeThreshold: numberType().int().optional(),
    minVisitorThreshold: numberType().int().optional()
  });
  var ContentInsightsResponse$outboundSchema = objectType({
    lastLogTimestamp: numberType().int().optional(),
    documentInsights: arrayType(DocumentInsight$outboundSchema).optional(),
    departments: arrayType(stringType()).optional(),
    minDepartmentSizeThreshold: numberType().int().optional(),
    minVisitorThreshold: numberType().int().optional()
  });
  var ContentInsightsResponse$;
  (function(ContentInsightsResponse$2) {
    ContentInsightsResponse$2.inboundSchema = ContentInsightsResponse$inboundSchema;
    ContentInsightsResponse$2.outboundSchema = ContentInsightsResponse$outboundSchema;
  })(ContentInsightsResponse$ || (ContentInsightsResponse$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/createannouncementrequest.js
  var CreateAnnouncementRequestChannel = {
    Main: "MAIN",
    SocialFeed: "SOCIAL_FEED"
  };
  var CreateAnnouncementRequestPostType = {
    Text: "TEXT",
    Link: "LINK"
  };
  var CreateAnnouncementRequestChannel$inboundSchema = nativeEnumType(CreateAnnouncementRequestChannel);
  var CreateAnnouncementRequestChannel$outboundSchema = CreateAnnouncementRequestChannel$inboundSchema;
  var CreateAnnouncementRequestChannel$;
  (function(CreateAnnouncementRequestChannel$2) {
    CreateAnnouncementRequestChannel$2.inboundSchema = CreateAnnouncementRequestChannel$inboundSchema;
    CreateAnnouncementRequestChannel$2.outboundSchema = CreateAnnouncementRequestChannel$outboundSchema;
  })(CreateAnnouncementRequestChannel$ || (CreateAnnouncementRequestChannel$ = {}));
  var CreateAnnouncementRequestPostType$inboundSchema = nativeEnumType(CreateAnnouncementRequestPostType);
  var CreateAnnouncementRequestPostType$outboundSchema = CreateAnnouncementRequestPostType$inboundSchema;
  var CreateAnnouncementRequestPostType$;
  (function(CreateAnnouncementRequestPostType$2) {
    CreateAnnouncementRequestPostType$2.inboundSchema = CreateAnnouncementRequestPostType$inboundSchema;
    CreateAnnouncementRequestPostType$2.outboundSchema = CreateAnnouncementRequestPostType$outboundSchema;
  })(CreateAnnouncementRequestPostType$ || (CreateAnnouncementRequestPostType$ = {}));
  var CreateAnnouncementRequest$inboundSchema = objectType({
    startTime: stringType().datetime({ offset: true }).transform((v) => new Date(v)),
    endTime: stringType().datetime({ offset: true }).transform((v) => new Date(v)),
    title: stringType(),
    body: StructuredText$inboundSchema.optional(),
    emoji: stringType().optional(),
    thumbnail: Thumbnail$inboundSchema.optional(),
    banner: Thumbnail$inboundSchema.optional(),
    audienceFilters: arrayType(FacetFilter$inboundSchema).optional(),
    sourceDocumentId: stringType().optional(),
    hideAttribution: booleanType().optional(),
    channel: CreateAnnouncementRequestChannel$inboundSchema.optional(),
    postType: CreateAnnouncementRequestPostType$inboundSchema.optional(),
    isPrioritized: booleanType().optional(),
    viewUrl: stringType().optional()
  });
  var CreateAnnouncementRequest$outboundSchema = objectType({
    startTime: dateType().transform((v) => v.toISOString()),
    endTime: dateType().transform((v) => v.toISOString()),
    title: stringType(),
    body: StructuredText$outboundSchema.optional(),
    emoji: stringType().optional(),
    thumbnail: Thumbnail$outboundSchema.optional(),
    banner: Thumbnail$outboundSchema.optional(),
    audienceFilters: arrayType(FacetFilter$outboundSchema).optional(),
    sourceDocumentId: stringType().optional(),
    hideAttribution: booleanType().optional(),
    channel: CreateAnnouncementRequestChannel$outboundSchema.optional(),
    postType: CreateAnnouncementRequestPostType$outboundSchema.optional(),
    isPrioritized: booleanType().optional(),
    viewUrl: stringType().optional()
  });
  var CreateAnnouncementRequest$;
  (function(CreateAnnouncementRequest$2) {
    CreateAnnouncementRequest$2.inboundSchema = CreateAnnouncementRequest$inboundSchema;
    CreateAnnouncementRequest$2.outboundSchema = CreateAnnouncementRequest$outboundSchema;
  })(CreateAnnouncementRequest$ || (CreateAnnouncementRequest$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/createanswerrequest.js
  var CreateAnswerRequest$inboundSchema = objectType({
    data: AnswerCreationData$inboundSchema
  });
  var CreateAnswerRequest$outboundSchema = objectType({
    data: AnswerCreationData$outboundSchema
  });
  var CreateAnswerRequest$;
  (function(CreateAnswerRequest$2) {
    CreateAnswerRequest$2.inboundSchema = CreateAnswerRequest$inboundSchema;
    CreateAnswerRequest$2.outboundSchema = CreateAnswerRequest$outboundSchema;
  })(CreateAnswerRequest$ || (CreateAnswerRequest$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/createauthtokenresponse.js
  var CreateAuthTokenResponse$inboundSchema = objectType({
    token: stringType(),
    expirationTime: numberType().int()
  });
  var CreateAuthTokenResponse$outboundSchema = objectType({
    token: stringType(),
    expirationTime: numberType().int()
  });
  var CreateAuthTokenResponse$;
  (function(CreateAuthTokenResponse$2) {
    CreateAuthTokenResponse$2.inboundSchema = CreateAuthTokenResponse$inboundSchema;
    CreateAuthTokenResponse$2.outboundSchema = CreateAuthTokenResponse$outboundSchema;
  })(CreateAuthTokenResponse$ || (CreateAuthTokenResponse$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/createcollectionrequest.js
  var CreateCollectionRequest$inboundSchema = objectType({
    name: stringType(),
    description: stringType().optional(),
    addedRoles: arrayType(UserRoleSpecification$inboundSchema).optional(),
    removedRoles: arrayType(UserRoleSpecification$inboundSchema).optional(),
    audienceFilters: arrayType(FacetFilter$inboundSchema).optional(),
    icon: stringType().optional(),
    adminLocked: booleanType().optional(),
    parentId: numberType().int().optional(),
    thumbnail: Thumbnail$inboundSchema.optional(),
    allowedDatasource: stringType().optional(),
    newNextItemId: stringType().optional()
  });
  var CreateCollectionRequest$outboundSchema = objectType({
    name: stringType(),
    description: stringType().optional(),
    addedRoles: arrayType(UserRoleSpecification$outboundSchema).optional(),
    removedRoles: arrayType(UserRoleSpecification$outboundSchema).optional(),
    audienceFilters: arrayType(FacetFilter$outboundSchema).optional(),
    icon: stringType().optional(),
    adminLocked: booleanType().optional(),
    parentId: numberType().int().optional(),
    thumbnail: Thumbnail$outboundSchema.optional(),
    allowedDatasource: stringType().optional(),
    newNextItemId: stringType().optional()
  });
  var CreateCollectionRequest$;
  (function(CreateCollectionRequest$2) {
    CreateCollectionRequest$2.inboundSchema = CreateCollectionRequest$inboundSchema;
    CreateCollectionRequest$2.outboundSchema = CreateCollectionRequest$outboundSchema;
  })(CreateCollectionRequest$ || (CreateCollectionRequest$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/dlppersonmetadata.js
  var DlpPersonMetadata$inboundSchema = objectType({
    firstName: stringType().optional(),
    email: stringType().optional()
  });
  var DlpPersonMetadata$outboundSchema = objectType({
    firstName: stringType().optional(),
    email: stringType().optional()
  });
  var DlpPersonMetadata$;
  (function(DlpPersonMetadata$2) {
    DlpPersonMetadata$2.inboundSchema = DlpPersonMetadata$inboundSchema;
    DlpPersonMetadata$2.outboundSchema = DlpPersonMetadata$outboundSchema;
  })(DlpPersonMetadata$ || (DlpPersonMetadata$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/dlpperson.js
  var DlpPerson$inboundSchema = objectType({
    name: stringType(),
    obfuscatedId: stringType(),
    metadata: DlpPersonMetadata$inboundSchema.optional()
  });
  var DlpPerson$outboundSchema = objectType({
    name: stringType(),
    obfuscatedId: stringType(),
    metadata: DlpPersonMetadata$outboundSchema.optional()
  });
  var DlpPerson$;
  (function(DlpPerson$2) {
    DlpPerson$2.inboundSchema = DlpPerson$inboundSchema;
    DlpPerson$2.outboundSchema = DlpPerson$outboundSchema;
  })(DlpPerson$ || (DlpPerson$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/externalsharingoptions.js
  var ExternalSharingOptions$inboundSchema = objectType({
    enabled: booleanType().optional(),
    threshold: numberType().int().optional(),
    thresholdEnabled: booleanType().optional(),
    anyoneWithLinkEnabled: booleanType().optional(),
    anyoneInternalEnabled: booleanType().optional(),
    anonymousAccessEnabled: booleanType().optional(),
    userAccessEnabled: booleanType().optional(),
    userIds: arrayType(stringType()).optional(),
    domainAccessEnabled: booleanType().optional()
  });
  var ExternalSharingOptions$outboundSchema = objectType({
    enabled: booleanType().optional(),
    threshold: numberType().int().optional(),
    thresholdEnabled: booleanType().optional(),
    anyoneWithLinkEnabled: booleanType().optional(),
    anyoneInternalEnabled: booleanType().optional(),
    anonymousAccessEnabled: booleanType().optional(),
    userAccessEnabled: booleanType().optional(),
    userIds: arrayType(stringType()).optional(),
    domainAccessEnabled: booleanType().optional()
  });
  var ExternalSharingOptions$;
  (function(ExternalSharingOptions$2) {
    ExternalSharingOptions$2.inboundSchema = ExternalSharingOptions$inboundSchema;
    ExternalSharingOptions$2.outboundSchema = ExternalSharingOptions$outboundSchema;
  })(ExternalSharingOptions$ || (ExternalSharingOptions$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/timerange.js
  var TimeRange$inboundSchema = objectType({
    startTime: stringType().datetime({ offset: true }).transform((v) => new Date(v)).optional(),
    endTime: stringType().datetime({ offset: true }).transform((v) => new Date(v)).optional(),
    lastNDaysValue: numberType().int().optional()
  });
  var TimeRange$outboundSchema = objectType({
    startTime: dateType().transform((v) => v.toISOString()).optional(),
    endTime: dateType().transform((v) => v.toISOString()).optional(),
    lastNDaysValue: numberType().int().optional()
  });
  var TimeRange$;
  (function(TimeRange$2) {
    TimeRange$2.inboundSchema = TimeRange$inboundSchema;
    TimeRange$2.outboundSchema = TimeRange$outboundSchema;
  })(TimeRange$ || (TimeRange$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/inputoptions.js
  var DatasourcesType = {
    All: "ALL",
    Custom: "CUSTOM"
  };
  var TimePeriodType = {
    AllTime: "ALL_TIME",
    PastYear: "PAST_YEAR",
    PastDay: "PAST_DAY",
    Custom: "CUSTOM",
    LastNDays: "LAST_N_DAYS"
  };
  var DatasourcesType$inboundSchema = nativeEnumType(DatasourcesType);
  var DatasourcesType$outboundSchema = DatasourcesType$inboundSchema;
  var DatasourcesType$;
  (function(DatasourcesType$2) {
    DatasourcesType$2.inboundSchema = DatasourcesType$inboundSchema;
    DatasourcesType$2.outboundSchema = DatasourcesType$outboundSchema;
  })(DatasourcesType$ || (DatasourcesType$ = {}));
  var TimePeriodType$inboundSchema = nativeEnumType(TimePeriodType);
  var TimePeriodType$outboundSchema = TimePeriodType$inboundSchema;
  var TimePeriodType$;
  (function(TimePeriodType$2) {
    TimePeriodType$2.inboundSchema = TimePeriodType$inboundSchema;
    TimePeriodType$2.outboundSchema = TimePeriodType$outboundSchema;
  })(TimePeriodType$ || (TimePeriodType$ = {}));
  var InputOptions$inboundSchema = objectType({
    urlGreenlist: arrayType(stringType()).optional(),
    datasourcesType: DatasourcesType$inboundSchema.optional(),
    datasources: arrayType(stringType()).optional(),
    datasourceInstances: arrayType(stringType()).optional(),
    timePeriodType: TimePeriodType$inboundSchema.optional(),
    customTimeRange: TimeRange$inboundSchema.optional()
  });
  var InputOptions$outboundSchema = objectType({
    urlGreenlist: arrayType(stringType()).optional(),
    datasourcesType: DatasourcesType$outboundSchema.optional(),
    datasources: arrayType(stringType()).optional(),
    datasourceInstances: arrayType(stringType()).optional(),
    timePeriodType: TimePeriodType$outboundSchema.optional(),
    customTimeRange: TimeRange$outboundSchema.optional()
  });
  var InputOptions$;
  (function(InputOptions$2) {
    InputOptions$2.inboundSchema = InputOptions$inboundSchema;
    InputOptions$2.outboundSchema = InputOptions$outboundSchema;
  })(InputOptions$ || (InputOptions$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/hotwordproximity.js
  var HotwordProximity$inboundSchema = objectType({
    windowBefore: numberType().int().optional(),
    windowAfter: numberType().int().optional()
  });
  var HotwordProximity$outboundSchema = objectType({
    windowBefore: numberType().int().optional(),
    windowAfter: numberType().int().optional()
  });
  var HotwordProximity$;
  (function(HotwordProximity$2) {
    HotwordProximity$2.inboundSchema = HotwordProximity$inboundSchema;
    HotwordProximity$2.outboundSchema = HotwordProximity$outboundSchema;
  })(HotwordProximity$ || (HotwordProximity$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/hotword.js
  var Hotword$inboundSchema = objectType({
    regex: stringType().optional(),
    proximity: HotwordProximity$inboundSchema.optional()
  });
  var Hotword$outboundSchema = objectType({
    regex: stringType().optional(),
    proximity: HotwordProximity$outboundSchema.optional()
  });
  var Hotword$;
  (function(Hotword$2) {
    Hotword$2.inboundSchema = Hotword$inboundSchema;
    Hotword$2.outboundSchema = Hotword$outboundSchema;
  })(Hotword$ || (Hotword$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/sensitiveexpression.js
  var SensitiveExpression$inboundSchema = objectType({
    expression: stringType().optional(),
    hotwords: arrayType(Hotword$inboundSchema).optional()
  });
  var SensitiveExpression$outboundSchema = objectType({
    expression: stringType().optional(),
    hotwords: arrayType(Hotword$outboundSchema).optional()
  });
  var SensitiveExpression$;
  (function(SensitiveExpression$2) {
    SensitiveExpression$2.inboundSchema = SensitiveExpression$inboundSchema;
    SensitiveExpression$2.outboundSchema = SensitiveExpression$outboundSchema;
  })(SensitiveExpression$ || (SensitiveExpression$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/sensitiveinfotype.js
  var LikelihoodThreshold = {
    Likely: "LIKELY",
    VeryLikely: "VERY_LIKELY"
  };
  var LikelihoodThreshold$inboundSchema = nativeEnumType(LikelihoodThreshold);
  var LikelihoodThreshold$outboundSchema = LikelihoodThreshold$inboundSchema;
  var LikelihoodThreshold$;
  (function(LikelihoodThreshold$2) {
    LikelihoodThreshold$2.inboundSchema = LikelihoodThreshold$inboundSchema;
    LikelihoodThreshold$2.outboundSchema = LikelihoodThreshold$outboundSchema;
  })(LikelihoodThreshold$ || (LikelihoodThreshold$ = {}));
  var SensitiveInfoType$inboundSchema = objectType({
    likelihoodThreshold: LikelihoodThreshold$inboundSchema.optional(),
    infoType: stringType().optional()
  });
  var SensitiveInfoType$outboundSchema = objectType({
    likelihoodThreshold: LikelihoodThreshold$outboundSchema.optional(),
    infoType: stringType().optional()
  });
  var SensitiveInfoType$;
  (function(SensitiveInfoType$2) {
    SensitiveInfoType$2.inboundSchema = SensitiveInfoType$inboundSchema;
    SensitiveInfoType$2.outboundSchema = SensitiveInfoType$outboundSchema;
  })(SensitiveInfoType$ || (SensitiveInfoType$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/sensitivecontentoptions.js
  var SensitiveContentOptions$inboundSchema = objectType({
    sensitiveInfoTypes: arrayType(SensitiveInfoType$inboundSchema).optional(),
    sensitiveTerms: arrayType(SensitiveExpression$inboundSchema).optional(),
    sensitiveRegexes: arrayType(SensitiveExpression$inboundSchema).optional()
  });
  var SensitiveContentOptions$outboundSchema = objectType({
    sensitiveInfoTypes: arrayType(SensitiveInfoType$outboundSchema).optional(),
    sensitiveTerms: arrayType(SensitiveExpression$outboundSchema).optional(),
    sensitiveRegexes: arrayType(SensitiveExpression$outboundSchema).optional()
  });
  var SensitiveContentOptions$;
  (function(SensitiveContentOptions$2) {
    SensitiveContentOptions$2.inboundSchema = SensitiveContentOptions$inboundSchema;
    SensitiveContentOptions$2.outboundSchema = SensitiveContentOptions$outboundSchema;
  })(SensitiveContentOptions$ || (SensitiveContentOptions$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/sharingoptions.js
  var SharingOptions$inboundSchema = objectType({
    enabled: booleanType().optional(),
    threshold: numberType().int().optional(),
    thresholdEnabled: booleanType().optional(),
    anyoneWithLinkEnabled: booleanType().optional(),
    anyoneInternalEnabled: booleanType().optional(),
    anonymousAccessEnabled: booleanType().optional(),
    userAccessEnabled: booleanType().optional(),
    userIds: arrayType(stringType()).optional()
  });
  var SharingOptions$outboundSchema = objectType({
    enabled: booleanType().optional(),
    threshold: numberType().int().optional(),
    thresholdEnabled: booleanType().optional(),
    anyoneWithLinkEnabled: booleanType().optional(),
    anyoneInternalEnabled: booleanType().optional(),
    anonymousAccessEnabled: booleanType().optional(),
    userAccessEnabled: booleanType().optional(),
    userIds: arrayType(stringType()).optional()
  });
  var SharingOptions$;
  (function(SharingOptions$2) {
    SharingOptions$2.inboundSchema = SharingOptions$inboundSchema;
    SharingOptions$2.outboundSchema = SharingOptions$outboundSchema;
  })(SharingOptions$ || (SharingOptions$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/dlpconfig.js
  var DlpConfig$inboundSchema = objectType({
    version: numberType().int().optional(),
    sensitiveInfoTypes: arrayType(SensitiveInfoType$inboundSchema).optional(),
    inputOptions: InputOptions$inboundSchema.optional(),
    externalSharingOptions: ExternalSharingOptions$inboundSchema.optional(),
    broadSharingOptions: SharingOptions$inboundSchema.optional(),
    sensitiveContentOptions: SensitiveContentOptions$inboundSchema.optional(),
    reportName: stringType().optional(),
    frequency: stringType().optional(),
    createdBy: DlpPerson$inboundSchema.optional(),
    createdAt: stringType().optional(),
    redactQuote: booleanType().optional(),
    autoHideDocs: booleanType().optional(),
    allowlistOptions: AllowlistOptions$inboundSchema.optional()
  });
  var DlpConfig$outboundSchema = objectType({
    version: numberType().int().optional(),
    sensitiveInfoTypes: arrayType(SensitiveInfoType$outboundSchema).optional(),
    inputOptions: InputOptions$outboundSchema.optional(),
    externalSharingOptions: ExternalSharingOptions$outboundSchema.optional(),
    broadSharingOptions: SharingOptions$outboundSchema.optional(),
    sensitiveContentOptions: SensitiveContentOptions$outboundSchema.optional(),
    reportName: stringType().optional(),
    frequency: stringType().optional(),
    createdBy: DlpPerson$outboundSchema.optional(),
    createdAt: stringType().optional(),
    redactQuote: booleanType().optional(),
    autoHideDocs: booleanType().optional(),
    allowlistOptions: AllowlistOptions$outboundSchema.optional()
  });
  var DlpConfig$;
  (function(DlpConfig$2) {
    DlpConfig$2.inboundSchema = DlpConfig$inboundSchema;
    DlpConfig$2.outboundSchema = DlpConfig$outboundSchema;
  })(DlpConfig$ || (DlpConfig$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/dlpfrequency.js
  var DlpFrequency = {
    Once: "ONCE",
    Daily: "DAILY",
    Weekly: "WEEKLY",
    Continuous: "CONTINUOUS",
    None: "NONE"
  };
  var DlpFrequency$inboundSchema = nativeEnumType(DlpFrequency);
  var DlpFrequency$outboundSchema = DlpFrequency$inboundSchema;
  var DlpFrequency$;
  (function(DlpFrequency$2) {
    DlpFrequency$2.inboundSchema = DlpFrequency$inboundSchema;
    DlpFrequency$2.outboundSchema = DlpFrequency$outboundSchema;
  })(DlpFrequency$ || (DlpFrequency$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/createdlpreportrequest.js
  var CreateDlpReportRequest$inboundSchema = objectType({
    name: stringType().optional(),
    config: DlpConfig$inboundSchema.optional(),
    frequency: DlpFrequency$inboundSchema.optional(),
    autoHideDocs: booleanType().optional()
  });
  var CreateDlpReportRequest$outboundSchema = objectType({
    name: stringType().optional(),
    config: DlpConfig$outboundSchema.optional(),
    frequency: DlpFrequency$outboundSchema.optional(),
    autoHideDocs: booleanType().optional()
  });
  var CreateDlpReportRequest$;
  (function(CreateDlpReportRequest$2) {
    CreateDlpReportRequest$2.inboundSchema = CreateDlpReportRequest$inboundSchema;
    CreateDlpReportRequest$2.outboundSchema = CreateDlpReportRequest$outboundSchema;
  })(CreateDlpReportRequest$ || (CreateDlpReportRequest$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/dlpreportstatus.js
  var DlpReportStatus = {
    Active: "ACTIVE",
    Inactive: "INACTIVE",
    Cancelled: "CANCELLED",
    None: "NONE"
  };
  var DlpReportStatus$inboundSchema = nativeEnumType(DlpReportStatus);
  var DlpReportStatus$outboundSchema = DlpReportStatus$inboundSchema;
  var DlpReportStatus$;
  (function(DlpReportStatus$2) {
    DlpReportStatus$2.inboundSchema = DlpReportStatus$inboundSchema;
    DlpReportStatus$2.outboundSchema = DlpReportStatus$outboundSchema;
  })(DlpReportStatus$ || (DlpReportStatus$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/dlpreport.js
  var LastScanStatus = {
    Pending: "PENDING",
    Success: "SUCCESS",
    Failure: "FAILURE",
    Cancelled: "CANCELLED",
    Cancelling: "CANCELLING",
    Active: "ACTIVE"
  };
  var LastScanStatus$inboundSchema = nativeEnumType(LastScanStatus);
  var LastScanStatus$outboundSchema = LastScanStatus$inboundSchema;
  var LastScanStatus$;
  (function(LastScanStatus$2) {
    LastScanStatus$2.inboundSchema = LastScanStatus$inboundSchema;
    LastScanStatus$2.outboundSchema = LastScanStatus$outboundSchema;
  })(LastScanStatus$ || (LastScanStatus$ = {}));
  var DlpReport$inboundSchema = objectType({
    id: stringType().optional(),
    name: stringType().optional(),
    config: DlpConfig$inboundSchema.optional(),
    frequency: DlpFrequency$inboundSchema.optional(),
    status: DlpReportStatus$inboundSchema.optional(),
    createdBy: DlpPerson$inboundSchema.optional(),
    createdAt: stringType().optional(),
    lastUpdatedAt: stringType().optional(),
    autoHideDocs: booleanType().optional(),
    lastScanStatus: LastScanStatus$inboundSchema.optional(),
    lastScanStartTime: stringType().optional(),
    updatedBy: DlpPerson$inboundSchema.optional()
  });
  var DlpReport$outboundSchema = objectType({
    id: stringType().optional(),
    name: stringType().optional(),
    config: DlpConfig$outboundSchema.optional(),
    frequency: DlpFrequency$outboundSchema.optional(),
    status: DlpReportStatus$outboundSchema.optional(),
    createdBy: DlpPerson$outboundSchema.optional(),
    createdAt: stringType().optional(),
    lastUpdatedAt: stringType().optional(),
    autoHideDocs: booleanType().optional(),
    lastScanStatus: LastScanStatus$outboundSchema.optional(),
    lastScanStartTime: stringType().optional(),
    updatedBy: DlpPerson$outboundSchema.optional()
  });
  var DlpReport$;
  (function(DlpReport$2) {
    DlpReport$2.inboundSchema = DlpReport$inboundSchema;
    DlpReport$2.outboundSchema = DlpReport$outboundSchema;
  })(DlpReport$ || (DlpReport$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/createdlpreportresponse.js
  var CreateDlpReportResponse$inboundSchema = objectType({
    report: DlpReport$inboundSchema.optional()
  });
  var CreateDlpReportResponse$outboundSchema = objectType({
    report: DlpReport$outboundSchema.optional()
  });
  var CreateDlpReportResponse$;
  (function(CreateDlpReportResponse$2) {
    CreateDlpReportResponse$2.inboundSchema = CreateDlpReportResponse$inboundSchema;
    CreateDlpReportResponse$2.outboundSchema = CreateDlpReportResponse$outboundSchema;
  })(CreateDlpReportResponse$ || (CreateDlpReportResponse$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/shortcutmutableproperties.js
  var ShortcutMutableProperties$inboundSchema = objectType({
    inputAlias: stringType().optional(),
    destinationUrl: stringType().optional(),
    destinationDocumentId: stringType().optional(),
    description: stringType().optional(),
    unlisted: booleanType().optional(),
    urlTemplate: stringType().optional(),
    addedRoles: arrayType(UserRoleSpecification$inboundSchema).optional(),
    removedRoles: arrayType(UserRoleSpecification$inboundSchema).optional()
  });
  var ShortcutMutableProperties$outboundSchema = objectType({
    inputAlias: stringType().optional(),
    destinationUrl: stringType().optional(),
    destinationDocumentId: stringType().optional(),
    description: stringType().optional(),
    unlisted: booleanType().optional(),
    urlTemplate: stringType().optional(),
    addedRoles: arrayType(UserRoleSpecification$outboundSchema).optional(),
    removedRoles: arrayType(UserRoleSpecification$outboundSchema).optional()
  });
  var ShortcutMutableProperties$;
  (function(ShortcutMutableProperties$2) {
    ShortcutMutableProperties$2.inboundSchema = ShortcutMutableProperties$inboundSchema;
    ShortcutMutableProperties$2.outboundSchema = ShortcutMutableProperties$outboundSchema;
  })(ShortcutMutableProperties$ || (ShortcutMutableProperties$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/createshortcutrequest.js
  var CreateShortcutRequest$inboundSchema = objectType({
    data: ShortcutMutableProperties$inboundSchema
  });
  var CreateShortcutRequest$outboundSchema = objectType({
    data: ShortcutMutableProperties$outboundSchema
  });
  var CreateShortcutRequest$;
  (function(CreateShortcutRequest$2) {
    CreateShortcutRequest$2.inboundSchema = CreateShortcutRequest$inboundSchema;
    CreateShortcutRequest$2.outboundSchema = CreateShortcutRequest$outboundSchema;
  })(CreateShortcutRequest$ || (CreateShortcutRequest$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/shortcuterror.js
  var ShortcutErrorErrorType = {
    NoPermission: "NO_PERMISSION",
    InvalidId: "INVALID_ID",
    ExistingShortcut: "EXISTING_SHORTCUT",
    InvalidChars: "INVALID_CHARS"
  };
  var ShortcutErrorErrorType$inboundSchema = nativeEnumType(ShortcutErrorErrorType);
  var ShortcutErrorErrorType$outboundSchema = ShortcutErrorErrorType$inboundSchema;
  var ShortcutErrorErrorType$;
  (function(ShortcutErrorErrorType$2) {
    ShortcutErrorErrorType$2.inboundSchema = ShortcutErrorErrorType$inboundSchema;
    ShortcutErrorErrorType$2.outboundSchema = ShortcutErrorErrorType$outboundSchema;
  })(ShortcutErrorErrorType$ || (ShortcutErrorErrorType$ = {}));
  var ShortcutError$inboundSchema = objectType({
    errorType: ShortcutErrorErrorType$inboundSchema.optional()
  });
  var ShortcutError$outboundSchema = objectType({
    errorType: ShortcutErrorErrorType$outboundSchema.optional()
  });
  var ShortcutError$;
  (function(ShortcutError$2) {
    ShortcutError$2.inboundSchema = ShortcutError$inboundSchema;
    ShortcutError$2.outboundSchema = ShortcutError$outboundSchema;
  })(ShortcutError$ || (ShortcutError$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/createshortcutresponse.js
  var CreateShortcutResponse$inboundSchema = objectType({
    shortcut: Shortcut$inboundSchema.optional(),
    error: ShortcutError$inboundSchema.optional()
  });
  var CreateShortcutResponse$outboundSchema = objectType({
    shortcut: Shortcut$outboundSchema.optional(),
    error: ShortcutError$outboundSchema.optional()
  });
  var CreateShortcutResponse$;
  (function(CreateShortcutResponse$2) {
    CreateShortcutResponse$2.inboundSchema = CreateShortcutResponse$inboundSchema;
    CreateShortcutResponse$2.outboundSchema = CreateShortcutResponse$outboundSchema;
  })(CreateShortcutResponse$ || (CreateShortcutResponse$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/propertydefinition.js
  var PropertyType = {
    Text: "TEXT",
    Date: "DATE",
    Int: "INT",
    Userid: "USERID",
    Picklist: "PICKLIST",
    Textlist: "TEXTLIST",
    Multipicklist: "MULTIPICKLIST"
  };
  var UiOptions = {
    None: "NONE",
    SearchResult: "SEARCH_RESULT",
    DocHovercard: "DOC_HOVERCARD"
  };
  var PropertyType$inboundSchema = nativeEnumType(PropertyType);
  var PropertyType$outboundSchema = PropertyType$inboundSchema;
  var PropertyType$;
  (function(PropertyType$2) {
    PropertyType$2.inboundSchema = PropertyType$inboundSchema;
    PropertyType$2.outboundSchema = PropertyType$outboundSchema;
  })(PropertyType$ || (PropertyType$ = {}));
  var UiOptions$inboundSchema = nativeEnumType(UiOptions);
  var UiOptions$outboundSchema = UiOptions$inboundSchema;
  var UiOptions$;
  (function(UiOptions$2) {
    UiOptions$2.inboundSchema = UiOptions$inboundSchema;
    UiOptions$2.outboundSchema = UiOptions$outboundSchema;
  })(UiOptions$ || (UiOptions$ = {}));
  var PropertyDefinition$inboundSchema = objectType({
    name: stringType().optional(),
    displayLabel: stringType().optional(),
    displayLabelPlural: stringType().optional(),
    propertyType: PropertyType$inboundSchema.optional(),
    uiOptions: UiOptions$inboundSchema.optional(),
    hideUiFacet: booleanType().optional(),
    uiFacetOrder: numberType().int().optional(),
    skipIndexing: booleanType().optional(),
    group: stringType().optional()
  });
  var PropertyDefinition$outboundSchema = objectType({
    name: stringType().optional(),
    displayLabel: stringType().optional(),
    displayLabelPlural: stringType().optional(),
    propertyType: PropertyType$outboundSchema.optional(),
    uiOptions: UiOptions$outboundSchema.optional(),
    hideUiFacet: booleanType().optional(),
    uiFacetOrder: numberType().int().optional(),
    skipIndexing: booleanType().optional(),
    group: stringType().optional()
  });
  var PropertyDefinition$;
  (function(PropertyDefinition$2) {
    PropertyDefinition$2.inboundSchema = PropertyDefinition$inboundSchema;
    PropertyDefinition$2.outboundSchema = PropertyDefinition$outboundSchema;
  })(PropertyDefinition$ || (PropertyDefinition$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/propertygroup.js
  var PropertyGroup$inboundSchema = objectType({
    name: stringType().optional(),
    displayLabel: stringType().optional()
  });
  var PropertyGroup$outboundSchema = objectType({
    name: stringType().optional(),
    displayLabel: stringType().optional()
  });
  var PropertyGroup$;
  (function(PropertyGroup$2) {
    PropertyGroup$2.inboundSchema = PropertyGroup$inboundSchema;
    PropertyGroup$2.outboundSchema = PropertyGroup$outboundSchema;
  })(PropertyGroup$ || (PropertyGroup$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/objectdefinition.js
  var DocCategory = {
    Uncategorized: "UNCATEGORIZED",
    Tickets: "TICKETS",
    Crm: "CRM",
    PublishedContent: "PUBLISHED_CONTENT",
    CollaborativeContent: "COLLABORATIVE_CONTENT",
    QuestionAnswer: "QUESTION_ANSWER",
    Messaging: "MESSAGING",
    CodeRepository: "CODE_REPOSITORY",
    ChangeManagement: "CHANGE_MANAGEMENT",
    People: "PEOPLE",
    Email: "EMAIL",
    Sso: "SSO",
    Ats: "ATS",
    KnowledgeHub: "KNOWLEDGE_HUB",
    ExternalShortcut: "EXTERNAL_SHORTCUT",
    Entity: "ENTITY",
    Calendar: "CALENDAR",
    Agents: "AGENTS"
  };
  var DocCategory$inboundSchema = nativeEnumType(DocCategory);
  var DocCategory$outboundSchema = DocCategory$inboundSchema;
  var DocCategory$;
  (function(DocCategory$2) {
    DocCategory$2.inboundSchema = DocCategory$inboundSchema;
    DocCategory$2.outboundSchema = DocCategory$outboundSchema;
  })(DocCategory$ || (DocCategory$ = {}));
  var ObjectDefinition$inboundSchema = objectType({
    name: stringType().optional(),
    displayLabel: stringType().optional(),
    docCategory: DocCategory$inboundSchema.optional(),
    propertyDefinitions: arrayType(PropertyDefinition$inboundSchema).optional(),
    propertyGroups: arrayType(PropertyGroup$inboundSchema).optional(),
    summarizable: booleanType().optional()
  });
  var ObjectDefinition$outboundSchema = objectType({
    name: stringType().optional(),
    displayLabel: stringType().optional(),
    docCategory: DocCategory$outboundSchema.optional(),
    propertyDefinitions: arrayType(PropertyDefinition$outboundSchema).optional(),
    propertyGroups: arrayType(PropertyGroup$outboundSchema).optional(),
    summarizable: booleanType().optional()
  });
  var ObjectDefinition$;
  (function(ObjectDefinition$2) {
    ObjectDefinition$2.inboundSchema = ObjectDefinition$inboundSchema;
    ObjectDefinition$2.outboundSchema = ObjectDefinition$outboundSchema;
  })(ObjectDefinition$ || (ObjectDefinition$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/customdatasourceconfig.js
  var DatasourceCategory = {
    Uncategorized: "UNCATEGORIZED",
    Tickets: "TICKETS",
    Crm: "CRM",
    PublishedContent: "PUBLISHED_CONTENT",
    CollaborativeContent: "COLLABORATIVE_CONTENT",
    QuestionAnswer: "QUESTION_ANSWER",
    Messaging: "MESSAGING",
    CodeRepository: "CODE_REPOSITORY",
    ChangeManagement: "CHANGE_MANAGEMENT",
    People: "PEOPLE",
    Email: "EMAIL",
    Sso: "SSO",
    Ats: "ATS",
    KnowledgeHub: "KNOWLEDGE_HUB",
    ExternalShortcut: "EXTERNAL_SHORTCUT",
    Entity: "ENTITY",
    Calendar: "CALENDAR",
    Agents: "AGENTS"
  };
  var HideBuiltInFacet = {
    Type: "TYPE",
    Tag: "TAG",
    Author: "AUTHOR",
    Owner: "OWNER"
  };
  var CustomDatasourceConfigConnectorType = {
    ApiCrawl: "API_CRAWL",
    BrowserCrawl: "BROWSER_CRAWL",
    BrowserHistory: "BROWSER_HISTORY",
    Builtin: "BUILTIN",
    FederatedSearch: "FEDERATED_SEARCH",
    PushApi: "PUSH_API",
    WebCrawl: "WEB_CRAWL",
    NativeHistory: "NATIVE_HISTORY"
  };
  var DatasourceCategory$inboundSchema = nativeEnumType(DatasourceCategory);
  var DatasourceCategory$outboundSchema = DatasourceCategory$inboundSchema;
  var DatasourceCategory$;
  (function(DatasourceCategory$2) {
    DatasourceCategory$2.inboundSchema = DatasourceCategory$inboundSchema;
    DatasourceCategory$2.outboundSchema = DatasourceCategory$outboundSchema;
  })(DatasourceCategory$ || (DatasourceCategory$ = {}));
  var HideBuiltInFacet$inboundSchema = nativeEnumType(HideBuiltInFacet);
  var HideBuiltInFacet$outboundSchema = HideBuiltInFacet$inboundSchema;
  var HideBuiltInFacet$;
  (function(HideBuiltInFacet$2) {
    HideBuiltInFacet$2.inboundSchema = HideBuiltInFacet$inboundSchema;
    HideBuiltInFacet$2.outboundSchema = HideBuiltInFacet$outboundSchema;
  })(HideBuiltInFacet$ || (HideBuiltInFacet$ = {}));
  var CustomDatasourceConfigConnectorType$inboundSchema = nativeEnumType(CustomDatasourceConfigConnectorType);
  var CustomDatasourceConfigConnectorType$outboundSchema = CustomDatasourceConfigConnectorType$inboundSchema;
  var CustomDatasourceConfigConnectorType$;
  (function(CustomDatasourceConfigConnectorType$2) {
    CustomDatasourceConfigConnectorType$2.inboundSchema = CustomDatasourceConfigConnectorType$inboundSchema;
    CustomDatasourceConfigConnectorType$2.outboundSchema = CustomDatasourceConfigConnectorType$outboundSchema;
  })(CustomDatasourceConfigConnectorType$ || (CustomDatasourceConfigConnectorType$ = {}));
  var CustomDatasourceConfig$inboundSchema = objectType({
    name: stringType(),
    displayName: stringType().optional(),
    datasourceCategory: DatasourceCategory$inboundSchema.default("UNCATEGORIZED"),
    urlRegex: stringType().optional(),
    iconUrl: stringType().optional(),
    objectDefinitions: arrayType(ObjectDefinition$inboundSchema).optional(),
    suggestionText: stringType().optional(),
    homeUrl: stringType().optional(),
    crawlerSeedUrls: arrayType(stringType()).optional(),
    iconDarkUrl: stringType().optional(),
    hideBuiltInFacets: arrayType(HideBuiltInFacet$inboundSchema).optional(),
    canonicalizingURLRegex: arrayType(CanonicalizingRegexType$inboundSchema).optional(),
    canonicalizingTitleRegex: arrayType(CanonicalizingRegexType$inboundSchema).optional(),
    redlistTitleRegex: stringType().optional(),
    connectorType: CustomDatasourceConfigConnectorType$inboundSchema.optional(),
    quicklinks: arrayType(Quicklink$inboundSchema).optional(),
    renderConfigPreset: stringType().optional(),
    aliases: arrayType(stringType()).optional(),
    isOnPrem: booleanType().optional(),
    trustUrlRegexForViewActivity: booleanType().default(true),
    includeUtmSource: booleanType().optional(),
    stripFragmentInCanonicalUrl: booleanType().default(true),
    identityDatasourceName: stringType().optional(),
    productAccessGroup: stringType().optional(),
    isUserReferencedByEmail: booleanType().optional(),
    isEntityDatasource: booleanType().default(false),
    isTestDatasource: booleanType().default(false)
  });
  var CustomDatasourceConfig$outboundSchema = objectType({
    name: stringType(),
    displayName: stringType().optional(),
    datasourceCategory: DatasourceCategory$outboundSchema.default("UNCATEGORIZED"),
    urlRegex: stringType().optional(),
    iconUrl: stringType().optional(),
    objectDefinitions: arrayType(ObjectDefinition$outboundSchema).optional(),
    suggestionText: stringType().optional(),
    homeUrl: stringType().optional(),
    crawlerSeedUrls: arrayType(stringType()).optional(),
    iconDarkUrl: stringType().optional(),
    hideBuiltInFacets: arrayType(HideBuiltInFacet$outboundSchema).optional(),
    canonicalizingURLRegex: arrayType(CanonicalizingRegexType$outboundSchema).optional(),
    canonicalizingTitleRegex: arrayType(CanonicalizingRegexType$outboundSchema).optional(),
    redlistTitleRegex: stringType().optional(),
    connectorType: CustomDatasourceConfigConnectorType$outboundSchema.optional(),
    quicklinks: arrayType(Quicklink$outboundSchema).optional(),
    renderConfigPreset: stringType().optional(),
    aliases: arrayType(stringType()).optional(),
    isOnPrem: booleanType().optional(),
    trustUrlRegexForViewActivity: booleanType().default(true),
    includeUtmSource: booleanType().optional(),
    stripFragmentInCanonicalUrl: booleanType().default(true),
    identityDatasourceName: stringType().optional(),
    productAccessGroup: stringType().optional(),
    isUserReferencedByEmail: booleanType().optional(),
    isEntityDatasource: booleanType().default(false),
    isTestDatasource: booleanType().default(false)
  });
  var CustomDatasourceConfig$;
  (function(CustomDatasourceConfig$2) {
    CustomDatasourceConfig$2.inboundSchema = CustomDatasourceConfig$inboundSchema;
    CustomDatasourceConfig$2.outboundSchema = CustomDatasourceConfig$outboundSchema;
  })(CustomDatasourceConfig$ || (CustomDatasourceConfig$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/datasourcemembershipdefinition.js
  var DatasourceMembershipDefinition$inboundSchema = objectType({
    groupName: stringType(),
    memberUserId: stringType().optional(),
    memberGroupName: stringType().optional()
  });
  var DatasourceMembershipDefinition$outboundSchema = objectType({
    groupName: stringType(),
    memberUserId: stringType().optional(),
    memberGroupName: stringType().optional()
  });
  var DatasourceMembershipDefinition$;
  (function(DatasourceMembershipDefinition$2) {
    DatasourceMembershipDefinition$2.inboundSchema = DatasourceMembershipDefinition$inboundSchema;
    DatasourceMembershipDefinition$2.outboundSchema = DatasourceMembershipDefinition$outboundSchema;
  })(DatasourceMembershipDefinition$ || (DatasourceMembershipDefinition$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/datasourceobjecttypedocumentcountentry.js
  var DatasourceObjectTypeDocumentCountEntry$inboundSchema = objectType({
    objectType: stringType().optional(),
    count: numberType().int().optional()
  });
  var DatasourceObjectTypeDocumentCountEntry$outboundSchema = objectType({
    objectType: stringType().optional(),
    count: numberType().int().optional()
  });
  var DatasourceObjectTypeDocumentCountEntry$;
  (function(DatasourceObjectTypeDocumentCountEntry$2) {
    DatasourceObjectTypeDocumentCountEntry$2.inboundSchema = DatasourceObjectTypeDocumentCountEntry$inboundSchema;
    DatasourceObjectTypeDocumentCountEntry$2.outboundSchema = DatasourceObjectTypeDocumentCountEntry$outboundSchema;
  })(DatasourceObjectTypeDocumentCountEntry$ || (DatasourceObjectTypeDocumentCountEntry$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/debugdatasourcestatusidentityresponsecomponent.js
  var DebugDatasourceStatusIdentityResponseComponentCounts$inboundSchema = objectType({
    uploaded: numberType().int().optional()
  });
  var DebugDatasourceStatusIdentityResponseComponentCounts$outboundSchema = objectType({
    uploaded: numberType().int().optional()
  });
  var DebugDatasourceStatusIdentityResponseComponentCounts$;
  (function(DebugDatasourceStatusIdentityResponseComponentCounts$2) {
    DebugDatasourceStatusIdentityResponseComponentCounts$2.inboundSchema = DebugDatasourceStatusIdentityResponseComponentCounts$inboundSchema;
    DebugDatasourceStatusIdentityResponseComponentCounts$2.outboundSchema = DebugDatasourceStatusIdentityResponseComponentCounts$outboundSchema;
  })(DebugDatasourceStatusIdentityResponseComponentCounts$ || (DebugDatasourceStatusIdentityResponseComponentCounts$ = {}));
  var DebugDatasourceStatusIdentityResponseComponent$inboundSchema = objectType({
    bulkUploadHistory: arrayType(BulkUploadHistoryEvent$inboundSchema).optional(),
    counts: lazyType(() => DebugDatasourceStatusIdentityResponseComponentCounts$inboundSchema).optional()
  });
  var DebugDatasourceStatusIdentityResponseComponent$outboundSchema = objectType({
    bulkUploadHistory: arrayType(BulkUploadHistoryEvent$outboundSchema).optional(),
    counts: lazyType(() => DebugDatasourceStatusIdentityResponseComponentCounts$outboundSchema).optional()
  });
  var DebugDatasourceStatusIdentityResponseComponent$;
  (function(DebugDatasourceStatusIdentityResponseComponent$2) {
    DebugDatasourceStatusIdentityResponseComponent$2.inboundSchema = DebugDatasourceStatusIdentityResponseComponent$inboundSchema;
    DebugDatasourceStatusIdentityResponseComponent$2.outboundSchema = DebugDatasourceStatusIdentityResponseComponent$outboundSchema;
  })(DebugDatasourceStatusIdentityResponseComponent$ || (DebugDatasourceStatusIdentityResponseComponent$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/processinghistoryevent.js
  var ProcessingHistoryEvent$inboundSchema = objectType({
    startTime: stringType().optional(),
    endTime: stringType().optional()
  });
  var ProcessingHistoryEvent$outboundSchema = objectType({
    startTime: stringType().optional(),
    endTime: stringType().optional()
  });
  var ProcessingHistoryEvent$;
  (function(ProcessingHistoryEvent$2) {
    ProcessingHistoryEvent$2.inboundSchema = ProcessingHistoryEvent$inboundSchema;
    ProcessingHistoryEvent$2.outboundSchema = ProcessingHistoryEvent$outboundSchema;
  })(ProcessingHistoryEvent$ || (ProcessingHistoryEvent$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/debugdatasourcestatusresponse.js
  var DatasourceVisibility = {
    EnabledForAll: "ENABLED_FOR_ALL",
    EnabledForTestGroup: "ENABLED_FOR_TEST_GROUP",
    NotEnabled: "NOT_ENABLED"
  };
  var DebugDatasourceStatusResponseCounts$inboundSchema = objectType({
    uploaded: arrayType(DatasourceObjectTypeDocumentCountEntry$inboundSchema).optional(),
    indexed: arrayType(DatasourceObjectTypeDocumentCountEntry$inboundSchema).optional()
  });
  var DebugDatasourceStatusResponseCounts$outboundSchema = objectType({
    uploaded: arrayType(DatasourceObjectTypeDocumentCountEntry$outboundSchema).optional(),
    indexed: arrayType(DatasourceObjectTypeDocumentCountEntry$outboundSchema).optional()
  });
  var DebugDatasourceStatusResponseCounts$;
  (function(DebugDatasourceStatusResponseCounts$2) {
    DebugDatasourceStatusResponseCounts$2.inboundSchema = DebugDatasourceStatusResponseCounts$inboundSchema;
    DebugDatasourceStatusResponseCounts$2.outboundSchema = DebugDatasourceStatusResponseCounts$outboundSchema;
  })(DebugDatasourceStatusResponseCounts$ || (DebugDatasourceStatusResponseCounts$ = {}));
  var Documents$inboundSchema = objectType({
    bulkUploadHistory: arrayType(BulkUploadHistoryEvent$inboundSchema).optional(),
    counts: lazyType(() => DebugDatasourceStatusResponseCounts$inboundSchema).optional(),
    processingHistory: arrayType(ProcessingHistoryEvent$inboundSchema).optional()
  });
  var Documents$outboundSchema = objectType({
    bulkUploadHistory: arrayType(BulkUploadHistoryEvent$outboundSchema).optional(),
    counts: lazyType(() => DebugDatasourceStatusResponseCounts$outboundSchema).optional(),
    processingHistory: arrayType(ProcessingHistoryEvent$outboundSchema).optional()
  });
  var Documents$;
  (function(Documents$2) {
    Documents$2.inboundSchema = Documents$inboundSchema;
    Documents$2.outboundSchema = Documents$outboundSchema;
  })(Documents$ || (Documents$ = {}));
  var Identity$inboundSchema = objectType({
    processingHistory: arrayType(ProcessingHistoryEvent$inboundSchema).optional(),
    users: DebugDatasourceStatusIdentityResponseComponent$inboundSchema.optional(),
    groups: DebugDatasourceStatusIdentityResponseComponent$inboundSchema.optional(),
    memberships: DebugDatasourceStatusIdentityResponseComponent$inboundSchema.optional()
  });
  var Identity$outboundSchema = objectType({
    processingHistory: arrayType(ProcessingHistoryEvent$outboundSchema).optional(),
    users: DebugDatasourceStatusIdentityResponseComponent$outboundSchema.optional(),
    groups: DebugDatasourceStatusIdentityResponseComponent$outboundSchema.optional(),
    memberships: DebugDatasourceStatusIdentityResponseComponent$outboundSchema.optional()
  });
  var Identity$;
  (function(Identity$2) {
    Identity$2.inboundSchema = Identity$inboundSchema;
    Identity$2.outboundSchema = Identity$outboundSchema;
  })(Identity$ || (Identity$ = {}));
  var DatasourceVisibility$inboundSchema = nativeEnumType(DatasourceVisibility);
  var DatasourceVisibility$outboundSchema = DatasourceVisibility$inboundSchema;
  var DatasourceVisibility$;
  (function(DatasourceVisibility$2) {
    DatasourceVisibility$2.inboundSchema = DatasourceVisibility$inboundSchema;
    DatasourceVisibility$2.outboundSchema = DatasourceVisibility$outboundSchema;
  })(DatasourceVisibility$ || (DatasourceVisibility$ = {}));
  var DebugDatasourceStatusResponse$inboundSchema = objectType({
    documents: lazyType(() => Documents$inboundSchema).optional(),
    identity: lazyType(() => Identity$inboundSchema).optional(),
    datasourceVisibility: DatasourceVisibility$inboundSchema.optional()
  });
  var DebugDatasourceStatusResponse$outboundSchema = objectType({
    documents: lazyType(() => Documents$outboundSchema).optional(),
    identity: lazyType(() => Identity$outboundSchema).optional(),
    datasourceVisibility: DatasourceVisibility$outboundSchema.optional()
  });
  var DebugDatasourceStatusResponse$;
  (function(DebugDatasourceStatusResponse$2) {
    DebugDatasourceStatusResponse$2.inboundSchema = DebugDatasourceStatusResponse$inboundSchema;
    DebugDatasourceStatusResponse$2.outboundSchema = DebugDatasourceStatusResponse$outboundSchema;
  })(DebugDatasourceStatusResponse$ || (DebugDatasourceStatusResponse$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/debugdocumentrequest.js
  var DebugDocumentRequest$inboundSchema = objectType({
    objectType: stringType(),
    docId: stringType()
  });
  var DebugDocumentRequest$outboundSchema = objectType({
    objectType: stringType(),
    docId: stringType()
  });
  var DebugDocumentRequest$;
  (function(DebugDocumentRequest$2) {
    DebugDocumentRequest$2.inboundSchema = DebugDocumentRequest$inboundSchema;
    DebugDocumentRequest$2.outboundSchema = DebugDocumentRequest$outboundSchema;
  })(DebugDocumentRequest$ || (DebugDocumentRequest$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/documentstatusresponse.js
  var DocumentStatusResponse$inboundSchema = objectType({
    uploadStatus: stringType().optional(),
    lastUploadedAt: stringType().optional(),
    indexingStatus: stringType().optional(),
    lastIndexedAt: stringType().optional(),
    permissionIdentityStatus: stringType().optional()
  });
  var DocumentStatusResponse$outboundSchema = objectType({
    uploadStatus: stringType().optional(),
    lastUploadedAt: stringType().optional(),
    indexingStatus: stringType().optional(),
    lastIndexedAt: stringType().optional(),
    permissionIdentityStatus: stringType().optional()
  });
  var DocumentStatusResponse$;
  (function(DocumentStatusResponse$2) {
    DocumentStatusResponse$2.inboundSchema = DocumentStatusResponse$inboundSchema;
    DocumentStatusResponse$2.outboundSchema = DocumentStatusResponse$outboundSchema;
  })(DocumentStatusResponse$ || (DocumentStatusResponse$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/debugdocumentresponse.js
  var DebugDocumentResponse$inboundSchema = objectType({
    status: DocumentStatusResponse$inboundSchema.optional(),
    uploadedPermissions: DocumentPermissionsDefinition$inboundSchema.optional()
  });
  var DebugDocumentResponse$outboundSchema = objectType({
    status: DocumentStatusResponse$outboundSchema.optional(),
    uploadedPermissions: DocumentPermissionsDefinition$outboundSchema.optional()
  });
  var DebugDocumentResponse$;
  (function(DebugDocumentResponse$2) {
    DebugDocumentResponse$2.inboundSchema = DebugDocumentResponse$inboundSchema;
    DebugDocumentResponse$2.outboundSchema = DebugDocumentResponse$outboundSchema;
  })(DebugDocumentResponse$ || (DebugDocumentResponse$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/debugdocumentsrequest.js
  var DebugDocumentsRequest$inboundSchema = objectType({
    debugDocuments: arrayType(DebugDocumentRequest$inboundSchema)
  });
  var DebugDocumentsRequest$outboundSchema = objectType({
    debugDocuments: arrayType(DebugDocumentRequest$outboundSchema)
  });
  var DebugDocumentsRequest$;
  (function(DebugDocumentsRequest$2) {
    DebugDocumentsRequest$2.inboundSchema = DebugDocumentsRequest$inboundSchema;
    DebugDocumentsRequest$2.outboundSchema = DebugDocumentsRequest$outboundSchema;
  })(DebugDocumentsRequest$ || (DebugDocumentsRequest$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/debugdocumentsresponseitem.js
  var DebugDocumentsResponseItem$inboundSchema = objectType({
    docId: stringType().optional(),
    objectType: stringType().optional(),
    debugInfo: DebugDocumentResponse$inboundSchema.optional()
  });
  var DebugDocumentsResponseItem$outboundSchema = objectType({
    docId: stringType().optional(),
    objectType: stringType().optional(),
    debugInfo: DebugDocumentResponse$outboundSchema.optional()
  });
  var DebugDocumentsResponseItem$;
  (function(DebugDocumentsResponseItem$2) {
    DebugDocumentsResponseItem$2.inboundSchema = DebugDocumentsResponseItem$inboundSchema;
    DebugDocumentsResponseItem$2.outboundSchema = DebugDocumentsResponseItem$outboundSchema;
  })(DebugDocumentsResponseItem$ || (DebugDocumentsResponseItem$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/debugdocumentsresponse.js
  var DebugDocumentsResponse$inboundSchema = objectType({
    documentStatuses: arrayType(DebugDocumentsResponseItem$inboundSchema).optional()
  });
  var DebugDocumentsResponse$outboundSchema = objectType({
    documentStatuses: arrayType(DebugDocumentsResponseItem$outboundSchema).optional()
  });
  var DebugDocumentsResponse$;
  (function(DebugDocumentsResponse$2) {
    DebugDocumentsResponse$2.inboundSchema = DebugDocumentsResponse$inboundSchema;
    DebugDocumentsResponse$2.outboundSchema = DebugDocumentsResponse$outboundSchema;
  })(DebugDocumentsResponse$ || (DebugDocumentsResponse$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/debuguserrequest.js
  var DebugUserRequest$inboundSchema = objectType({
    email: stringType()
  });
  var DebugUserRequest$outboundSchema = objectType({
    email: stringType()
  });
  var DebugUserRequest$;
  (function(DebugUserRequest$2) {
    DebugUserRequest$2.inboundSchema = DebugUserRequest$inboundSchema;
    DebugUserRequest$2.outboundSchema = DebugUserRequest$outboundSchema;
  })(DebugUserRequest$ || (DebugUserRequest$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/uploadstatusenum.js
  var UploadStatusEnum = {
    Uploaded: "UPLOADED",
    NotUploaded: "NOT_UPLOADED",
    StatusUnknown: "STATUS_UNKNOWN"
  };
  var UploadStatusEnum$inboundSchema = nativeEnumType(UploadStatusEnum);
  var UploadStatusEnum$outboundSchema = UploadStatusEnum$inboundSchema;
  var UploadStatusEnum$;
  (function(UploadStatusEnum$2) {
    UploadStatusEnum$2.inboundSchema = UploadStatusEnum$inboundSchema;
    UploadStatusEnum$2.outboundSchema = UploadStatusEnum$outboundSchema;
  })(UploadStatusEnum$ || (UploadStatusEnum$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/userstatusresponse.js
  var UserStatusResponse$inboundSchema = objectType({
    isActiveUser: booleanType().optional(),
    uploadStatus: UploadStatusEnum$inboundSchema.optional(),
    lastUploadedAt: stringType().optional()
  });
  var UserStatusResponse$outboundSchema = objectType({
    isActiveUser: booleanType().optional(),
    uploadStatus: UploadStatusEnum$outboundSchema.optional(),
    lastUploadedAt: stringType().optional()
  });
  var UserStatusResponse$;
  (function(UserStatusResponse$2) {
    UserStatusResponse$2.inboundSchema = UserStatusResponse$inboundSchema;
    UserStatusResponse$2.outboundSchema = UserStatusResponse$outboundSchema;
  })(UserStatusResponse$ || (UserStatusResponse$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/debuguserresponse.js
  var DebugUserResponse$inboundSchema = objectType({
    status: UserStatusResponse$inboundSchema.optional(),
    uploadedGroups: arrayType(DatasourceGroupDefinition$inboundSchema).optional()
  });
  var DebugUserResponse$outboundSchema = objectType({
    status: UserStatusResponse$outboundSchema.optional(),
    uploadedGroups: arrayType(DatasourceGroupDefinition$outboundSchema).optional()
  });
  var DebugUserResponse$;
  (function(DebugUserResponse$2) {
    DebugUserResponse$2.inboundSchema = DebugUserResponse$inboundSchema;
    DebugUserResponse$2.outboundSchema = DebugUserResponse$outboundSchema;
  })(DebugUserResponse$ || (DebugUserResponse$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/deleteannouncementrequest.js
  var DeleteAnnouncementRequest$inboundSchema = objectType({
    id: numberType().int()
  });
  var DeleteAnnouncementRequest$outboundSchema = objectType({
    id: numberType().int()
  });
  var DeleteAnnouncementRequest$;
  (function(DeleteAnnouncementRequest$2) {
    DeleteAnnouncementRequest$2.inboundSchema = DeleteAnnouncementRequest$inboundSchema;
    DeleteAnnouncementRequest$2.outboundSchema = DeleteAnnouncementRequest$outboundSchema;
  })(DeleteAnnouncementRequest$ || (DeleteAnnouncementRequest$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/deleteanswerrequest.js
  var DeleteAnswerRequest$inboundSchema = objectType({
    id: numberType().int(),
    docId: stringType().optional()
  });
  var DeleteAnswerRequest$outboundSchema = objectType({
    id: numberType().int(),
    docId: stringType().optional()
  });
  var DeleteAnswerRequest$;
  (function(DeleteAnswerRequest$2) {
    DeleteAnswerRequest$2.inboundSchema = DeleteAnswerRequest$inboundSchema;
    DeleteAnswerRequest$2.outboundSchema = DeleteAnswerRequest$outboundSchema;
  })(DeleteAnswerRequest$ || (DeleteAnswerRequest$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/deletechatfilesrequest.js
  var DeleteChatFilesRequest$inboundSchema = objectType({
    fileIds: arrayType(stringType())
  });
  var DeleteChatFilesRequest$outboundSchema = objectType({
    fileIds: arrayType(stringType())
  });
  var DeleteChatFilesRequest$;
  (function(DeleteChatFilesRequest$2) {
    DeleteChatFilesRequest$2.inboundSchema = DeleteChatFilesRequest$inboundSchema;
    DeleteChatFilesRequest$2.outboundSchema = DeleteChatFilesRequest$outboundSchema;
  })(DeleteChatFilesRequest$ || (DeleteChatFilesRequest$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/deletechatsrequest.js
  var DeleteChatsRequest$inboundSchema = objectType({
    ids: arrayType(stringType())
  });
  var DeleteChatsRequest$outboundSchema = objectType({
    ids: arrayType(stringType())
  });
  var DeleteChatsRequest$;
  (function(DeleteChatsRequest$2) {
    DeleteChatsRequest$2.inboundSchema = DeleteChatsRequest$inboundSchema;
    DeleteChatsRequest$2.outboundSchema = DeleteChatsRequest$outboundSchema;
  })(DeleteChatsRequest$ || (DeleteChatsRequest$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/deletecollectionitemrequest.js
  var DeleteCollectionItemRequest$inboundSchema = objectType({
    collectionId: numberType(),
    itemId: stringType(),
    documentId: stringType().optional()
  });
  var DeleteCollectionItemRequest$outboundSchema = objectType({
    collectionId: numberType(),
    itemId: stringType(),
    documentId: stringType().optional()
  });
  var DeleteCollectionItemRequest$;
  (function(DeleteCollectionItemRequest$2) {
    DeleteCollectionItemRequest$2.inboundSchema = DeleteCollectionItemRequest$inboundSchema;
    DeleteCollectionItemRequest$2.outboundSchema = DeleteCollectionItemRequest$outboundSchema;
  })(DeleteCollectionItemRequest$ || (DeleteCollectionItemRequest$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/deletecollectionitemresponse.js
  var DeleteCollectionItemResponse$inboundSchema = objectType({
    collection: Collection$inboundSchema.optional()
  });
  var DeleteCollectionItemResponse$outboundSchema = objectType({
    collection: Collection$outboundSchema.optional()
  });
  var DeleteCollectionItemResponse$;
  (function(DeleteCollectionItemResponse$2) {
    DeleteCollectionItemResponse$2.inboundSchema = DeleteCollectionItemResponse$inboundSchema;
    DeleteCollectionItemResponse$2.outboundSchema = DeleteCollectionItemResponse$outboundSchema;
  })(DeleteCollectionItemResponse$ || (DeleteCollectionItemResponse$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/deletecollectionrequest.js
  var DeleteCollectionRequest$inboundSchema = objectType({
    ids: arrayType(numberType().int()),
    allowedDatasource: stringType().optional()
  });
  var DeleteCollectionRequest$outboundSchema = objectType({
    ids: arrayType(numberType().int()),
    allowedDatasource: stringType().optional()
  });
  var DeleteCollectionRequest$;
  (function(DeleteCollectionRequest$2) {
    DeleteCollectionRequest$2.inboundSchema = DeleteCollectionRequest$inboundSchema;
    DeleteCollectionRequest$2.outboundSchema = DeleteCollectionRequest$outboundSchema;
  })(DeleteCollectionRequest$ || (DeleteCollectionRequest$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/deletedocumentrequest.js
  var DeleteDocumentRequest$inboundSchema = objectType({
    version: numberType().int().optional(),
    datasource: stringType(),
    objectType: stringType(),
    id: stringType()
  });
  var DeleteDocumentRequest$outboundSchema = objectType({
    version: numberType().int().optional(),
    datasource: stringType(),
    objectType: stringType(),
    id: stringType()
  });
  var DeleteDocumentRequest$;
  (function(DeleteDocumentRequest$2) {
    DeleteDocumentRequest$2.inboundSchema = DeleteDocumentRequest$inboundSchema;
    DeleteDocumentRequest$2.outboundSchema = DeleteDocumentRequest$outboundSchema;
  })(DeleteDocumentRequest$ || (DeleteDocumentRequest$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/deleteemployeerequest.js
  var DeleteEmployeeRequest$inboundSchema = objectType({
    version: numberType().int().optional(),
    employeeEmail: stringType()
  });
  var DeleteEmployeeRequest$outboundSchema = objectType({
    version: numberType().int().optional(),
    employeeEmail: stringType()
  });
  var DeleteEmployeeRequest$;
  (function(DeleteEmployeeRequest$2) {
    DeleteEmployeeRequest$2.inboundSchema = DeleteEmployeeRequest$inboundSchema;
    DeleteEmployeeRequest$2.outboundSchema = DeleteEmployeeRequest$outboundSchema;
  })(DeleteEmployeeRequest$ || (DeleteEmployeeRequest$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/deletegrouprequest.js
  var DeleteGroupRequest$inboundSchema = objectType({
    version: numberType().int().optional(),
    datasource: stringType(),
    groupName: stringType()
  });
  var DeleteGroupRequest$outboundSchema = objectType({
    version: numberType().int().optional(),
    datasource: stringType(),
    groupName: stringType()
  });
  var DeleteGroupRequest$;
  (function(DeleteGroupRequest$2) {
    DeleteGroupRequest$2.inboundSchema = DeleteGroupRequest$inboundSchema;
    DeleteGroupRequest$2.outboundSchema = DeleteGroupRequest$outboundSchema;
  })(DeleteGroupRequest$ || (DeleteGroupRequest$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/deletemembershiprequest.js
  var DeleteMembershipRequest$inboundSchema = objectType({
    version: numberType().int().optional(),
    datasource: stringType(),
    membership: DatasourceMembershipDefinition$inboundSchema
  });
  var DeleteMembershipRequest$outboundSchema = objectType({
    version: numberType().int().optional(),
    datasource: stringType(),
    membership: DatasourceMembershipDefinition$outboundSchema
  });
  var DeleteMembershipRequest$;
  (function(DeleteMembershipRequest$2) {
    DeleteMembershipRequest$2.inboundSchema = DeleteMembershipRequest$inboundSchema;
    DeleteMembershipRequest$2.outboundSchema = DeleteMembershipRequest$outboundSchema;
  })(DeleteMembershipRequest$ || (DeleteMembershipRequest$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/deleteshortcutrequest.js
  var DeleteShortcutRequest$inboundSchema = objectType({
    id: numberType().int()
  });
  var DeleteShortcutRequest$outboundSchema = objectType({
    id: numberType().int()
  });
  var DeleteShortcutRequest$;
  (function(DeleteShortcutRequest$2) {
    DeleteShortcutRequest$2.inboundSchema = DeleteShortcutRequest$inboundSchema;
    DeleteShortcutRequest$2.outboundSchema = DeleteShortcutRequest$outboundSchema;
  })(DeleteShortcutRequest$ || (DeleteShortcutRequest$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/deleteteamrequest.js
  var DeleteTeamRequest$inboundSchema = objectType({
    id: stringType()
  });
  var DeleteTeamRequest$outboundSchema = objectType({
    id: stringType()
  });
  var DeleteTeamRequest$;
  (function(DeleteTeamRequest$2) {
    DeleteTeamRequest$2.inboundSchema = DeleteTeamRequest$inboundSchema;
    DeleteTeamRequest$2.outboundSchema = DeleteTeamRequest$outboundSchema;
  })(DeleteTeamRequest$ || (DeleteTeamRequest$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/deleteuserrequest.js
  var DeleteUserRequest$inboundSchema = objectType({
    version: numberType().int().optional(),
    datasource: stringType(),
    email: stringType()
  });
  var DeleteUserRequest$outboundSchema = objectType({
    version: numberType().int().optional(),
    datasource: stringType(),
    email: stringType()
  });
  var DeleteUserRequest$;
  (function(DeleteUserRequest$2) {
    DeleteUserRequest$2.inboundSchema = DeleteUserRequest$inboundSchema;
    DeleteUserRequest$2.outboundSchema = DeleteUserRequest$outboundSchema;
  })(DeleteUserRequest$ || (DeleteUserRequest$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/updatetype.js
  var UpdateType = {
    Actionable: "ACTIONABLE",
    Informative: "INFORMATIVE"
  };
  var UpdateType$inboundSchema = nativeEnumType(UpdateType);
  var UpdateType$outboundSchema = UpdateType$inboundSchema;
  var UpdateType$;
  (function(UpdateType$2) {
    UpdateType$2.inboundSchema = UpdateType$inboundSchema;
    UpdateType$2.outboundSchema = UpdateType$outboundSchema;
  })(UpdateType$ || (UpdateType$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/digestupdate.js
  var DigestUpdate$inboundSchema = objectType({
    url: stringType().optional(),
    title: stringType().optional(),
    datasource: stringType().optional(),
    summary: stringType().optional(),
    type: UpdateType$inboundSchema.optional()
  });
  var DigestUpdate$outboundSchema = objectType({
    url: stringType().optional(),
    title: stringType().optional(),
    datasource: stringType().optional(),
    summary: stringType().optional(),
    type: UpdateType$outboundSchema.optional()
  });
  var DigestUpdate$;
  (function(DigestUpdate$2) {
    DigestUpdate$2.inboundSchema = DigestUpdate$inboundSchema;
    DigestUpdate$2.outboundSchema = DigestUpdate$outboundSchema;
  })(DigestUpdate$ || (DigestUpdate$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/sectiontype.js
  var SectionType = {
    Channel: "CHANNEL",
    Mentions: "MENTIONS",
    Topic: "TOPIC"
  };
  var SectionType$inboundSchema = nativeEnumType(SectionType);
  var SectionType$outboundSchema = SectionType$inboundSchema;
  var SectionType$;
  (function(SectionType$2) {
    SectionType$2.inboundSchema = SectionType$inboundSchema;
    SectionType$2.outboundSchema = SectionType$outboundSchema;
  })(SectionType$ || (SectionType$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/digestsection.js
  var DigestSection$inboundSchema = objectType({
    id: stringType(),
    type: SectionType$inboundSchema,
    displayName: stringType().optional(),
    channelName: stringType().optional(),
    channelType: stringType().optional(),
    instanceId: stringType().optional(),
    url: stringType().optional(),
    updates: arrayType(DigestUpdate$inboundSchema)
  });
  var DigestSection$outboundSchema = objectType({
    id: stringType(),
    type: SectionType$outboundSchema,
    displayName: stringType().optional(),
    channelName: stringType().optional(),
    channelType: stringType().optional(),
    instanceId: stringType().optional(),
    url: stringType().optional(),
    updates: arrayType(DigestUpdate$outboundSchema)
  });
  var DigestSection$;
  (function(DigestSection$2) {
    DigestSection$2.inboundSchema = DigestSection$inboundSchema;
    DigestSection$2.outboundSchema = DigestSection$outboundSchema;
  })(DigestSection$ || (DigestSection$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/digest.js
  var Digest$inboundSchema = objectType({
    podcastFileId: stringType().optional(),
    podcastDuration: numberType().optional(),
    digestDate: stringType().optional(),
    sections: arrayType(DigestSection$inboundSchema).optional()
  });
  var Digest$outboundSchema = objectType({
    podcastFileId: stringType().optional(),
    podcastDuration: numberType().optional(),
    digestDate: stringType().optional(),
    sections: arrayType(DigestSection$outboundSchema).optional()
  });
  var Digest$;
  (function(Digest$2) {
    Digest$2.inboundSchema = Digest$inboundSchema;
    Digest$2.outboundSchema = Digest$outboundSchema;
  })(Digest$ || (Digest$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/displayablelistitemuiconfig.js
  var DisplayableListItemUIConfig$inboundSchema = objectType({
    showNewIndicator: booleanType().optional()
  });
  var DisplayableListItemUIConfig$outboundSchema = objectType({
    showNewIndicator: booleanType().optional()
  });
  var DisplayableListItemUIConfig$;
  (function(DisplayableListItemUIConfig$2) {
    DisplayableListItemUIConfig$2.inboundSchema = DisplayableListItemUIConfig$inboundSchema;
    DisplayableListItemUIConfig$2.outboundSchema = DisplayableListItemUIConfig$outboundSchema;
  })(DisplayableListItemUIConfig$ || (DisplayableListItemUIConfig$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/dlpsimpleresult.js
  var DlpSimpleResult = {
    Success: "SUCCESS",
    Failure: "FAILURE"
  };
  var DlpSimpleResult$inboundSchema = nativeEnumType(DlpSimpleResult);
  var DlpSimpleResult$outboundSchema = DlpSimpleResult$inboundSchema;
  var DlpSimpleResult$;
  (function(DlpSimpleResult$2) {
    DlpSimpleResult$2.inboundSchema = DlpSimpleResult$inboundSchema;
    DlpSimpleResult$2.outboundSchema = DlpSimpleResult$outboundSchema;
  })(DlpSimpleResult$ || (DlpSimpleResult$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/documentorerrorunion.js
  var DocumentOrError$inboundSchema = objectType({
    error: stringType().optional()
  });
  var DocumentOrError$outboundSchema = objectType({
    error: stringType().optional()
  });
  var DocumentOrError$;
  (function(DocumentOrError$2) {
    DocumentOrError$2.inboundSchema = DocumentOrError$inboundSchema;
    DocumentOrError$2.outboundSchema = DocumentOrError$outboundSchema;
  })(DocumentOrError$ || (DocumentOrError$ = {}));
  var DocumentOrErrorUnion$inboundSchema = unionType([
    Document$inboundSchema,
    lazyType(() => DocumentOrError$inboundSchema)
  ]);
  var DocumentOrErrorUnion$outboundSchema = unionType([
    Document$outboundSchema,
    lazyType(() => DocumentOrError$outboundSchema)
  ]);
  var DocumentOrErrorUnion$;
  (function(DocumentOrErrorUnion$2) {
    DocumentOrErrorUnion$2.inboundSchema = DocumentOrErrorUnion$inboundSchema;
    DocumentOrErrorUnion$2.outboundSchema = DocumentOrErrorUnion$outboundSchema;
  })(DocumentOrErrorUnion$ || (DocumentOrErrorUnion$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/documentvisibilityoverride.js
  var DocumentVisibilityOverrideOverride = {
    None: "NONE",
    HideFromAll: "HIDE_FROM_ALL",
    HideFromGroups: "HIDE_FROM_GROUPS",
    HideFromAllExceptOwner: "HIDE_FROM_ALL_EXCEPT_OWNER"
  };
  var DocumentVisibilityOverrideOverride$inboundSchema = nativeEnumType(DocumentVisibilityOverrideOverride);
  var DocumentVisibilityOverrideOverride$outboundSchema = DocumentVisibilityOverrideOverride$inboundSchema;
  var DocumentVisibilityOverrideOverride$;
  (function(DocumentVisibilityOverrideOverride$2) {
    DocumentVisibilityOverrideOverride$2.inboundSchema = DocumentVisibilityOverrideOverride$inboundSchema;
    DocumentVisibilityOverrideOverride$2.outboundSchema = DocumentVisibilityOverrideOverride$outboundSchema;
  })(DocumentVisibilityOverrideOverride$ || (DocumentVisibilityOverrideOverride$ = {}));
  var DocumentVisibilityOverride$inboundSchema = objectType({
    docId: stringType().optional(),
    override: DocumentVisibilityOverrideOverride$inboundSchema.optional()
  });
  var DocumentVisibilityOverride$outboundSchema = objectType({
    docId: stringType().optional(),
    override: DocumentVisibilityOverrideOverride$outboundSchema.optional()
  });
  var DocumentVisibilityOverride$;
  (function(DocumentVisibilityOverride$2) {
    DocumentVisibilityOverride$2.inboundSchema = DocumentVisibilityOverride$inboundSchema;
    DocumentVisibilityOverride$2.outboundSchema = DocumentVisibilityOverride$outboundSchema;
  })(DocumentVisibilityOverride$ || (DocumentVisibilityOverride$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/documentvisibilityupdateresult.js
  var DocumentVisibilityUpdateResultOverride = {
    None: "NONE",
    HideFromAll: "HIDE_FROM_ALL",
    HideFromGroups: "HIDE_FROM_GROUPS",
    HideFromAllExceptOwner: "HIDE_FROM_ALL_EXCEPT_OWNER"
  };
  var DocumentVisibilityUpdateResultOverride$inboundSchema = nativeEnumType(DocumentVisibilityUpdateResultOverride);
  var DocumentVisibilityUpdateResultOverride$outboundSchema = DocumentVisibilityUpdateResultOverride$inboundSchema;
  var DocumentVisibilityUpdateResultOverride$;
  (function(DocumentVisibilityUpdateResultOverride$2) {
    DocumentVisibilityUpdateResultOverride$2.inboundSchema = DocumentVisibilityUpdateResultOverride$inboundSchema;
    DocumentVisibilityUpdateResultOverride$2.outboundSchema = DocumentVisibilityUpdateResultOverride$outboundSchema;
  })(DocumentVisibilityUpdateResultOverride$ || (DocumentVisibilityUpdateResultOverride$ = {}));
  var DocumentVisibilityUpdateResult$inboundSchema = objectType({
    docId: stringType().optional(),
    override: DocumentVisibilityUpdateResultOverride$inboundSchema.optional(),
    success: booleanType().optional()
  });
  var DocumentVisibilityUpdateResult$outboundSchema = objectType({
    docId: stringType().optional(),
    override: DocumentVisibilityUpdateResultOverride$outboundSchema.optional(),
    success: booleanType().optional()
  });
  var DocumentVisibilityUpdateResult$;
  (function(DocumentVisibilityUpdateResult$2) {
    DocumentVisibilityUpdateResult$2.inboundSchema = DocumentVisibilityUpdateResult$inboundSchema;
    DocumentVisibilityUpdateResult$2.outboundSchema = DocumentVisibilityUpdateResult$outboundSchema;
  })(DocumentVisibilityUpdateResult$ || (DocumentVisibilityUpdateResult$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/editanswerrequest.js
  var EditAnswerRequestSourceType = {
    Document: "DOCUMENT",
    Assistant: "ASSISTANT"
  };
  var EditAnswerRequestSourceType$inboundSchema = nativeEnumType(EditAnswerRequestSourceType);
  var EditAnswerRequestSourceType$outboundSchema = EditAnswerRequestSourceType$inboundSchema;
  var EditAnswerRequestSourceType$;
  (function(EditAnswerRequestSourceType$2) {
    EditAnswerRequestSourceType$2.inboundSchema = EditAnswerRequestSourceType$inboundSchema;
    EditAnswerRequestSourceType$2.outboundSchema = EditAnswerRequestSourceType$outboundSchema;
  })(EditAnswerRequestSourceType$ || (EditAnswerRequestSourceType$ = {}));
  var EditAnswerRequest$inboundSchema = objectType({
    id: numberType().int(),
    docId: stringType().optional(),
    question: stringType().optional(),
    questionVariations: arrayType(stringType()).optional(),
    bodyText: stringType().optional(),
    boardId: numberType().int().optional(),
    audienceFilters: arrayType(FacetFilter$inboundSchema).optional(),
    addedRoles: arrayType(UserRoleSpecification$inboundSchema).optional(),
    removedRoles: arrayType(UserRoleSpecification$inboundSchema).optional(),
    roles: arrayType(UserRoleSpecification$inboundSchema).optional(),
    sourceDocumentSpec: DocumentSpecUnion$inboundSchema.optional(),
    sourceType: EditAnswerRequestSourceType$inboundSchema.optional(),
    addedCollections: arrayType(numberType().int()).optional(),
    removedCollections: arrayType(numberType().int()).optional(),
    combinedAnswerText: StructuredTextMutableProperties$inboundSchema.optional()
  });
  var EditAnswerRequest$outboundSchema = objectType({
    id: numberType().int(),
    docId: stringType().optional(),
    question: stringType().optional(),
    questionVariations: arrayType(stringType()).optional(),
    bodyText: stringType().optional(),
    boardId: numberType().int().optional(),
    audienceFilters: arrayType(FacetFilter$outboundSchema).optional(),
    addedRoles: arrayType(UserRoleSpecification$outboundSchema).optional(),
    removedRoles: arrayType(UserRoleSpecification$outboundSchema).optional(),
    roles: arrayType(UserRoleSpecification$outboundSchema).optional(),
    sourceDocumentSpec: DocumentSpecUnion$outboundSchema.optional(),
    sourceType: EditAnswerRequestSourceType$outboundSchema.optional(),
    addedCollections: arrayType(numberType().int()).optional(),
    removedCollections: arrayType(numberType().int()).optional(),
    combinedAnswerText: StructuredTextMutableProperties$outboundSchema.optional()
  });
  var EditAnswerRequest$;
  (function(EditAnswerRequest$2) {
    EditAnswerRequest$2.inboundSchema = EditAnswerRequest$inboundSchema;
    EditAnswerRequest$2.outboundSchema = EditAnswerRequest$outboundSchema;
  })(EditAnswerRequest$ || (EditAnswerRequest$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/editcollectionitemrequest.js
  var EditCollectionItemRequest$inboundSchema = objectType({
    name: stringType().optional(),
    description: stringType().optional(),
    icon: stringType().optional(),
    collectionId: numberType().int(),
    itemId: stringType()
  });
  var EditCollectionItemRequest$outboundSchema = objectType({
    name: stringType().optional(),
    description: stringType().optional(),
    icon: stringType().optional(),
    collectionId: numberType().int(),
    itemId: stringType()
  });
  var EditCollectionItemRequest$;
  (function(EditCollectionItemRequest$2) {
    EditCollectionItemRequest$2.inboundSchema = EditCollectionItemRequest$inboundSchema;
    EditCollectionItemRequest$2.outboundSchema = EditCollectionItemRequest$outboundSchema;
  })(EditCollectionItemRequest$ || (EditCollectionItemRequest$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/editcollectionitemresponse.js
  var EditCollectionItemResponse$inboundSchema = objectType({
    collection: Collection$inboundSchema.optional()
  });
  var EditCollectionItemResponse$outboundSchema = objectType({
    collection: Collection$outboundSchema.optional()
  });
  var EditCollectionItemResponse$;
  (function(EditCollectionItemResponse$2) {
    EditCollectionItemResponse$2.inboundSchema = EditCollectionItemResponse$inboundSchema;
    EditCollectionItemResponse$2.outboundSchema = EditCollectionItemResponse$outboundSchema;
  })(EditCollectionItemResponse$ || (EditCollectionItemResponse$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/editcollectionrequest.js
  var EditCollectionRequest$inboundSchema = objectType({
    name: stringType(),
    description: stringType().optional(),
    addedRoles: arrayType(UserRoleSpecification$inboundSchema).optional(),
    removedRoles: arrayType(UserRoleSpecification$inboundSchema).optional(),
    audienceFilters: arrayType(FacetFilter$inboundSchema).optional(),
    icon: stringType().optional(),
    adminLocked: booleanType().optional(),
    parentId: numberType().int().optional(),
    thumbnail: Thumbnail$inboundSchema.optional(),
    allowedDatasource: stringType().optional(),
    id: numberType().int()
  });
  var EditCollectionRequest$outboundSchema = objectType({
    name: stringType(),
    description: stringType().optional(),
    addedRoles: arrayType(UserRoleSpecification$outboundSchema).optional(),
    removedRoles: arrayType(UserRoleSpecification$outboundSchema).optional(),
    audienceFilters: arrayType(FacetFilter$outboundSchema).optional(),
    icon: stringType().optional(),
    adminLocked: booleanType().optional(),
    parentId: numberType().int().optional(),
    thumbnail: Thumbnail$outboundSchema.optional(),
    allowedDatasource: stringType().optional(),
    id: numberType().int()
  });
  var EditCollectionRequest$;
  (function(EditCollectionRequest$2) {
    EditCollectionRequest$2.inboundSchema = EditCollectionRequest$inboundSchema;
    EditCollectionRequest$2.outboundSchema = EditCollectionRequest$outboundSchema;
  })(EditCollectionRequest$ || (EditCollectionRequest$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/editcollectionresponse.js
  var EditCollectionResponseErrorCode = {
    NameExists: "NAME_EXISTS",
    NotFound: "NOT_FOUND",
    CollectionPinned: "COLLECTION_PINNED",
    ConcurrentHierarchyEdit: "CONCURRENT_HIERARCHY_EDIT",
    HeightViolation: "HEIGHT_VIOLATION",
    WidthViolation: "WIDTH_VIOLATION",
    NoPermissions: "NO_PERMISSIONS"
  };
  var EditCollectionResponseErrorCode$inboundSchema = nativeEnumType(EditCollectionResponseErrorCode);
  var EditCollectionResponseErrorCode$outboundSchema = EditCollectionResponseErrorCode$inboundSchema;
  var EditCollectionResponseErrorCode$;
  (function(EditCollectionResponseErrorCode$2) {
    EditCollectionResponseErrorCode$2.inboundSchema = EditCollectionResponseErrorCode$inboundSchema;
    EditCollectionResponseErrorCode$2.outboundSchema = EditCollectionResponseErrorCode$outboundSchema;
  })(EditCollectionResponseErrorCode$ || (EditCollectionResponseErrorCode$ = {}));
  var EditCollectionResponse$inboundSchema = objectType({
    name: stringType(),
    description: stringType(),
    addedRoles: arrayType(UserRoleSpecification$inboundSchema).optional(),
    removedRoles: arrayType(UserRoleSpecification$inboundSchema).optional(),
    audienceFilters: arrayType(FacetFilter$inboundSchema).optional(),
    icon: stringType().optional(),
    adminLocked: booleanType().optional(),
    parentId: numberType().int().optional(),
    thumbnail: Thumbnail$inboundSchema.optional(),
    allowedDatasource: stringType().optional(),
    permissions: ObjectPermissions$inboundSchema.optional(),
    id: numberType().int(),
    createTime: stringType().datetime({ offset: true }).transform((v) => new Date(v)).optional(),
    updateTime: stringType().datetime({ offset: true }).transform((v) => new Date(v)).optional(),
    creator: Person$inboundSchema.optional(),
    updatedBy: Person$inboundSchema.optional(),
    itemCount: numberType().int().optional(),
    childCount: numberType().int().optional(),
    items: arrayType(CollectionItem$inboundSchema).optional(),
    pinMetadata: CollectionPinnedMetadata$inboundSchema.optional(),
    shortcuts: arrayType(stringType()).optional(),
    children: arrayType(Collection$inboundSchema).optional(),
    roles: arrayType(UserRoleSpecification$inboundSchema).optional(),
    errorCode: EditCollectionResponseErrorCode$inboundSchema,
    collection: Collection$inboundSchema.optional(),
    error: CollectionError$inboundSchema.optional()
  });
  var EditCollectionResponse$outboundSchema = objectType({
    name: stringType(),
    description: stringType(),
    addedRoles: arrayType(UserRoleSpecification$outboundSchema).optional(),
    removedRoles: arrayType(UserRoleSpecification$outboundSchema).optional(),
    audienceFilters: arrayType(FacetFilter$outboundSchema).optional(),
    icon: stringType().optional(),
    adminLocked: booleanType().optional(),
    parentId: numberType().int().optional(),
    thumbnail: Thumbnail$outboundSchema.optional(),
    allowedDatasource: stringType().optional(),
    permissions: ObjectPermissions$outboundSchema.optional(),
    id: numberType().int(),
    createTime: dateType().transform((v) => v.toISOString()).optional(),
    updateTime: dateType().transform((v) => v.toISOString()).optional(),
    creator: Person$outboundSchema.optional(),
    updatedBy: Person$outboundSchema.optional(),
    itemCount: numberType().int().optional(),
    childCount: numberType().int().optional(),
    items: arrayType(CollectionItem$outboundSchema).optional(),
    pinMetadata: CollectionPinnedMetadata$outboundSchema.optional(),
    shortcuts: arrayType(stringType()).optional(),
    children: arrayType(Collection$outboundSchema).optional(),
    roles: arrayType(UserRoleSpecification$outboundSchema).optional(),
    errorCode: EditCollectionResponseErrorCode$outboundSchema,
    collection: Collection$outboundSchema.optional(),
    error: CollectionError$outboundSchema.optional()
  });
  var EditCollectionResponse$;
  (function(EditCollectionResponse$2) {
    EditCollectionResponse$2.inboundSchema = EditCollectionResponse$inboundSchema;
    EditCollectionResponse$2.outboundSchema = EditCollectionResponse$outboundSchema;
  })(EditCollectionResponse$ || (EditCollectionResponse$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/editpinrequest.js
  var EditPinRequest$inboundSchema = objectType({
    queries: arrayType(stringType()).optional(),
    audienceFilters: arrayType(FacetFilter$inboundSchema).optional(),
    id: stringType().optional()
  });
  var EditPinRequest$outboundSchema = objectType({
    queries: arrayType(stringType()).optional(),
    audienceFilters: arrayType(FacetFilter$outboundSchema).optional(),
    id: stringType().optional()
  });
  var EditPinRequest$;
  (function(EditPinRequest$2) {
    EditPinRequest$2.inboundSchema = EditPinRequest$inboundSchema;
    EditPinRequest$2.outboundSchema = EditPinRequest$outboundSchema;
  })(EditPinRequest$ || (EditPinRequest$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/entitiessortorder.js
  var EntitiesSortOrder = {
    EntityName: "ENTITY_NAME",
    FirstName: "FIRST_NAME",
    LastName: "LAST_NAME",
    OrgSizeCount: "ORG_SIZE_COUNT",
    StartDate: "START_DATE",
    TeamSize: "TEAM_SIZE",
    Relevance: "RELEVANCE"
  };
  var EntitiesSortOrder$inboundSchema = nativeEnumType(EntitiesSortOrder);
  var EntitiesSortOrder$outboundSchema = EntitiesSortOrder$inboundSchema;
  var EntitiesSortOrder$;
  (function(EntitiesSortOrder$2) {
    EntitiesSortOrder$2.inboundSchema = EntitiesSortOrder$inboundSchema;
    EntitiesSortOrder$2.outboundSchema = EntitiesSortOrder$outboundSchema;
  })(EntitiesSortOrder$ || (EntitiesSortOrder$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/facetvalue.js
  var FacetValue$inboundSchema = objectType({
    stringValue: stringType().optional(),
    integerValue: numberType().int().optional(),
    displayLabel: stringType().optional(),
    iconConfig: IconConfig$inboundSchema.optional()
  });
  var FacetValue$outboundSchema = objectType({
    stringValue: stringType().optional(),
    integerValue: numberType().int().optional(),
    displayLabel: stringType().optional(),
    iconConfig: IconConfig$outboundSchema.optional()
  });
  var FacetValue$;
  (function(FacetValue$2) {
    FacetValue$2.inboundSchema = FacetValue$inboundSchema;
    FacetValue$2.outboundSchema = FacetValue$outboundSchema;
  })(FacetValue$ || (FacetValue$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/facetbucket.js
  var FacetBucket$inboundSchema = objectType({
    count: numberType().int().optional(),
    datasource: stringType().optional(),
    percentage: numberType().int().optional(),
    value: FacetValue$inboundSchema.optional()
  });
  var FacetBucket$outboundSchema = objectType({
    count: numberType().int().optional(),
    datasource: stringType().optional(),
    percentage: numberType().int().optional(),
    value: FacetValue$outboundSchema.optional()
  });
  var FacetBucket$;
  (function(FacetBucket$2) {
    FacetBucket$2.inboundSchema = FacetBucket$inboundSchema;
    FacetBucket$2.outboundSchema = FacetBucket$outboundSchema;
  })(FacetBucket$ || (FacetBucket$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/facetresult.js
  var FacetResult$inboundSchema = objectType({
    sourceName: stringType().optional(),
    operatorName: stringType().optional(),
    buckets: arrayType(FacetBucket$inboundSchema).optional(),
    hasMoreBuckets: booleanType().optional(),
    groupName: stringType().optional()
  });
  var FacetResult$outboundSchema = objectType({
    sourceName: stringType().optional(),
    operatorName: stringType().optional(),
    buckets: arrayType(FacetBucket$outboundSchema).optional(),
    hasMoreBuckets: booleanType().optional(),
    groupName: stringType().optional()
  });
  var FacetResult$;
  (function(FacetResult$2) {
    FacetResult$2.inboundSchema = FacetResult$inboundSchema;
    FacetResult$2.outboundSchema = FacetResult$outboundSchema;
  })(FacetResult$ || (FacetResult$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/ugctype.js
  var UgcType = {
    AnnouncementsType: "ANNOUNCEMENTS_TYPE",
    AnswersType: "ANSWERS_TYPE",
    CollectionsType: "COLLECTIONS_TYPE",
    ShortcutsType: "SHORTCUTS_TYPE",
    WorkflowsType: "WORKFLOWS_TYPE",
    PromptTemplatesType: "PROMPT_TEMPLATES_TYPE"
  };
  var UgcType$inboundSchema = nativeEnumType(UgcType);
  var UgcType$outboundSchema = UgcType$inboundSchema;
  var UgcType$;
  (function(UgcType$2) {
    UgcType$2.inboundSchema = UgcType$inboundSchema;
    UgcType$2.outboundSchema = UgcType$outboundSchema;
  })(UgcType$ || (UgcType$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/favoriteinfo.js
  var FavoriteInfo$inboundSchema = objectType({
    ugcType: UgcType$inboundSchema.optional(),
    id: stringType().optional(),
    count: numberType().int().optional(),
    favoritedByUser: booleanType().optional()
  });
  var FavoriteInfo$outboundSchema = objectType({
    ugcType: UgcType$outboundSchema.optional(),
    id: stringType().optional(),
    count: numberType().int().optional(),
    favoritedByUser: booleanType().optional()
  });
  var FavoriteInfo$;
  (function(FavoriteInfo$2) {
    FavoriteInfo$2.inboundSchema = FavoriteInfo$inboundSchema;
    FavoriteInfo$2.outboundSchema = FavoriteInfo$outboundSchema;
  })(FavoriteInfo$ || (FavoriteInfo$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/feedbackchatexchange.js
  var ResultDocument$inboundSchema = objectType({
    title: stringType().optional(),
    url: stringType().optional()
  });
  var ResultDocument$outboundSchema = objectType({
    title: stringType().optional(),
    url: stringType().optional()
  });
  var ResultDocument$;
  (function(ResultDocument$2) {
    ResultDocument$2.inboundSchema = ResultDocument$inboundSchema;
    ResultDocument$2.outboundSchema = ResultDocument$outboundSchema;
  })(ResultDocument$ || (ResultDocument$ = {}));
  var FeedbackChatExchange$inboundSchema = objectType({
    timestamp: numberType().int().optional(),
    agent: stringType().optional(),
    userQuery: stringType().optional(),
    searchQuery: stringType().optional(),
    resultDocuments: arrayType(lazyType(() => ResultDocument$inboundSchema)).optional(),
    response: stringType().optional()
  });
  var FeedbackChatExchange$outboundSchema = objectType({
    timestamp: numberType().int().optional(),
    agent: stringType().optional(),
    userQuery: stringType().optional(),
    searchQuery: stringType().optional(),
    resultDocuments: arrayType(lazyType(() => ResultDocument$outboundSchema)).optional(),
    response: stringType().optional()
  });
  var FeedbackChatExchange$;
  (function(FeedbackChatExchange$2) {
    FeedbackChatExchange$2.inboundSchema = FeedbackChatExchange$inboundSchema;
    FeedbackChatExchange$2.outboundSchema = FeedbackChatExchange$outboundSchema;
  })(FeedbackChatExchange$ || (FeedbackChatExchange$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/manualfeedbackinfo.js
  var ManualFeedbackInfoSource = {
    Autocomplete: "AUTOCOMPLETE",
    Calendar: "CALENDAR",
    Chat: "CHAT",
    ChatGeneral: "CHAT_GENERAL",
    ConceptCard: "CONCEPT_CARD",
    DesktopApp: "DESKTOP_APP",
    DisambiguationCard: "DISAMBIGUATION_CARD",
    ExpertDetection: "EXPERT_DETECTION",
    Feed: "FEED",
    GeneratedQAndA: "GENERATED_Q_AND_A",
    InlineMenu: "INLINE_MENU",
    NativeResult: "NATIVE_RESULT",
    QAndA: "Q_AND_A",
    RelatedQuestions: "RELATED_QUESTIONS",
    ReportIssue: "REPORT_ISSUE",
    Sciobot: "SCIOBOT",
    Search: "SEARCH",
    Sidebar: "SIDEBAR",
    Summary: "SUMMARY",
    Tasks: "TASKS"
  };
  var Issue = {
    InaccurateResponse: "INACCURATE_RESPONSE",
    IncompleteOrNoAnswer: "INCOMPLETE_OR_NO_ANSWER",
    IncorrectCitation: "INCORRECT_CITATION",
    MissingCitation: "MISSING_CITATION",
    Other: "OTHER",
    OutdatedResponse: "OUTDATED_RESPONSE",
    ResultMissing: "RESULT_MISSING",
    ResultShouldNotAppear: "RESULT_SHOULD_NOT_APPEAR",
    ResultsHelpful: "RESULTS_HELPFUL",
    ResultsPoorOrder: "RESULTS_POOR_ORDER",
    TooMuchOneKind: "TOO_MUCH_ONE_KIND"
  };
  var ManualFeedbackInfoVote = {
    Upvote: "UPVOTE",
    Downvote: "DOWNVOTE"
  };
  var ManualFeedbackInfoSource$inboundSchema = nativeEnumType(ManualFeedbackInfoSource);
  var ManualFeedbackInfoSource$outboundSchema = ManualFeedbackInfoSource$inboundSchema;
  var ManualFeedbackInfoSource$;
  (function(ManualFeedbackInfoSource$2) {
    ManualFeedbackInfoSource$2.inboundSchema = ManualFeedbackInfoSource$inboundSchema;
    ManualFeedbackInfoSource$2.outboundSchema = ManualFeedbackInfoSource$outboundSchema;
  })(ManualFeedbackInfoSource$ || (ManualFeedbackInfoSource$ = {}));
  var Issue$inboundSchema = nativeEnumType(Issue);
  var Issue$outboundSchema = Issue$inboundSchema;
  var Issue$;
  (function(Issue$2) {
    Issue$2.inboundSchema = Issue$inboundSchema;
    Issue$2.outboundSchema = Issue$outboundSchema;
  })(Issue$ || (Issue$ = {}));
  var ManualFeedbackInfoVote$inboundSchema = nativeEnumType(ManualFeedbackInfoVote);
  var ManualFeedbackInfoVote$outboundSchema = ManualFeedbackInfoVote$inboundSchema;
  var ManualFeedbackInfoVote$;
  (function(ManualFeedbackInfoVote$2) {
    ManualFeedbackInfoVote$2.inboundSchema = ManualFeedbackInfoVote$inboundSchema;
    ManualFeedbackInfoVote$2.outboundSchema = ManualFeedbackInfoVote$outboundSchema;
  })(ManualFeedbackInfoVote$ || (ManualFeedbackInfoVote$ = {}));
  var ManualFeedbackInfo$inboundSchema = objectType({
    email: stringType().optional(),
    source: ManualFeedbackInfoSource$inboundSchema.optional(),
    issue: stringType().optional(),
    issues: arrayType(Issue$inboundSchema).optional(),
    imageUrls: arrayType(stringType()).optional(),
    query: stringType().optional(),
    obscuredQuery: stringType().optional(),
    activeTab: stringType().optional(),
    comments: stringType().optional(),
    searchResults: arrayType(stringType()).optional(),
    previousMessages: arrayType(stringType()).optional(),
    chatTranscript: arrayType(FeedbackChatExchange$inboundSchema).optional(),
    numQueriesFromFirstRun: numberType().int().optional(),
    vote: ManualFeedbackInfoVote$inboundSchema.optional(),
    rating: numberType().int().optional(),
    ratingKey: stringType().optional(),
    ratingScale: numberType().int().optional()
  });
  var ManualFeedbackInfo$outboundSchema = objectType({
    email: stringType().optional(),
    source: ManualFeedbackInfoSource$outboundSchema.optional(),
    issue: stringType().optional(),
    issues: arrayType(Issue$outboundSchema).optional(),
    imageUrls: arrayType(stringType()).optional(),
    query: stringType().optional(),
    obscuredQuery: stringType().optional(),
    activeTab: stringType().optional(),
    comments: stringType().optional(),
    searchResults: arrayType(stringType()).optional(),
    previousMessages: arrayType(stringType()).optional(),
    chatTranscript: arrayType(FeedbackChatExchange$outboundSchema).optional(),
    numQueriesFromFirstRun: numberType().int().optional(),
    vote: ManualFeedbackInfoVote$outboundSchema.optional(),
    rating: numberType().int().optional(),
    ratingKey: stringType().optional(),
    ratingScale: numberType().int().optional()
  });
  var ManualFeedbackInfo$;
  (function(ManualFeedbackInfo$2) {
    ManualFeedbackInfo$2.inboundSchema = ManualFeedbackInfo$inboundSchema;
    ManualFeedbackInfo$2.outboundSchema = ManualFeedbackInfo$outboundSchema;
  })(ManualFeedbackInfo$ || (ManualFeedbackInfo$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/sidebysideimplementation.js
  var ResponseMetadata$inboundSchema = objectType({
    latencyMs: numberType().int().optional(),
    tokenCount: numberType().int().optional(),
    modelUsed: stringType().optional()
  });
  var ResponseMetadata$outboundSchema = objectType({
    latencyMs: numberType().int().optional(),
    tokenCount: numberType().int().optional(),
    modelUsed: stringType().optional()
  });
  var ResponseMetadata$;
  (function(ResponseMetadata$2) {
    ResponseMetadata$2.inboundSchema = ResponseMetadata$inboundSchema;
    ResponseMetadata$2.outboundSchema = ResponseMetadata$outboundSchema;
  })(ResponseMetadata$ || (ResponseMetadata$ = {}));
  var SideBySideImplementation$inboundSchema = objectType({
    implementationId: stringType().optional(),
    implementationName: stringType().optional(),
    searchParams: recordType(stringType()).optional(),
    response: stringType().optional(),
    responseMetadata: lazyType(() => ResponseMetadata$inboundSchema).optional()
  });
  var SideBySideImplementation$outboundSchema = objectType({
    implementationId: stringType().optional(),
    implementationName: stringType().optional(),
    searchParams: recordType(stringType()).optional(),
    response: stringType().optional(),
    responseMetadata: lazyType(() => ResponseMetadata$outboundSchema).optional()
  });
  var SideBySideImplementation$;
  (function(SideBySideImplementation$2) {
    SideBySideImplementation$2.inboundSchema = SideBySideImplementation$inboundSchema;
    SideBySideImplementation$2.outboundSchema = SideBySideImplementation$outboundSchema;
  })(SideBySideImplementation$ || (SideBySideImplementation$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/manualfeedbacksidebysideinfo.js
  var ManualFeedbackSideBySideInfoSource = {
    LiveEval: "LIVE_EVAL",
    Chat: "CHAT",
    Search: "SEARCH"
  };
  var ManualFeedbackSideBySideInfoVote = {
    Upvote: "UPVOTE",
    Downvote: "DOWNVOTE",
    Neutral: "NEUTRAL"
  };
  var ManualFeedbackSideBySideInfoSource$inboundSchema = nativeEnumType(ManualFeedbackSideBySideInfoSource);
  var ManualFeedbackSideBySideInfoSource$outboundSchema = ManualFeedbackSideBySideInfoSource$inboundSchema;
  var ManualFeedbackSideBySideInfoSource$;
  (function(ManualFeedbackSideBySideInfoSource$2) {
    ManualFeedbackSideBySideInfoSource$2.inboundSchema = ManualFeedbackSideBySideInfoSource$inboundSchema;
    ManualFeedbackSideBySideInfoSource$2.outboundSchema = ManualFeedbackSideBySideInfoSource$outboundSchema;
  })(ManualFeedbackSideBySideInfoSource$ || (ManualFeedbackSideBySideInfoSource$ = {}));
  var ManualFeedbackSideBySideInfoVote$inboundSchema = nativeEnumType(ManualFeedbackSideBySideInfoVote);
  var ManualFeedbackSideBySideInfoVote$outboundSchema = ManualFeedbackSideBySideInfoVote$inboundSchema;
  var ManualFeedbackSideBySideInfoVote$;
  (function(ManualFeedbackSideBySideInfoVote$2) {
    ManualFeedbackSideBySideInfoVote$2.inboundSchema = ManualFeedbackSideBySideInfoVote$inboundSchema;
    ManualFeedbackSideBySideInfoVote$2.outboundSchema = ManualFeedbackSideBySideInfoVote$outboundSchema;
  })(ManualFeedbackSideBySideInfoVote$ || (ManualFeedbackSideBySideInfoVote$ = {}));
  var ManualFeedbackSideBySideInfo$inboundSchema = objectType({
    email: stringType().optional(),
    source: ManualFeedbackSideBySideInfoSource$inboundSchema.optional(),
    query: stringType().optional(),
    implementations: arrayType(SideBySideImplementation$inboundSchema).optional(),
    evaluationSessionId: stringType().optional(),
    implementationId: stringType().optional(),
    vote: ManualFeedbackSideBySideInfoVote$inboundSchema.optional(),
    comments: stringType().optional()
  });
  var ManualFeedbackSideBySideInfo$outboundSchema = objectType({
    email: stringType().optional(),
    source: ManualFeedbackSideBySideInfoSource$outboundSchema.optional(),
    query: stringType().optional(),
    implementations: arrayType(SideBySideImplementation$outboundSchema).optional(),
    evaluationSessionId: stringType().optional(),
    implementationId: stringType().optional(),
    vote: ManualFeedbackSideBySideInfoVote$outboundSchema.optional(),
    comments: stringType().optional()
  });
  var ManualFeedbackSideBySideInfo$;
  (function(ManualFeedbackSideBySideInfo$2) {
    ManualFeedbackSideBySideInfo$2.inboundSchema = ManualFeedbackSideBySideInfo$inboundSchema;
    ManualFeedbackSideBySideInfo$2.outboundSchema = ManualFeedbackSideBySideInfo$outboundSchema;
  })(ManualFeedbackSideBySideInfo$ || (ManualFeedbackSideBySideInfo$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/seenfeedbackinfo.js
  var SeenFeedbackInfo$inboundSchema = objectType({
    isExplicit: booleanType().optional()
  });
  var SeenFeedbackInfo$outboundSchema = objectType({
    isExplicit: booleanType().optional()
  });
  var SeenFeedbackInfo$;
  (function(SeenFeedbackInfo$2) {
    SeenFeedbackInfo$2.inboundSchema = SeenFeedbackInfo$inboundSchema;
    SeenFeedbackInfo$2.outboundSchema = SeenFeedbackInfo$outboundSchema;
  })(SeenFeedbackInfo$ || (SeenFeedbackInfo$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/user.js
  var User$inboundSchema = objectType({
    userID: stringType().optional(),
    origID: stringType().optional()
  });
  var User$outboundSchema = objectType({
    userID: stringType().optional(),
    origID: stringType().optional()
  });
  var User$;
  (function(User$2) {
    User$2.inboundSchema = User$inboundSchema;
    User$2.outboundSchema = User$outboundSchema;
  })(User$ || (User$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/userviewinfo.js
  var UserViewInfo$inboundSchema = objectType({
    docId: stringType().optional(),
    docTitle: stringType().optional(),
    docUrl: stringType().optional()
  });
  var UserViewInfo$outboundSchema = objectType({
    docId: stringType().optional(),
    docTitle: stringType().optional(),
    docUrl: stringType().optional()
  });
  var UserViewInfo$;
  (function(UserViewInfo$2) {
    UserViewInfo$2.inboundSchema = UserViewInfo$inboundSchema;
    UserViewInfo$2.outboundSchema = UserViewInfo$outboundSchema;
  })(UserViewInfo$ || (UserViewInfo$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/workflowfeedbackinfo.js
  var WorkflowFeedbackInfoSource = {
    ZeroState: "ZERO_STATE",
    Library: "LIBRARY",
    Homepage: "HOMEPAGE"
  };
  var WorkflowFeedbackInfoSource$inboundSchema = nativeEnumType(WorkflowFeedbackInfoSource);
  var WorkflowFeedbackInfoSource$outboundSchema = WorkflowFeedbackInfoSource$inboundSchema;
  var WorkflowFeedbackInfoSource$;
  (function(WorkflowFeedbackInfoSource$2) {
    WorkflowFeedbackInfoSource$2.inboundSchema = WorkflowFeedbackInfoSource$inboundSchema;
    WorkflowFeedbackInfoSource$2.outboundSchema = WorkflowFeedbackInfoSource$outboundSchema;
  })(WorkflowFeedbackInfoSource$ || (WorkflowFeedbackInfoSource$ = {}));
  var WorkflowFeedbackInfo$inboundSchema = objectType({
    source: WorkflowFeedbackInfoSource$inboundSchema.optional()
  });
  var WorkflowFeedbackInfo$outboundSchema = objectType({
    source: WorkflowFeedbackInfoSource$outboundSchema.optional()
  });
  var WorkflowFeedbackInfo$;
  (function(WorkflowFeedbackInfo$2) {
    WorkflowFeedbackInfo$2.inboundSchema = WorkflowFeedbackInfo$inboundSchema;
    WorkflowFeedbackInfo$2.outboundSchema = WorkflowFeedbackInfo$outboundSchema;
  })(WorkflowFeedbackInfo$ || (WorkflowFeedbackInfo$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/feedback.js
  var FeedbackCategory = {
    Announcement: "ANNOUNCEMENT",
    Autocomplete: "AUTOCOMPLETE",
    Collections: "COLLECTIONS",
    Feed: "FEED",
    Search: "SEARCH",
    Chat: "CHAT",
    Ntp: "NTP",
    Workflows: "WORKFLOWS",
    Summary: "SUMMARY",
    General: "GENERAL",
    Prompts: "PROMPTS"
  };
  var Event = {
    Click: "CLICK",
    ContainerClick: "CONTAINER_CLICK",
    CopyLink: "COPY_LINK",
    Create: "CREATE",
    Dismiss: "DISMISS",
    Downvote: "DOWNVOTE",
    Email: "EMAIL",
    Execute: "EXECUTE",
    Filter: "FILTER",
    FirstToken: "FIRST_TOKEN",
    FocusIn: "FOCUS_IN",
    LastToken: "LAST_TOKEN",
    ManualFeedback: "MANUAL_FEEDBACK",
    ManualFeedbackSideBySide: "MANUAL_FEEDBACK_SIDE_BY_SIDE",
    MarkAsRead: "MARK_AS_READ",
    Message: "MESSAGE",
    MiddleClick: "MIDDLE_CLICK",
    PageBlur: "PAGE_BLUR",
    PageFocus: "PAGE_FOCUS",
    PageLeave: "PAGE_LEAVE",
    Preview: "PREVIEW",
    RelatedClick: "RELATED_CLICK",
    RightClick: "RIGHT_CLICK",
    SectionClick: "SECTION_CLICK",
    Seen: "SEEN",
    Share: "SHARE",
    ShowMore: "SHOW_MORE",
    Upvote: "UPVOTE",
    View: "VIEW",
    Visible: "VISIBLE"
  };
  var FeedbackChannel = {
    Company: "COMPANY",
    Glean: "GLEAN"
  };
  var FeedbackCategory$inboundSchema = nativeEnumType(FeedbackCategory);
  var FeedbackCategory$outboundSchema = FeedbackCategory$inboundSchema;
  var FeedbackCategory$;
  (function(FeedbackCategory$2) {
    FeedbackCategory$2.inboundSchema = FeedbackCategory$inboundSchema;
    FeedbackCategory$2.outboundSchema = FeedbackCategory$outboundSchema;
  })(FeedbackCategory$ || (FeedbackCategory$ = {}));
  var Event$inboundSchema = nativeEnumType(Event);
  var Event$outboundSchema = Event$inboundSchema;
  var Event$;
  (function(Event$2) {
    Event$2.inboundSchema = Event$inboundSchema;
    Event$2.outboundSchema = Event$outboundSchema;
  })(Event$ || (Event$ = {}));
  var FeedbackChannel$inboundSchema = nativeEnumType(FeedbackChannel);
  var FeedbackChannel$outboundSchema = FeedbackChannel$inboundSchema;
  var FeedbackChannel$;
  (function(FeedbackChannel$2) {
    FeedbackChannel$2.inboundSchema = FeedbackChannel$inboundSchema;
    FeedbackChannel$2.outboundSchema = FeedbackChannel$outboundSchema;
  })(FeedbackChannel$ || (FeedbackChannel$ = {}));
  var Feedback$inboundSchema = objectType({
    id: stringType().optional(),
    category: FeedbackCategory$inboundSchema.optional(),
    trackingTokens: arrayType(stringType()),
    event: Event$inboundSchema,
    position: numberType().int().optional(),
    payload: stringType().optional(),
    sessionInfo: SessionInfo$inboundSchema.optional(),
    timestamp: stringType().datetime({ offset: true }).transform((v) => new Date(v)).optional(),
    user: User$inboundSchema.optional(),
    pathname: stringType().optional(),
    channels: arrayType(FeedbackChannel$inboundSchema).optional(),
    url: stringType().optional(),
    uiTree: arrayType(stringType()).optional(),
    uiElement: stringType().optional(),
    manualFeedbackInfo: ManualFeedbackInfo$inboundSchema.optional(),
    manualFeedbackSideBySideInfo: ManualFeedbackSideBySideInfo$inboundSchema.optional(),
    seenFeedbackInfo: SeenFeedbackInfo$inboundSchema.optional(),
    userViewInfo: UserViewInfo$inboundSchema.optional(),
    workflowFeedbackInfo: WorkflowFeedbackInfo$inboundSchema.optional(),
    applicationId: stringType().optional(),
    agentId: stringType().optional()
  });
  var Feedback$outboundSchema = objectType({
    id: stringType().optional(),
    category: FeedbackCategory$outboundSchema.optional(),
    trackingTokens: arrayType(stringType()),
    event: Event$outboundSchema,
    position: numberType().int().optional(),
    payload: stringType().optional(),
    sessionInfo: SessionInfo$outboundSchema.optional(),
    timestamp: dateType().transform((v) => v.toISOString()).optional(),
    user: User$outboundSchema.optional(),
    pathname: stringType().optional(),
    channels: arrayType(FeedbackChannel$outboundSchema).optional(),
    url: stringType().optional(),
    uiTree: arrayType(stringType()).optional(),
    uiElement: stringType().optional(),
    manualFeedbackInfo: ManualFeedbackInfo$outboundSchema.optional(),
    manualFeedbackSideBySideInfo: ManualFeedbackSideBySideInfo$outboundSchema.optional(),
    seenFeedbackInfo: SeenFeedbackInfo$outboundSchema.optional(),
    userViewInfo: UserViewInfo$outboundSchema.optional(),
    workflowFeedbackInfo: WorkflowFeedbackInfo$outboundSchema.optional(),
    applicationId: stringType().optional(),
    agentId: stringType().optional()
  });
  var Feedback$;
  (function(Feedback$2) {
    Feedback$2.inboundSchema = Feedback$inboundSchema;
    Feedback$2.outboundSchema = Feedback$outboundSchema;
  })(Feedback$ || (Feedback$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/prompttemplate.js
  var PromptTemplate$inboundSchema = objectType({
    name: stringType().optional(),
    template: stringType(),
    applicationId: stringType().optional(),
    inclusions: ChatRestrictionFilters$inboundSchema.optional(),
    addedRoles: arrayType(UserRoleSpecification$inboundSchema).optional(),
    removedRoles: arrayType(UserRoleSpecification$inboundSchema).optional(),
    permissions: ObjectPermissions$inboundSchema.optional(),
    id: stringType().optional(),
    author: Person$inboundSchema.optional(),
    createTimestamp: numberType().int().optional(),
    lastUpdateTimestamp: numberType().int().optional(),
    lastUpdatedBy: Person$inboundSchema.optional(),
    roles: arrayType(UserRoleSpecification$inboundSchema).optional()
  });
  var PromptTemplate$outboundSchema = objectType({
    name: stringType().optional(),
    template: stringType(),
    applicationId: stringType().optional(),
    inclusions: ChatRestrictionFilters$outboundSchema.optional(),
    addedRoles: arrayType(UserRoleSpecification$outboundSchema).optional(),
    removedRoles: arrayType(UserRoleSpecification$outboundSchema).optional(),
    permissions: ObjectPermissions$outboundSchema.optional(),
    id: stringType().optional(),
    author: Person$outboundSchema.optional(),
    createTimestamp: numberType().int().optional(),
    lastUpdateTimestamp: numberType().int().optional(),
    lastUpdatedBy: Person$outboundSchema.optional(),
    roles: arrayType(UserRoleSpecification$outboundSchema).optional()
  });
  var PromptTemplate$;
  (function(PromptTemplate$2) {
    PromptTemplate$2.inboundSchema = PromptTemplate$inboundSchema;
    PromptTemplate$2.outboundSchema = PromptTemplate$outboundSchema;
  })(PromptTemplate$ || (PromptTemplate$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/prompttemplateresult.js
  var PromptTemplateResult$inboundSchema = objectType({
    promptTemplate: PromptTemplate$inboundSchema.optional(),
    trackingToken: stringType().optional(),
    favoriteInfo: FavoriteInfo$inboundSchema.optional(),
    runCount: CountInfo$inboundSchema.optional()
  });
  var PromptTemplateResult$outboundSchema = objectType({
    promptTemplate: PromptTemplate$outboundSchema.optional(),
    trackingToken: stringType().optional(),
    favoriteInfo: FavoriteInfo$outboundSchema.optional(),
    runCount: CountInfo$outboundSchema.optional()
  });
  var PromptTemplateResult$;
  (function(PromptTemplateResult$2) {
    PromptTemplateResult$2.inboundSchema = PromptTemplateResult$inboundSchema;
    PromptTemplateResult$2.outboundSchema = PromptTemplateResult$outboundSchema;
  })(PromptTemplateResult$ || (PromptTemplateResult$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/useractivity.js
  var UserActivityAction = {
    Add: "ADD",
    AddReminder: "ADD_REMINDER",
    Click: "CLICK",
    Comment: "COMMENT",
    Delete: "DELETE",
    Dismiss: "DISMISS",
    Edit: "EDIT",
    Mention: "MENTION",
    Move: "MOVE",
    Other: "OTHER",
    Restore: "RESTORE",
    Unknown: "UNKNOWN",
    Verify: "VERIFY",
    View: "VIEW"
  };
  var UserActivityAction$inboundSchema = nativeEnumType(UserActivityAction);
  var UserActivityAction$outboundSchema = UserActivityAction$inboundSchema;
  var UserActivityAction$;
  (function(UserActivityAction$2) {
    UserActivityAction$2.inboundSchema = UserActivityAction$inboundSchema;
    UserActivityAction$2.outboundSchema = UserActivityAction$outboundSchema;
  })(UserActivityAction$ || (UserActivityAction$ = {}));
  var UserActivity$inboundSchema = objectType({
    actor: Person$inboundSchema.optional(),
    timestamp: numberType().int().optional(),
    action: UserActivityAction$inboundSchema.optional(),
    aggregateVisitCount: CountInfo$inboundSchema.optional()
  });
  var UserActivity$outboundSchema = objectType({
    actor: Person$outboundSchema.optional(),
    timestamp: numberType().int().optional(),
    action: UserActivityAction$outboundSchema.optional(),
    aggregateVisitCount: CountInfo$outboundSchema.optional()
  });
  var UserActivity$;
  (function(UserActivity$2) {
    UserActivity$2.inboundSchema = UserActivity$inboundSchema;
    UserActivity$2.outboundSchema = UserActivity$outboundSchema;
  })(UserActivity$ || (UserActivity$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/workflow.js
  var Workflow$inboundSchema = objectType({
    name: stringType().optional(),
    author: Person$inboundSchema.optional(),
    createTimestamp: numberType().int().optional(),
    lastUpdateTimestamp: numberType().int().optional(),
    lastUpdatedBy: Person$inboundSchema.optional(),
    permissions: ObjectPermissions$inboundSchema.optional(),
    id: stringType().optional()
  });
  var Workflow$outboundSchema = objectType({
    name: stringType().optional(),
    author: Person$outboundSchema.optional(),
    createTimestamp: numberType().int().optional(),
    lastUpdateTimestamp: numberType().int().optional(),
    lastUpdatedBy: Person$outboundSchema.optional(),
    permissions: ObjectPermissions$outboundSchema.optional(),
    id: stringType().optional()
  });
  var Workflow$;
  (function(Workflow$2) {
    Workflow$2.inboundSchema = Workflow$inboundSchema;
    Workflow$2.outboundSchema = Workflow$outboundSchema;
  })(Workflow$ || (Workflow$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/workflowresult.js
  var WorkflowResult$inboundSchema = objectType({
    workflow: Workflow$inboundSchema
  });
  var WorkflowResult$outboundSchema = objectType({
    workflow: Workflow$outboundSchema
  });
  var WorkflowResult$;
  (function(WorkflowResult$2) {
    WorkflowResult$2.inboundSchema = WorkflowResult$inboundSchema;
    WorkflowResult$2.outboundSchema = WorkflowResult$outboundSchema;
  })(WorkflowResult$ || (WorkflowResult$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/feedentry.js
  var Format = {
    List: "LIST"
  };
  var JustificationType = {
    FrequentlyAccessed: "FREQUENTLY_ACCESSED",
    RecentlyAccessed: "RECENTLY_ACCESSED",
    TrendingDocument: "TRENDING_DOCUMENT",
    VerificationReminder: "VERIFICATION_REMINDER",
    SuggestedDocument: "SUGGESTED_DOCUMENT",
    EmptyStateSuggestion: "EMPTY_STATE_SUGGESTION",
    FrecencyScored: "FRECENCY_SCORED",
    ServerGenerated: "SERVER_GENERATED",
    UseCase: "USE_CASE",
    UpdateSinceLastView: "UPDATE_SINCE_LAST_VIEW",
    RecentlyStarted: "RECENTLY_STARTED",
    Event: "EVENT",
    UserMention: "USER_MENTION",
    Announcement: "ANNOUNCEMENT",
    ExternalAnnouncement: "EXTERNAL_ANNOUNCEMENT",
    PopularityBasedTrending: "POPULARITY_BASED_TRENDING",
    CompanyResource: "COMPANY_RESOURCE",
    EventDocumentFromContent: "EVENT_DOCUMENT_FROM_CONTENT",
    EventDocumentFromSearch: "EVENT_DOCUMENT_FROM_SEARCH",
    VisitAffinityScored: "VISIT_AFFINITY_SCORED",
    SuggestedApp: "SUGGESTED_APP",
    SuggestedPerson: "SUGGESTED_PERSON",
    ActivityHighlight: "ACTIVITY_HIGHLIGHT",
    SavedSearch: "SAVED_SEARCH",
    SuggestedChannel: "SUGGESTED_CHANNEL",
    PeopleCelebrations: "PEOPLE_CELEBRATIONS",
    SocialLink: "SOCIAL_LINK",
    ZeroStateChatSuggestion: "ZERO_STATE_CHAT_SUGGESTION",
    ZeroStateChatToolSuggestion: "ZERO_STATE_CHAT_TOOL_SUGGESTION",
    ZeroStatePromptTemplateSuggestion: "ZERO_STATE_PROMPT_TEMPLATE_SUGGESTION",
    ZeroStateStaticWorkflowSuggestion: "ZERO_STATE_STATIC_WORKFLOW_SUGGESTION",
    ZeroStateAgentSuggestion: "ZERO_STATE_AGENT_SUGGESTION",
    PersonalizedChatSuggestion: "PERSONALIZED_CHAT_SUGGESTION",
    DailyDigest: "DAILY_DIGEST"
  };
  var Format$inboundSchema = nativeEnumType(Format);
  var Format$outboundSchema = Format$inboundSchema;
  var Format$;
  (function(Format$2) {
    Format$2.inboundSchema = Format$inboundSchema;
    Format$2.outboundSchema = Format$outboundSchema;
  })(Format$ || (Format$ = {}));
  var UiConfig$inboundSchema = objectType({
    format: Format$inboundSchema.optional(),
    additionalFlags: DisplayableListItemUIConfig$inboundSchema.optional()
  });
  var UiConfig$outboundSchema = objectType({
    format: Format$outboundSchema.optional(),
    additionalFlags: DisplayableListItemUIConfig$outboundSchema.optional()
  });
  var UiConfig$;
  (function(UiConfig$2) {
    UiConfig$2.inboundSchema = UiConfig$inboundSchema;
    UiConfig$2.outboundSchema = UiConfig$outboundSchema;
  })(UiConfig$ || (UiConfig$ = {}));
  var JustificationType$inboundSchema = nativeEnumType(JustificationType);
  var JustificationType$outboundSchema = JustificationType$inboundSchema;
  var JustificationType$;
  (function(JustificationType$2) {
    JustificationType$2.inboundSchema = JustificationType$inboundSchema;
    JustificationType$2.outboundSchema = JustificationType$outboundSchema;
  })(JustificationType$ || (JustificationType$ = {}));
  var FeedEntry$inboundSchema = objectType({
    entryId: stringType().optional(),
    title: stringType(),
    thumbnail: Thumbnail$inboundSchema.optional(),
    createdBy: Person$inboundSchema.optional(),
    uiConfig: lazyType(() => UiConfig$inboundSchema).optional(),
    justificationType: JustificationType$inboundSchema.optional(),
    justification: stringType().optional(),
    trackingToken: stringType().optional(),
    viewUrl: stringType().optional(),
    document: Document$inboundSchema.optional(),
    event: CalendarEvent$inboundSchema.optional(),
    announcement: Announcement$inboundSchema.optional(),
    digest: Digest$inboundSchema.optional(),
    collection: Collection$inboundSchema.optional(),
    collectionItem: CollectionItem$inboundSchema.optional(),
    person: Person$inboundSchema.optional(),
    app: AppResult$inboundSchema.optional(),
    chatSuggestion: ChatSuggestion$inboundSchema.optional(),
    promptTemplate: PromptTemplateResult$inboundSchema.optional(),
    workflow: WorkflowResult$inboundSchema.optional(),
    activities: arrayType(UserActivity$inboundSchema).optional(),
    documentVisitorCount: CountInfo$inboundSchema.optional()
  });
  var FeedEntry$outboundSchema = objectType({
    entryId: stringType().optional(),
    title: stringType(),
    thumbnail: Thumbnail$outboundSchema.optional(),
    createdBy: Person$outboundSchema.optional(),
    uiConfig: lazyType(() => UiConfig$outboundSchema).optional(),
    justificationType: JustificationType$outboundSchema.optional(),
    justification: stringType().optional(),
    trackingToken: stringType().optional(),
    viewUrl: stringType().optional(),
    document: Document$outboundSchema.optional(),
    event: CalendarEvent$outboundSchema.optional(),
    announcement: Announcement$outboundSchema.optional(),
    digest: Digest$outboundSchema.optional(),
    collection: Collection$outboundSchema.optional(),
    collectionItem: CollectionItem$outboundSchema.optional(),
    person: Person$outboundSchema.optional(),
    app: AppResult$outboundSchema.optional(),
    chatSuggestion: ChatSuggestion$outboundSchema.optional(),
    promptTemplate: PromptTemplateResult$outboundSchema.optional(),
    workflow: WorkflowResult$outboundSchema.optional(),
    activities: arrayType(UserActivity$outboundSchema).optional(),
    documentVisitorCount: CountInfo$outboundSchema.optional()
  });
  var FeedEntry$;
  (function(FeedEntry$2) {
    FeedEntry$2.inboundSchema = FeedEntry$inboundSchema;
    FeedEntry$2.outboundSchema = FeedEntry$outboundSchema;
  })(FeedEntry$ || (FeedEntry$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/feedrequestoptions.js
  var CategoryToResultSize$inboundSchema = objectType({
    resultSize: numberType().int().optional()
  });
  var CategoryToResultSize$outboundSchema = objectType({
    resultSize: numberType().int().optional()
  });
  var CategoryToResultSize$;
  (function(CategoryToResultSize$2) {
    CategoryToResultSize$2.inboundSchema = CategoryToResultSize$inboundSchema;
    CategoryToResultSize$2.outboundSchema = CategoryToResultSize$outboundSchema;
  })(CategoryToResultSize$ || (CategoryToResultSize$ = {}));
  var FeedRequestOptions$inboundSchema = objectType({
    resultSize: numberType().int(),
    timezoneOffset: numberType().int().optional(),
    categoryToResultSize: recordType(lazyType(() => CategoryToResultSize$inboundSchema)).optional(),
    datasourceFilter: arrayType(stringType()).optional(),
    chatZeroStateSuggestionOptions: ChatZeroStateSuggestionOptions$inboundSchema.optional()
  });
  var FeedRequestOptions$outboundSchema = objectType({
    resultSize: numberType().int(),
    timezoneOffset: numberType().int().optional(),
    categoryToResultSize: recordType(lazyType(() => CategoryToResultSize$outboundSchema)).optional(),
    datasourceFilter: arrayType(stringType()).optional(),
    chatZeroStateSuggestionOptions: ChatZeroStateSuggestionOptions$outboundSchema.optional()
  });
  var FeedRequestOptions$;
  (function(FeedRequestOptions$2) {
    FeedRequestOptions$2.inboundSchema = FeedRequestOptions$inboundSchema;
    FeedRequestOptions$2.outboundSchema = FeedRequestOptions$outboundSchema;
  })(FeedRequestOptions$ || (FeedRequestOptions$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/feedrequest.js
  var FeedRequestCategory = {
    DocumentSuggestion: "DOCUMENT_SUGGESTION",
    DocumentSuggestionScenario: "DOCUMENT_SUGGESTION_SCENARIO",
    TrendingDocument: "TRENDING_DOCUMENT",
    VerificationReminder: "VERIFICATION_REMINDER",
    Event: "EVENT",
    Announcement: "ANNOUNCEMENT",
    Mention: "MENTION",
    DatasourceAffinity: "DATASOURCE_AFFINITY",
    Recent: "RECENT",
    CompanyResource: "COMPANY_RESOURCE",
    Experimental: "EXPERIMENTAL",
    PeopleCelebrations: "PEOPLE_CELEBRATIONS",
    DisplayableList: "DISPLAYABLE_LIST",
    SocialLink: "SOCIAL_LINK",
    ExternalTasks: "EXTERNAL_TASKS",
    WorkflowCollections: "WORKFLOW_COLLECTIONS",
    ZeroStateChatSuggestion: "ZERO_STATE_CHAT_SUGGESTION",
    ZeroStateChatToolSuggestion: "ZERO_STATE_CHAT_TOOL_SUGGESTION",
    ZeroStateWorkflowCreatedByMe: "ZERO_STATE_WORKFLOW_CREATED_BY_ME",
    ZeroStateWorkflowFavorites: "ZERO_STATE_WORKFLOW_FAVORITES",
    ZeroStateWorkflowPopular: "ZERO_STATE_WORKFLOW_POPULAR",
    ZeroStateWorkflowSuggestion: "ZERO_STATE_WORKFLOW_SUGGESTION",
    PersonalizedChatSuggestion: "PERSONALIZED_CHAT_SUGGESTION",
    DailyDigest: "DAILY_DIGEST"
  };
  var FeedRequestCategory$inboundSchema = nativeEnumType(FeedRequestCategory);
  var FeedRequestCategory$outboundSchema = FeedRequestCategory$inboundSchema;
  var FeedRequestCategory$;
  (function(FeedRequestCategory$2) {
    FeedRequestCategory$2.inboundSchema = FeedRequestCategory$inboundSchema;
    FeedRequestCategory$2.outboundSchema = FeedRequestCategory$outboundSchema;
  })(FeedRequestCategory$ || (FeedRequestCategory$ = {}));
  var FeedRequest$inboundSchema = objectType({
    categories: arrayType(FeedRequestCategory$inboundSchema).optional(),
    requestOptions: FeedRequestOptions$inboundSchema.optional(),
    timeoutMillis: numberType().int().optional(),
    sessionInfo: SessionInfo$inboundSchema.optional()
  });
  var FeedRequest$outboundSchema = objectType({
    categories: arrayType(FeedRequestCategory$outboundSchema).optional(),
    requestOptions: FeedRequestOptions$outboundSchema.optional(),
    timeoutMillis: numberType().int().optional(),
    sessionInfo: SessionInfo$outboundSchema.optional()
  });
  var FeedRequest$;
  (function(FeedRequest$2) {
    FeedRequest$2.inboundSchema = FeedRequest$inboundSchema;
    FeedRequest$2.outboundSchema = FeedRequest$outboundSchema;
  })(FeedRequest$ || (FeedRequest$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/feedresult.js
  var FeedResultCategory = {
    DocumentSuggestion: "DOCUMENT_SUGGESTION",
    DocumentSuggestionScenario: "DOCUMENT_SUGGESTION_SCENARIO",
    TrendingDocument: "TRENDING_DOCUMENT",
    UseCase: "USE_CASE",
    VerificationReminder: "VERIFICATION_REMINDER",
    Event: "EVENT",
    Announcement: "ANNOUNCEMENT",
    Mention: "MENTION",
    DatasourceAffinity: "DATASOURCE_AFFINITY",
    Recent: "RECENT",
    CompanyResource: "COMPANY_RESOURCE",
    Experimental: "EXPERIMENTAL",
    PeopleCelebrations: "PEOPLE_CELEBRATIONS",
    SocialLink: "SOCIAL_LINK",
    ExternalTasks: "EXTERNAL_TASKS",
    DisplayableList: "DISPLAYABLE_LIST",
    ZeroStateChatSuggestion: "ZERO_STATE_CHAT_SUGGESTION",
    ZeroStateChatToolSuggestion: "ZERO_STATE_CHAT_TOOL_SUGGESTION",
    ZeroStateWorkflowCreatedByMe: "ZERO_STATE_WORKFLOW_CREATED_BY_ME",
    ZeroStateWorkflowFavorites: "ZERO_STATE_WORKFLOW_FAVORITES",
    ZeroStateWorkflowPopular: "ZERO_STATE_WORKFLOW_POPULAR",
    ZeroStateWorkflowSuggestion: "ZERO_STATE_WORKFLOW_SUGGESTION",
    PersonalizedChatSuggestion: "PERSONALIZED_CHAT_SUGGESTION",
    DailyDigest: "DAILY_DIGEST"
  };
  var FeedResultCategory$inboundSchema = nativeEnumType(FeedResultCategory);
  var FeedResultCategory$outboundSchema = FeedResultCategory$inboundSchema;
  var FeedResultCategory$;
  (function(FeedResultCategory$2) {
    FeedResultCategory$2.inboundSchema = FeedResultCategory$inboundSchema;
    FeedResultCategory$2.outboundSchema = FeedResultCategory$outboundSchema;
  })(FeedResultCategory$ || (FeedResultCategory$ = {}));
  var FeedResult$inboundSchema = objectType({
    category: FeedResultCategory$inboundSchema,
    primaryEntry: FeedEntry$inboundSchema,
    secondaryEntries: arrayType(FeedEntry$inboundSchema).optional(),
    rank: numberType().int().optional()
  });
  var FeedResult$outboundSchema = objectType({
    category: FeedResultCategory$outboundSchema,
    primaryEntry: FeedEntry$outboundSchema,
    secondaryEntries: arrayType(FeedEntry$outboundSchema).optional(),
    rank: numberType().int().optional()
  });
  var FeedResult$;
  (function(FeedResult$2) {
    FeedResult$2.inboundSchema = FeedResult$inboundSchema;
    FeedResult$2.outboundSchema = FeedResult$outboundSchema;
  })(FeedResult$ || (FeedResult$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/feedresponse.js
  var FeedResponse$inboundSchema = objectType({
    experimentIds: arrayType(numberType().int()).optional(),
    trackingToken: stringType().optional(),
    serverTimestamp: numberType().int(),
    results: arrayType(FeedResult$inboundSchema).optional(),
    facetResults: recordType(arrayType(FacetResult$inboundSchema)).optional(),
    mentionsTimeWindowInHours: numberType().int().optional()
  });
  var FeedResponse$outboundSchema = objectType({
    experimentIds: arrayType(numberType().int()).optional(),
    trackingToken: stringType().optional(),
    serverTimestamp: numberType().int(),
    results: arrayType(FeedResult$outboundSchema).optional(),
    facetResults: recordType(arrayType(FacetResult$outboundSchema)).optional(),
    mentionsTimeWindowInHours: numberType().int().optional()
  });
  var FeedResponse$;
  (function(FeedResponse$2) {
    FeedResponse$2.inboundSchema = FeedResponse$inboundSchema;
    FeedResponse$2.outboundSchema = FeedResponse$outboundSchema;
  })(FeedResponse$ || (FeedResponse$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/getanswererror.js
  var GetAnswerErrorErrorType = {
    NoPermission: "NO_PERMISSION",
    InvalidId: "INVALID_ID"
  };
  var GetAnswerErrorErrorType$inboundSchema = nativeEnumType(GetAnswerErrorErrorType);
  var GetAnswerErrorErrorType$outboundSchema = GetAnswerErrorErrorType$inboundSchema;
  var GetAnswerErrorErrorType$;
  (function(GetAnswerErrorErrorType$2) {
    GetAnswerErrorErrorType$2.inboundSchema = GetAnswerErrorErrorType$inboundSchema;
    GetAnswerErrorErrorType$2.outboundSchema = GetAnswerErrorErrorType$outboundSchema;
  })(GetAnswerErrorErrorType$ || (GetAnswerErrorErrorType$ = {}));
  var GetAnswerError$inboundSchema = objectType({
    errorType: GetAnswerErrorErrorType$inboundSchema.optional(),
    answerAuthor: Person$inboundSchema.optional()
  });
  var GetAnswerError$outboundSchema = objectType({
    errorType: GetAnswerErrorErrorType$outboundSchema.optional(),
    answerAuthor: Person$outboundSchema.optional()
  });
  var GetAnswerError$;
  (function(GetAnswerError$2) {
    GetAnswerError$2.inboundSchema = GetAnswerError$inboundSchema;
    GetAnswerError$2.outboundSchema = GetAnswerError$outboundSchema;
  })(GetAnswerError$ || (GetAnswerError$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/getanswerrequest.js
  var GetAnswerRequest$inboundSchema = objectType({
    id: numberType().int().optional(),
    docId: stringType().optional()
  });
  var GetAnswerRequest$outboundSchema = objectType({
    id: numberType().int().optional(),
    docId: stringType().optional()
  });
  var GetAnswerRequest$;
  (function(GetAnswerRequest$2) {
    GetAnswerRequest$2.inboundSchema = GetAnswerRequest$inboundSchema;
    GetAnswerRequest$2.outboundSchema = GetAnswerRequest$outboundSchema;
  })(GetAnswerRequest$ || (GetAnswerRequest$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/getanswerresponse.js
  var GetAnswerResponse$inboundSchema = objectType({
    answerResult: AnswerResult$inboundSchema.optional(),
    error: GetAnswerError$inboundSchema.optional()
  });
  var GetAnswerResponse$outboundSchema = objectType({
    answerResult: AnswerResult$outboundSchema.optional(),
    error: GetAnswerError$outboundSchema.optional()
  });
  var GetAnswerResponse$;
  (function(GetAnswerResponse$2) {
    GetAnswerResponse$2.inboundSchema = GetAnswerResponse$inboundSchema;
    GetAnswerResponse$2.outboundSchema = GetAnswerResponse$outboundSchema;
  })(GetAnswerResponse$ || (GetAnswerResponse$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/getchatapplicationrequest.js
  var GetChatApplicationRequest$inboundSchema = objectType({
    id: stringType()
  });
  var GetChatApplicationRequest$outboundSchema = objectType({
    id: stringType()
  });
  var GetChatApplicationRequest$;
  (function(GetChatApplicationRequest$2) {
    GetChatApplicationRequest$2.inboundSchema = GetChatApplicationRequest$inboundSchema;
    GetChatApplicationRequest$2.outboundSchema = GetChatApplicationRequest$outboundSchema;
  })(GetChatApplicationRequest$ || (GetChatApplicationRequest$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/getchatapplicationresponse.js
  var GetChatApplicationResponse$inboundSchema = objectType({
    application: anyType().optional()
  });
  var GetChatApplicationResponse$outboundSchema = objectType({
    application: anyType().optional()
  });
  var GetChatApplicationResponse$;
  (function(GetChatApplicationResponse$2) {
    GetChatApplicationResponse$2.inboundSchema = GetChatApplicationResponse$inboundSchema;
    GetChatApplicationResponse$2.outboundSchema = GetChatApplicationResponse$outboundSchema;
  })(GetChatApplicationResponse$ || (GetChatApplicationResponse$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/getchatfilesrequest.js
  var GetChatFilesRequest$inboundSchema = objectType({
    fileIds: arrayType(stringType()),
    chatId: stringType().optional()
  });
  var GetChatFilesRequest$outboundSchema = objectType({
    fileIds: arrayType(stringType()),
    chatId: stringType().optional()
  });
  var GetChatFilesRequest$;
  (function(GetChatFilesRequest$2) {
    GetChatFilesRequest$2.inboundSchema = GetChatFilesRequest$inboundSchema;
    GetChatFilesRequest$2.outboundSchema = GetChatFilesRequest$outboundSchema;
  })(GetChatFilesRequest$ || (GetChatFilesRequest$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/getchatfilesresponse.js
  var GetChatFilesResponse$inboundSchema = objectType({
    files: recordType(ChatFile$inboundSchema).optional()
  });
  var GetChatFilesResponse$outboundSchema = objectType({
    files: recordType(ChatFile$outboundSchema).optional()
  });
  var GetChatFilesResponse$;
  (function(GetChatFilesResponse$2) {
    GetChatFilesResponse$2.inboundSchema = GetChatFilesResponse$inboundSchema;
    GetChatFilesResponse$2.outboundSchema = GetChatFilesResponse$outboundSchema;
  })(GetChatFilesResponse$ || (GetChatFilesResponse$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/getchatrequest.js
  var GetChatRequest$inboundSchema = objectType({
    id: stringType()
  });
  var GetChatRequest$outboundSchema = objectType({
    id: stringType()
  });
  var GetChatRequest$;
  (function(GetChatRequest$2) {
    GetChatRequest$2.inboundSchema = GetChatRequest$inboundSchema;
    GetChatRequest$2.outboundSchema = GetChatRequest$outboundSchema;
  })(GetChatRequest$ || (GetChatRequest$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/getchatresponse.js
  var GetChatResponse$inboundSchema = objectType({
    chatResult: ChatResult$inboundSchema.optional()
  });
  var GetChatResponse$outboundSchema = objectType({
    chatResult: ChatResult$outboundSchema.optional()
  });
  var GetChatResponse$;
  (function(GetChatResponse$2) {
    GetChatResponse$2.inboundSchema = GetChatResponse$inboundSchema;
    GetChatResponse$2.outboundSchema = GetChatResponse$outboundSchema;
  })(GetChatResponse$ || (GetChatResponse$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/getcollectionrequest.js
  var GetCollectionRequest$inboundSchema = objectType({
    id: numberType().int(),
    withItems: booleanType().optional(),
    withHierarchy: booleanType().optional(),
    allowedDatasource: stringType().optional()
  });
  var GetCollectionRequest$outboundSchema = objectType({
    id: numberType().int(),
    withItems: booleanType().optional(),
    withHierarchy: booleanType().optional(),
    allowedDatasource: stringType().optional()
  });
  var GetCollectionRequest$;
  (function(GetCollectionRequest$2) {
    GetCollectionRequest$2.inboundSchema = GetCollectionRequest$inboundSchema;
    GetCollectionRequest$2.outboundSchema = GetCollectionRequest$outboundSchema;
  })(GetCollectionRequest$ || (GetCollectionRequest$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/getcollectionresponse.js
  var GetCollectionResponse$inboundSchema = objectType({
    collection: Collection$inboundSchema.optional(),
    rootCollection: Collection$inboundSchema.optional(),
    trackingToken: stringType().optional(),
    error: CollectionError$inboundSchema.optional()
  });
  var GetCollectionResponse$outboundSchema = objectType({
    collection: Collection$outboundSchema.optional(),
    rootCollection: Collection$outboundSchema.optional(),
    trackingToken: stringType().optional(),
    error: CollectionError$outboundSchema.optional()
  });
  var GetCollectionResponse$;
  (function(GetCollectionResponse$2) {
    GetCollectionResponse$2.inboundSchema = GetCollectionResponse$inboundSchema;
    GetCollectionResponse$2.outboundSchema = GetCollectionResponse$outboundSchema;
  })(GetCollectionResponse$ || (GetCollectionResponse$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/getdatasourceconfigrequest.js
  var GetDatasourceConfigRequest$inboundSchema = objectType({
    datasource: stringType()
  });
  var GetDatasourceConfigRequest$outboundSchema = objectType({
    datasource: stringType()
  });
  var GetDatasourceConfigRequest$;
  (function(GetDatasourceConfigRequest$2) {
    GetDatasourceConfigRequest$2.inboundSchema = GetDatasourceConfigRequest$inboundSchema;
    GetDatasourceConfigRequest$2.outboundSchema = GetDatasourceConfigRequest$outboundSchema;
  })(GetDatasourceConfigRequest$ || (GetDatasourceConfigRequest$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/getdlpreportresponse.js
  var GetDlpReportResponse$inboundSchema = objectType({
    report: DlpReport$inboundSchema.optional()
  });
  var GetDlpReportResponse$outboundSchema = objectType({
    report: DlpReport$outboundSchema.optional()
  });
  var GetDlpReportResponse$;
  (function(GetDlpReportResponse$2) {
    GetDlpReportResponse$2.inboundSchema = GetDlpReportResponse$inboundSchema;
    GetDlpReportResponse$2.outboundSchema = GetDlpReportResponse$outboundSchema;
  })(GetDlpReportResponse$ || (GetDlpReportResponse$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/getdocpermissionsrequest.js
  var GetDocPermissionsRequest$inboundSchema = objectType({
    documentId: stringType().optional()
  });
  var GetDocPermissionsRequest$outboundSchema = objectType({
    documentId: stringType().optional()
  });
  var GetDocPermissionsRequest$;
  (function(GetDocPermissionsRequest$2) {
    GetDocPermissionsRequest$2.inboundSchema = GetDocPermissionsRequest$inboundSchema;
    GetDocPermissionsRequest$2.outboundSchema = GetDocPermissionsRequest$outboundSchema;
  })(GetDocPermissionsRequest$ || (GetDocPermissionsRequest$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/getdocpermissionsresponse.js
  var GetDocPermissionsResponse$inboundSchema = objectType({
    allowedUserEmails: arrayType(stringType()).optional()
  });
  var GetDocPermissionsResponse$outboundSchema = objectType({
    allowedUserEmails: arrayType(stringType()).optional()
  });
  var GetDocPermissionsResponse$;
  (function(GetDocPermissionsResponse$2) {
    GetDocPermissionsResponse$2.inboundSchema = GetDocPermissionsResponse$inboundSchema;
    GetDocPermissionsResponse$2.outboundSchema = GetDocPermissionsResponse$outboundSchema;
  })(GetDocPermissionsResponse$ || (GetDocPermissionsResponse$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/getdocumentcountrequest.js
  var GetDocumentCountRequest$inboundSchema = objectType({
    datasource: stringType()
  });
  var GetDocumentCountRequest$outboundSchema = objectType({
    datasource: stringType()
  });
  var GetDocumentCountRequest$;
  (function(GetDocumentCountRequest$2) {
    GetDocumentCountRequest$2.inboundSchema = GetDocumentCountRequest$inboundSchema;
    GetDocumentCountRequest$2.outboundSchema = GetDocumentCountRequest$outboundSchema;
  })(GetDocumentCountRequest$ || (GetDocumentCountRequest$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/getdocumentcountresponse.js
  var GetDocumentCountResponse$inboundSchema = objectType({
    documentCount: numberType().int().optional()
  });
  var GetDocumentCountResponse$outboundSchema = objectType({
    documentCount: numberType().int().optional()
  });
  var GetDocumentCountResponse$;
  (function(GetDocumentCountResponse$2) {
    GetDocumentCountResponse$2.inboundSchema = GetDocumentCountResponse$inboundSchema;
    GetDocumentCountResponse$2.outboundSchema = GetDocumentCountResponse$outboundSchema;
  })(GetDocumentCountResponse$ || (GetDocumentCountResponse$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/getdocumentsbyfacetsrequest.js
  var GetDocumentsByFacetsRequest$inboundSchema = objectType({
    datasourcesFilter: arrayType(stringType()).optional(),
    filterSets: arrayType(FacetFilterSet$inboundSchema),
    cursor: stringType().optional()
  });
  var GetDocumentsByFacetsRequest$outboundSchema = objectType({
    datasourcesFilter: arrayType(stringType()).optional(),
    filterSets: arrayType(FacetFilterSet$outboundSchema),
    cursor: stringType().optional()
  });
  var GetDocumentsByFacetsRequest$;
  (function(GetDocumentsByFacetsRequest$2) {
    GetDocumentsByFacetsRequest$2.inboundSchema = GetDocumentsByFacetsRequest$inboundSchema;
    GetDocumentsByFacetsRequest$2.outboundSchema = GetDocumentsByFacetsRequest$outboundSchema;
  })(GetDocumentsByFacetsRequest$ || (GetDocumentsByFacetsRequest$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/getdocumentsbyfacetsresponse.js
  var GetDocumentsByFacetsResponse$inboundSchema = objectType({
    documents: arrayType(Document$inboundSchema).optional(),
    hasMoreResults: booleanType().optional(),
    cursor: stringType().optional()
  });
  var GetDocumentsByFacetsResponse$outboundSchema = objectType({
    documents: arrayType(Document$outboundSchema).optional(),
    hasMoreResults: booleanType().optional(),
    cursor: stringType().optional()
  });
  var GetDocumentsByFacetsResponse$;
  (function(GetDocumentsByFacetsResponse$2) {
    GetDocumentsByFacetsResponse$2.inboundSchema = GetDocumentsByFacetsResponse$inboundSchema;
    GetDocumentsByFacetsResponse$2.outboundSchema = GetDocumentsByFacetsResponse$outboundSchema;
  })(GetDocumentsByFacetsResponse$ || (GetDocumentsByFacetsResponse$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/getdocumentsrequest.js
  var GetDocumentsRequestIncludeField = {
    LastViewedAt: "LAST_VIEWED_AT",
    VisitorsCount: "VISITORS_COUNT",
    RecentShares: "RECENT_SHARES",
    DocumentContent: "DOCUMENT_CONTENT"
  };
  var GetDocumentsRequestIncludeField$inboundSchema = nativeEnumType(GetDocumentsRequestIncludeField);
  var GetDocumentsRequestIncludeField$outboundSchema = GetDocumentsRequestIncludeField$inboundSchema;
  var GetDocumentsRequestIncludeField$;
  (function(GetDocumentsRequestIncludeField$2) {
    GetDocumentsRequestIncludeField$2.inboundSchema = GetDocumentsRequestIncludeField$inboundSchema;
    GetDocumentsRequestIncludeField$2.outboundSchema = GetDocumentsRequestIncludeField$outboundSchema;
  })(GetDocumentsRequestIncludeField$ || (GetDocumentsRequestIncludeField$ = {}));
  var GetDocumentsRequest$inboundSchema = objectType({
    documentSpecs: arrayType(DocumentSpecUnion$inboundSchema),
    includeFields: arrayType(GetDocumentsRequestIncludeField$inboundSchema).optional()
  });
  var GetDocumentsRequest$outboundSchema = objectType({
    documentSpecs: arrayType(DocumentSpecUnion$outboundSchema),
    includeFields: arrayType(GetDocumentsRequestIncludeField$outboundSchema).optional()
  });
  var GetDocumentsRequest$;
  (function(GetDocumentsRequest$2) {
    GetDocumentsRequest$2.inboundSchema = GetDocumentsRequest$inboundSchema;
    GetDocumentsRequest$2.outboundSchema = GetDocumentsRequest$outboundSchema;
  })(GetDocumentsRequest$ || (GetDocumentsRequest$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/getdocumentsresponse.js
  var GetDocumentsResponse$inboundSchema = objectType({
    documents: recordType(DocumentOrErrorUnion$inboundSchema).optional()
  });
  var GetDocumentsResponse$outboundSchema = objectType({
    documents: recordType(DocumentOrErrorUnion$outboundSchema).optional()
  });
  var GetDocumentsResponse$;
  (function(GetDocumentsResponse$2) {
    GetDocumentsResponse$2.inboundSchema = GetDocumentsResponse$inboundSchema;
    GetDocumentsResponse$2.outboundSchema = GetDocumentsResponse$outboundSchema;
  })(GetDocumentsResponse$ || (GetDocumentsResponse$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/getdocumentstatusrequest.js
  var GetDocumentStatusRequest$inboundSchema = objectType({
    datasource: stringType(),
    objectType: stringType(),
    docId: stringType()
  });
  var GetDocumentStatusRequest$outboundSchema = objectType({
    datasource: stringType(),
    objectType: stringType(),
    docId: stringType()
  });
  var GetDocumentStatusRequest$;
  (function(GetDocumentStatusRequest$2) {
    GetDocumentStatusRequest$2.inboundSchema = GetDocumentStatusRequest$inboundSchema;
    GetDocumentStatusRequest$2.outboundSchema = GetDocumentStatusRequest$outboundSchema;
  })(GetDocumentStatusRequest$ || (GetDocumentStatusRequest$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/getdocumentstatusresponse.js
  var GetDocumentStatusResponse$inboundSchema = objectType({
    uploadStatus: stringType().optional(),
    lastUploadedAt: numberType().int().optional(),
    indexingStatus: stringType().optional(),
    lastIndexedAt: numberType().int().optional()
  });
  var GetDocumentStatusResponse$outboundSchema = objectType({
    uploadStatus: stringType().optional(),
    lastUploadedAt: numberType().int().optional(),
    indexingStatus: stringType().optional(),
    lastIndexedAt: numberType().int().optional()
  });
  var GetDocumentStatusResponse$;
  (function(GetDocumentStatusResponse$2) {
    GetDocumentStatusResponse$2.inboundSchema = GetDocumentStatusResponse$inboundSchema;
    GetDocumentStatusResponse$2.outboundSchema = GetDocumentStatusResponse$outboundSchema;
  })(GetDocumentStatusResponse$ || (GetDocumentStatusResponse$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/getdocumentvisibilityoverridesresponse.js
  var GetDocumentVisibilityOverridesResponse$inboundSchema = objectType({
    visibilityOverrides: arrayType(DocumentVisibilityOverride$inboundSchema).optional()
  });
  var GetDocumentVisibilityOverridesResponse$outboundSchema = objectType({
    visibilityOverrides: arrayType(DocumentVisibilityOverride$outboundSchema).optional()
  });
  var GetDocumentVisibilityOverridesResponse$;
  (function(GetDocumentVisibilityOverridesResponse$2) {
    GetDocumentVisibilityOverridesResponse$2.inboundSchema = GetDocumentVisibilityOverridesResponse$inboundSchema;
    GetDocumentVisibilityOverridesResponse$2.outboundSchema = GetDocumentVisibilityOverridesResponse$outboundSchema;
  })(GetDocumentVisibilityOverridesResponse$ || (GetDocumentVisibilityOverridesResponse$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/getpinrequest.js
  var GetPinRequest$inboundSchema = objectType({
    id: stringType().optional()
  });
  var GetPinRequest$outboundSchema = objectType({
    id: stringType().optional()
  });
  var GetPinRequest$;
  (function(GetPinRequest$2) {
    GetPinRequest$2.inboundSchema = GetPinRequest$inboundSchema;
    GetPinRequest$2.outboundSchema = GetPinRequest$outboundSchema;
  })(GetPinRequest$ || (GetPinRequest$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/getpinresponse.js
  var GetPinResponse$inboundSchema = objectType({
    pin: PinDocument$inboundSchema.optional()
  });
  var GetPinResponse$outboundSchema = objectType({
    pin: PinDocument$outboundSchema.optional()
  });
  var GetPinResponse$;
  (function(GetPinResponse$2) {
    GetPinResponse$2.inboundSchema = GetPinResponse$inboundSchema;
    GetPinResponse$2.outboundSchema = GetPinResponse$outboundSchema;
  })(GetPinResponse$ || (GetPinResponse$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/usergeneratedcontentid.js
  var UserGeneratedContentId$inboundSchema = objectType({
    id: numberType().int().optional()
  });
  var UserGeneratedContentId$outboundSchema = objectType({
    id: numberType().int().optional()
  });
  var UserGeneratedContentId$;
  (function(UserGeneratedContentId$2) {
    UserGeneratedContentId$2.inboundSchema = UserGeneratedContentId$inboundSchema;
    UserGeneratedContentId$2.outboundSchema = UserGeneratedContentId$outboundSchema;
  })(UserGeneratedContentId$ || (UserGeneratedContentId$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/getshortcutrequestunion.js
  var GetShortcutRequest$inboundSchema = objectType({
    alias: stringType()
  });
  var GetShortcutRequest$outboundSchema = objectType({
    alias: stringType()
  });
  var GetShortcutRequest$;
  (function(GetShortcutRequest$2) {
    GetShortcutRequest$2.inboundSchema = GetShortcutRequest$inboundSchema;
    GetShortcutRequest$2.outboundSchema = GetShortcutRequest$outboundSchema;
  })(GetShortcutRequest$ || (GetShortcutRequest$ = {}));
  var GetShortcutRequestUnion$inboundSchema = unionType([
    lazyType(() => GetShortcutRequest$inboundSchema),
    UserGeneratedContentId$inboundSchema
  ]);
  var GetShortcutRequestUnion$outboundSchema = unionType([
    lazyType(() => GetShortcutRequest$outboundSchema),
    UserGeneratedContentId$outboundSchema
  ]);
  var GetShortcutRequestUnion$;
  (function(GetShortcutRequestUnion$2) {
    GetShortcutRequestUnion$2.inboundSchema = GetShortcutRequestUnion$inboundSchema;
    GetShortcutRequestUnion$2.outboundSchema = GetShortcutRequestUnion$outboundSchema;
  })(GetShortcutRequestUnion$ || (GetShortcutRequestUnion$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/getshortcutresponse.js
  var GetShortcutResponse$inboundSchema = objectType({
    shortcut: Shortcut$inboundSchema.optional(),
    error: ShortcutError$inboundSchema.optional()
  });
  var GetShortcutResponse$outboundSchema = objectType({
    shortcut: Shortcut$outboundSchema.optional(),
    error: ShortcutError$outboundSchema.optional()
  });
  var GetShortcutResponse$;
  (function(GetShortcutResponse$2) {
    GetShortcutResponse$2.inboundSchema = GetShortcutResponse$inboundSchema;
    GetShortcutResponse$2.outboundSchema = GetShortcutResponse$outboundSchema;
  })(GetShortcutResponse$ || (GetShortcutResponse$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/getusercountrequest.js
  var GetUserCountRequest$inboundSchema = objectType({
    datasource: stringType()
  });
  var GetUserCountRequest$outboundSchema = objectType({
    datasource: stringType()
  });
  var GetUserCountRequest$;
  (function(GetUserCountRequest$2) {
    GetUserCountRequest$2.inboundSchema = GetUserCountRequest$inboundSchema;
    GetUserCountRequest$2.outboundSchema = GetUserCountRequest$outboundSchema;
  })(GetUserCountRequest$ || (GetUserCountRequest$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/getusercountresponse.js
  var GetUserCountResponse$inboundSchema = objectType({
    userCount: numberType().int().optional()
  });
  var GetUserCountResponse$outboundSchema = objectType({
    userCount: numberType().int().optional()
  });
  var GetUserCountResponse$;
  (function(GetUserCountResponse$2) {
    GetUserCountResponse$2.inboundSchema = GetUserCountResponse$inboundSchema;
    GetUserCountResponse$2.outboundSchema = GetUserCountResponse$outboundSchema;
  })(GetUserCountResponse$ || (GetUserCountResponse$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/gleanassistinsightsresponse.js
  var GleanAssistInsightsResponse$inboundSchema = objectType({
    lastLogTimestamp: numberType().int().optional(),
    activityInsights: arrayType(UserActivityInsight$inboundSchema).optional(),
    totalActiveUsers: numberType().int().optional(),
    datasourceInstances: arrayType(stringType()).optional(),
    departments: arrayType(stringType()).optional()
  });
  var GleanAssistInsightsResponse$outboundSchema = objectType({
    lastLogTimestamp: numberType().int().optional(),
    activityInsights: arrayType(UserActivityInsight$outboundSchema).optional(),
    totalActiveUsers: numberType().int().optional(),
    datasourceInstances: arrayType(stringType()).optional(),
    departments: arrayType(stringType()).optional()
  });
  var GleanAssistInsightsResponse$;
  (function(GleanAssistInsightsResponse$2) {
    GleanAssistInsightsResponse$2.inboundSchema = GleanAssistInsightsResponse$inboundSchema;
    GleanAssistInsightsResponse$2.outboundSchema = GleanAssistInsightsResponse$outboundSchema;
  })(GleanAssistInsightsResponse$ || (GleanAssistInsightsResponse$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/greenlistusersrequest.js
  var GreenlistUsersRequest$inboundSchema = objectType({
    datasource: stringType(),
    emails: arrayType(stringType())
  });
  var GreenlistUsersRequest$outboundSchema = objectType({
    datasource: stringType(),
    emails: arrayType(stringType())
  });
  var GreenlistUsersRequest$;
  (function(GreenlistUsersRequest$2) {
    GreenlistUsersRequest$2.inboundSchema = GreenlistUsersRequest$inboundSchema;
    GreenlistUsersRequest$2.outboundSchema = GreenlistUsersRequest$outboundSchema;
  })(GreenlistUsersRequest$ || (GreenlistUsersRequest$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/indexdocumentrequest.js
  var IndexDocumentRequest$inboundSchema = objectType({
    version: numberType().int().optional(),
    document: DocumentDefinition$inboundSchema
  });
  var IndexDocumentRequest$outboundSchema = objectType({
    version: numberType().int().optional(),
    document: DocumentDefinition$outboundSchema
  });
  var IndexDocumentRequest$;
  (function(IndexDocumentRequest$2) {
    IndexDocumentRequest$2.inboundSchema = IndexDocumentRequest$inboundSchema;
    IndexDocumentRequest$2.outboundSchema = IndexDocumentRequest$outboundSchema;
  })(IndexDocumentRequest$ || (IndexDocumentRequest$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/indexdocumentsrequest.js
  var IndexDocumentsRequest$inboundSchema = objectType({
    uploadId: stringType().optional(),
    datasource: stringType(),
    documents: arrayType(DocumentDefinition$inboundSchema)
  });
  var IndexDocumentsRequest$outboundSchema = objectType({
    uploadId: stringType().optional(),
    datasource: stringType(),
    documents: arrayType(DocumentDefinition$outboundSchema)
  });
  var IndexDocumentsRequest$;
  (function(IndexDocumentsRequest$2) {
    IndexDocumentsRequest$2.inboundSchema = IndexDocumentsRequest$inboundSchema;
    IndexDocumentsRequest$2.outboundSchema = IndexDocumentsRequest$outboundSchema;
  })(IndexDocumentsRequest$ || (IndexDocumentsRequest$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/indexemployeerequest.js
  var IndexEmployeeRequest$inboundSchema = objectType({
    employee: EmployeeInfoDefinition$inboundSchema,
    version: numberType().int().optional()
  });
  var IndexEmployeeRequest$outboundSchema = objectType({
    employee: EmployeeInfoDefinition$outboundSchema,
    version: numberType().int().optional()
  });
  var IndexEmployeeRequest$;
  (function(IndexEmployeeRequest$2) {
    IndexEmployeeRequest$2.inboundSchema = IndexEmployeeRequest$inboundSchema;
    IndexEmployeeRequest$2.outboundSchema = IndexEmployeeRequest$outboundSchema;
  })(IndexEmployeeRequest$ || (IndexEmployeeRequest$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/indexgrouprequest.js
  var IndexGroupRequest$inboundSchema = objectType({
    version: numberType().int().optional(),
    datasource: stringType(),
    group: DatasourceGroupDefinition$inboundSchema
  });
  var IndexGroupRequest$outboundSchema = objectType({
    version: numberType().int().optional(),
    datasource: stringType(),
    group: DatasourceGroupDefinition$outboundSchema
  });
  var IndexGroupRequest$;
  (function(IndexGroupRequest$2) {
    IndexGroupRequest$2.inboundSchema = IndexGroupRequest$inboundSchema;
    IndexGroupRequest$2.outboundSchema = IndexGroupRequest$outboundSchema;
  })(IndexGroupRequest$ || (IndexGroupRequest$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/indexingshortcut.js
  var IndexingShortcut$inboundSchema = objectType({
    inputAlias: stringType(),
    description: stringType().optional(),
    destinationUrl: stringType(),
    createdBy: stringType(),
    createTime: numberType().int().optional(),
    updatedBy: stringType().optional(),
    updateTime: numberType().int().optional(),
    unlisted: booleanType().optional(),
    urlTemplate: stringType().optional()
  });
  var IndexingShortcut$outboundSchema = objectType({
    inputAlias: stringType(),
    description: stringType().optional(),
    destinationUrl: stringType(),
    createdBy: stringType(),
    createTime: numberType().int().optional(),
    updatedBy: stringType().optional(),
    updateTime: numberType().int().optional(),
    unlisted: booleanType().optional(),
    urlTemplate: stringType().optional()
  });
  var IndexingShortcut$;
  (function(IndexingShortcut$2) {
    IndexingShortcut$2.inboundSchema = IndexingShortcut$inboundSchema;
    IndexingShortcut$2.outboundSchema = IndexingShortcut$outboundSchema;
  })(IndexingShortcut$ || (IndexingShortcut$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/indexmembershiprequest.js
  var IndexMembershipRequest$inboundSchema = objectType({
    version: numberType().int().optional(),
    datasource: stringType(),
    membership: DatasourceMembershipDefinition$inboundSchema
  });
  var IndexMembershipRequest$outboundSchema = objectType({
    version: numberType().int().optional(),
    datasource: stringType(),
    membership: DatasourceMembershipDefinition$outboundSchema
  });
  var IndexMembershipRequest$;
  (function(IndexMembershipRequest$2) {
    IndexMembershipRequest$2.inboundSchema = IndexMembershipRequest$inboundSchema;
    IndexMembershipRequest$2.outboundSchema = IndexMembershipRequest$outboundSchema;
  })(IndexMembershipRequest$ || (IndexMembershipRequest$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/indexteamrequest.js
  var IndexTeamRequest$inboundSchema = objectType({
    team: TeamInfoDefinition$inboundSchema,
    version: numberType().int().optional()
  });
  var IndexTeamRequest$outboundSchema = objectType({
    team: TeamInfoDefinition$outboundSchema,
    version: numberType().int().optional()
  });
  var IndexTeamRequest$;
  (function(IndexTeamRequest$2) {
    IndexTeamRequest$2.inboundSchema = IndexTeamRequest$inboundSchema;
    IndexTeamRequest$2.outboundSchema = IndexTeamRequest$outboundSchema;
  })(IndexTeamRequest$ || (IndexTeamRequest$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/indexuserrequest.js
  var IndexUserRequest$inboundSchema = objectType({
    version: numberType().int().optional(),
    datasource: stringType(),
    user: DatasourceUserDefinition$inboundSchema
  });
  var IndexUserRequest$outboundSchema = objectType({
    version: numberType().int().optional(),
    datasource: stringType(),
    user: DatasourceUserDefinition$outboundSchema
  });
  var IndexUserRequest$;
  (function(IndexUserRequest$2) {
    IndexUserRequest$2.inboundSchema = IndexUserRequest$inboundSchema;
    IndexUserRequest$2.outboundSchema = IndexUserRequest$outboundSchema;
  })(IndexUserRequest$ || (IndexUserRequest$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/insightsagentsrequestoptions.js
  var InsightsAgentsRequestOptions$inboundSchema = objectType({
    agentIds: arrayType(stringType()).optional()
  });
  var InsightsAgentsRequestOptions$outboundSchema = objectType({
    agentIds: arrayType(stringType()).optional()
  });
  var InsightsAgentsRequestOptions$;
  (function(InsightsAgentsRequestOptions$2) {
    InsightsAgentsRequestOptions$2.inboundSchema = InsightsAgentsRequestOptions$inboundSchema;
    InsightsAgentsRequestOptions$2.outboundSchema = InsightsAgentsRequestOptions$outboundSchema;
  })(InsightsAgentsRequestOptions$ || (InsightsAgentsRequestOptions$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/insightsaiapprequestoptions.js
  var InsightsAiAppRequestOptions$inboundSchema = objectType({
    aiAppIds: arrayType(stringType()).optional()
  });
  var InsightsAiAppRequestOptions$outboundSchema = objectType({
    aiAppIds: arrayType(stringType()).optional()
  });
  var InsightsAiAppRequestOptions$;
  (function(InsightsAiAppRequestOptions$2) {
    InsightsAiAppRequestOptions$2.inboundSchema = InsightsAiAppRequestOptions$inboundSchema;
    InsightsAiAppRequestOptions$2.outboundSchema = InsightsAiAppRequestOptions$outboundSchema;
  })(InsightsAiAppRequestOptions$ || (InsightsAiAppRequestOptions$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/insightsassistantrequest.js
  var InsightsAssistantRequest$inboundSchema = objectType({
    departments: arrayType(stringType()).optional(),
    dayRange: Period$inboundSchema.optional()
  });
  var InsightsAssistantRequest$outboundSchema = objectType({
    departments: arrayType(stringType()).optional(),
    dayRange: Period$outboundSchema.optional()
  });
  var InsightsAssistantRequest$;
  (function(InsightsAssistantRequest$2) {
    InsightsAssistantRequest$2.inboundSchema = InsightsAssistantRequest$inboundSchema;
    InsightsAssistantRequest$2.outboundSchema = InsightsAssistantRequest$outboundSchema;
  })(InsightsAssistantRequest$ || (InsightsAssistantRequest$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/insightsoverviewrequest.js
  var InsightsOverviewRequest$inboundSchema = objectType({
    departments: arrayType(stringType()).optional(),
    dayRange: Period$inboundSchema.optional()
  });
  var InsightsOverviewRequest$outboundSchema = objectType({
    departments: arrayType(stringType()).optional(),
    dayRange: Period$outboundSchema.optional()
  });
  var InsightsOverviewRequest$;
  (function(InsightsOverviewRequest$2) {
    InsightsOverviewRequest$2.inboundSchema = InsightsOverviewRequest$inboundSchema;
    InsightsOverviewRequest$2.outboundSchema = InsightsOverviewRequest$outboundSchema;
  })(InsightsOverviewRequest$ || (InsightsOverviewRequest$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/insightsrequest.js
  var InsightsRequestCategory = {
    Agents: "AGENTS",
    AgentUsers: "AGENT_USERS",
    TopAgents: "TOP_AGENTS",
    AgentsUsageByDepartment: "AGENTS_USAGE_BY_DEPARTMENT",
    Ai: "AI",
    AiApps: "AI_APPS",
    Announcements: "ANNOUNCEMENTS",
    Answers: "ANSWERS",
    Collections: "COLLECTIONS",
    Content: "CONTENT",
    GleanAssist: "GLEAN_ASSIST",
    Queries: "QUERIES",
    Shortcuts: "SHORTCUTS",
    Users: "USERS"
  };
  var AssistantActivityType = {
    GleanChat: "GLEAN_CHAT",
    AiSummary: "AI_SUMMARY",
    AiAnswer: "AI_ANSWER",
    GleanbotResponse: "GLEANBOT_RESPONSE"
  };
  var InsightsRequestCategory$inboundSchema = nativeEnumType(InsightsRequestCategory);
  var InsightsRequestCategory$outboundSchema = InsightsRequestCategory$inboundSchema;
  var InsightsRequestCategory$;
  (function(InsightsRequestCategory$2) {
    InsightsRequestCategory$2.inboundSchema = InsightsRequestCategory$inboundSchema;
    InsightsRequestCategory$2.outboundSchema = InsightsRequestCategory$outboundSchema;
  })(InsightsRequestCategory$ || (InsightsRequestCategory$ = {}));
  var AssistantActivityType$inboundSchema = nativeEnumType(AssistantActivityType);
  var AssistantActivityType$outboundSchema = AssistantActivityType$inboundSchema;
  var AssistantActivityType$;
  (function(AssistantActivityType$2) {
    AssistantActivityType$2.inboundSchema = AssistantActivityType$inboundSchema;
    AssistantActivityType$2.outboundSchema = AssistantActivityType$outboundSchema;
  })(AssistantActivityType$ || (AssistantActivityType$ = {}));
  var InsightsRequest$inboundSchema = objectType({
    overviewRequest: InsightsOverviewRequest$inboundSchema.optional(),
    assistantRequest: InsightsAssistantRequest$inboundSchema.optional(),
    agentsRequest: AgentsInsightsV2Request$inboundSchema.optional(),
    disablePerUserInsights: booleanType().optional(),
    categories: arrayType(InsightsRequestCategory$inboundSchema).optional(),
    departments: arrayType(stringType()).optional(),
    dayRange: Period$inboundSchema.optional(),
    aiAppRequestOptions: InsightsAiAppRequestOptions$inboundSchema.optional(),
    agentsRequestOptions: InsightsAgentsRequestOptions$inboundSchema.optional(),
    assistantActivityTypes: arrayType(AssistantActivityType$inboundSchema).optional()
  });
  var InsightsRequest$outboundSchema = objectType({
    overviewRequest: InsightsOverviewRequest$outboundSchema.optional(),
    assistantRequest: InsightsAssistantRequest$outboundSchema.optional(),
    agentsRequest: AgentsInsightsV2Request$outboundSchema.optional(),
    disablePerUserInsights: booleanType().optional(),
    categories: arrayType(InsightsRequestCategory$outboundSchema).optional(),
    departments: arrayType(stringType()).optional(),
    dayRange: Period$outboundSchema.optional(),
    aiAppRequestOptions: InsightsAiAppRequestOptions$outboundSchema.optional(),
    agentsRequestOptions: InsightsAgentsRequestOptions$outboundSchema.optional(),
    assistantActivityTypes: arrayType(AssistantActivityType$outboundSchema).optional()
  });
  var InsightsRequest$;
  (function(InsightsRequest$2) {
    InsightsRequest$2.inboundSchema = InsightsRequest$inboundSchema;
    InsightsRequest$2.outboundSchema = InsightsRequest$outboundSchema;
  })(InsightsRequest$ || (InsightsRequest$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/labeledcountinfo.js
  var LabeledCountInfo$inboundSchema = objectType({
    label: stringType(),
    countInfo: arrayType(CountInfo$inboundSchema).optional()
  });
  var LabeledCountInfo$outboundSchema = objectType({
    label: stringType(),
    countInfo: arrayType(CountInfo$outboundSchema).optional()
  });
  var LabeledCountInfo$;
  (function(LabeledCountInfo$2) {
    LabeledCountInfo$2.inboundSchema = LabeledCountInfo$inboundSchema;
    LabeledCountInfo$2.outboundSchema = LabeledCountInfo$outboundSchema;
  })(LabeledCountInfo$ || (LabeledCountInfo$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/queryinsight.js
  var QueryInsight$inboundSchema = objectType({
    query: stringType(),
    searchCount: CountInfo$inboundSchema.optional(),
    searchorCount: CountInfo$inboundSchema.optional(),
    searchWithClickCount: CountInfo$inboundSchema.optional(),
    clickCount: CountInfo$inboundSchema.optional(),
    similarQueries: arrayType(lazyType(() => QueryInsight$inboundSchema)).optional()
  });
  var QueryInsight$outboundSchema = objectType({
    query: stringType(),
    searchCount: CountInfo$outboundSchema.optional(),
    searchorCount: CountInfo$outboundSchema.optional(),
    searchWithClickCount: CountInfo$outboundSchema.optional(),
    clickCount: CountInfo$outboundSchema.optional(),
    similarQueries: arrayType(lazyType(() => QueryInsight$outboundSchema)).optional()
  });
  var QueryInsight$;
  (function(QueryInsight$2) {
    QueryInsight$2.inboundSchema = QueryInsight$inboundSchema;
    QueryInsight$2.outboundSchema = QueryInsight$outboundSchema;
  })(QueryInsight$ || (QueryInsight$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/queryinsightsresponse.js
  var QueryInsightsResponse$inboundSchema = objectType({
    lastLogTimestamp: numberType().int().optional(),
    queryInsights: arrayType(QueryInsight$inboundSchema).optional(),
    lowPerformingQueryInsights: arrayType(QueryInsight$inboundSchema).optional(),
    departments: arrayType(stringType()).optional(),
    minVisitorThreshold: numberType().int().optional()
  });
  var QueryInsightsResponse$outboundSchema = objectType({
    lastLogTimestamp: numberType().int().optional(),
    queryInsights: arrayType(QueryInsight$outboundSchema).optional(),
    lowPerformingQueryInsights: arrayType(QueryInsight$outboundSchema).optional(),
    departments: arrayType(stringType()).optional(),
    minVisitorThreshold: numberType().int().optional()
  });
  var QueryInsightsResponse$;
  (function(QueryInsightsResponse$2) {
    QueryInsightsResponse$2.inboundSchema = QueryInsightsResponse$inboundSchema;
    QueryInsightsResponse$2.outboundSchema = QueryInsightsResponse$outboundSchema;
  })(QueryInsightsResponse$ || (QueryInsightsResponse$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/shortcutinsight.js
  var ShortcutInsight$inboundSchema = objectType({
    shortcut: Shortcut$inboundSchema,
    visitCount: CountInfo$inboundSchema.optional(),
    visitorCount: CountInfo$inboundSchema.optional()
  });
  var ShortcutInsight$outboundSchema = objectType({
    shortcut: Shortcut$outboundSchema,
    visitCount: CountInfo$outboundSchema.optional(),
    visitorCount: CountInfo$outboundSchema.optional()
  });
  var ShortcutInsight$;
  (function(ShortcutInsight$2) {
    ShortcutInsight$2.inboundSchema = ShortcutInsight$inboundSchema;
    ShortcutInsight$2.outboundSchema = ShortcutInsight$outboundSchema;
  })(ShortcutInsight$ || (ShortcutInsight$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/shortcutinsightsresponse.js
  var ShortcutInsightsResponse$inboundSchema = objectType({
    lastLogTimestamp: numberType().int().optional(),
    shortcutInsights: arrayType(ShortcutInsight$inboundSchema).optional(),
    departments: arrayType(stringType()).optional(),
    minVisitorThreshold: numberType().int().optional()
  });
  var ShortcutInsightsResponse$outboundSchema = objectType({
    lastLogTimestamp: numberType().int().optional(),
    shortcutInsights: arrayType(ShortcutInsight$outboundSchema).optional(),
    departments: arrayType(stringType()).optional(),
    minVisitorThreshold: numberType().int().optional()
  });
  var ShortcutInsightsResponse$;
  (function(ShortcutInsightsResponse$2) {
    ShortcutInsightsResponse$2.inboundSchema = ShortcutInsightsResponse$inboundSchema;
    ShortcutInsightsResponse$2.outboundSchema = ShortcutInsightsResponse$outboundSchema;
  })(ShortcutInsightsResponse$ || (ShortcutInsightsResponse$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/userinsightsresponse.js
  var UserInsightsResponse$inboundSchema = objectType({
    lastLogTimestamp: numberType().int().optional(),
    activityInsights: arrayType(UserActivityInsight$inboundSchema).optional(),
    inactiveInsights: arrayType(UserActivityInsight$inboundSchema).optional(),
    totalTeammates: numberType().int().optional(),
    totalActiveUsers: numberType().int().optional(),
    departments: arrayType(stringType()).optional()
  });
  var UserInsightsResponse$outboundSchema = objectType({
    lastLogTimestamp: numberType().int().optional(),
    activityInsights: arrayType(UserActivityInsight$outboundSchema).optional(),
    inactiveInsights: arrayType(UserActivityInsight$outboundSchema).optional(),
    totalTeammates: numberType().int().optional(),
    totalActiveUsers: numberType().int().optional(),
    departments: arrayType(stringType()).optional()
  });
  var UserInsightsResponse$;
  (function(UserInsightsResponse$2) {
    UserInsightsResponse$2.inboundSchema = UserInsightsResponse$inboundSchema;
    UserInsightsResponse$2.outboundSchema = UserInsightsResponse$outboundSchema;
  })(UserInsightsResponse$ || (UserInsightsResponse$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/insightsresponse.js
  var InsightsResponse$inboundSchema = objectType({
    timeseries: arrayType(LabeledCountInfo$inboundSchema).optional(),
    users: UserInsightsResponse$inboundSchema.optional(),
    content: ContentInsightsResponse$inboundSchema.optional(),
    queries: QueryInsightsResponse$inboundSchema.optional(),
    collections: ContentInsightsResponse$inboundSchema.optional(),
    collectionsV2: ContentInsightsResponse$inboundSchema.optional(),
    shortcuts: ShortcutInsightsResponse$inboundSchema.optional(),
    announcements: ContentInsightsResponse$inboundSchema.optional(),
    answers: ContentInsightsResponse$inboundSchema.optional(),
    ai: AiInsightsResponse$inboundSchema.optional(),
    aiApps: AiAppsInsightsResponse$inboundSchema.optional(),
    gleanAssist: GleanAssistInsightsResponse$inboundSchema.optional(),
    departments: arrayType(stringType()).optional()
  });
  var InsightsResponse$outboundSchema = objectType({
    timeseries: arrayType(LabeledCountInfo$outboundSchema).optional(),
    users: UserInsightsResponse$outboundSchema.optional(),
    content: ContentInsightsResponse$outboundSchema.optional(),
    queries: QueryInsightsResponse$outboundSchema.optional(),
    collections: ContentInsightsResponse$outboundSchema.optional(),
    collectionsV2: ContentInsightsResponse$outboundSchema.optional(),
    shortcuts: ShortcutInsightsResponse$outboundSchema.optional(),
    announcements: ContentInsightsResponse$outboundSchema.optional(),
    answers: ContentInsightsResponse$outboundSchema.optional(),
    ai: AiInsightsResponse$outboundSchema.optional(),
    aiApps: AiAppsInsightsResponse$outboundSchema.optional(),
    gleanAssist: GleanAssistInsightsResponse$outboundSchema.optional(),
    departments: arrayType(stringType()).optional()
  });
  var InsightsResponse$;
  (function(InsightsResponse$2) {
    InsightsResponse$2.inboundSchema = InsightsResponse$inboundSchema;
    InsightsResponse$2.outboundSchema = InsightsResponse$outboundSchema;
  })(InsightsResponse$ || (InsightsResponse$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/listanswersrequest.js
  var ListAnswersRequest$inboundSchema = objectType({
    boardId: numberType().int().optional()
  });
  var ListAnswersRequest$outboundSchema = objectType({
    boardId: numberType().int().optional()
  });
  var ListAnswersRequest$;
  (function(ListAnswersRequest$2) {
    ListAnswersRequest$2.inboundSchema = ListAnswersRequest$inboundSchema;
    ListAnswersRequest$2.outboundSchema = ListAnswersRequest$outboundSchema;
  })(ListAnswersRequest$ || (ListAnswersRequest$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/listanswersresponse.js
  var ListAnswersResponse$inboundSchema = objectType({
    answerResults: arrayType(AnswerResult$inboundSchema)
  });
  var ListAnswersResponse$outboundSchema = objectType({
    answerResults: arrayType(AnswerResult$outboundSchema)
  });
  var ListAnswersResponse$;
  (function(ListAnswersResponse$2) {
    ListAnswersResponse$2.inboundSchema = ListAnswersResponse$inboundSchema;
    ListAnswersResponse$2.outboundSchema = ListAnswersResponse$outboundSchema;
  })(ListAnswersResponse$ || (ListAnswersResponse$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/listchatsresponse.js
  var ListChatsResponse$inboundSchema = objectType({
    chatResults: arrayType(ChatMetadataResult$inboundSchema).optional()
  });
  var ListChatsResponse$outboundSchema = objectType({
    chatResults: arrayType(ChatMetadataResult$outboundSchema).optional()
  });
  var ListChatsResponse$;
  (function(ListChatsResponse$2) {
    ListChatsResponse$2.inboundSchema = ListChatsResponse$inboundSchema;
    ListChatsResponse$2.outboundSchema = ListChatsResponse$outboundSchema;
  })(ListChatsResponse$ || (ListChatsResponse$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/listcollectionsrequest.js
  var ListCollectionsRequest$inboundSchema = objectType({
    includeAudience: booleanType().optional(),
    includeRoles: booleanType().optional(),
    allowedDatasource: stringType().optional()
  });
  var ListCollectionsRequest$outboundSchema = objectType({
    includeAudience: booleanType().optional(),
    includeRoles: booleanType().optional(),
    allowedDatasource: stringType().optional()
  });
  var ListCollectionsRequest$;
  (function(ListCollectionsRequest$2) {
    ListCollectionsRequest$2.inboundSchema = ListCollectionsRequest$inboundSchema;
    ListCollectionsRequest$2.outboundSchema = ListCollectionsRequest$outboundSchema;
  })(ListCollectionsRequest$ || (ListCollectionsRequest$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/listcollectionsresponse.js
  var ListCollectionsResponse$inboundSchema = objectType({
    collections: arrayType(Collection$inboundSchema)
  });
  var ListCollectionsResponse$outboundSchema = objectType({
    collections: arrayType(Collection$outboundSchema)
  });
  var ListCollectionsResponse$;
  (function(ListCollectionsResponse$2) {
    ListCollectionsResponse$2.inboundSchema = ListCollectionsResponse$inboundSchema;
    ListCollectionsResponse$2.outboundSchema = ListCollectionsResponse$outboundSchema;
  })(ListCollectionsResponse$ || (ListCollectionsResponse$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/listdlpreportsresponse.js
  var ListDlpReportsResponse$inboundSchema = objectType({
    reports: arrayType(DlpReport$inboundSchema).optional()
  });
  var ListDlpReportsResponse$outboundSchema = objectType({
    reports: arrayType(DlpReport$outboundSchema).optional()
  });
  var ListDlpReportsResponse$;
  (function(ListDlpReportsResponse$2) {
    ListDlpReportsResponse$2.inboundSchema = ListDlpReportsResponse$inboundSchema;
    ListDlpReportsResponse$2.outboundSchema = ListDlpReportsResponse$outboundSchema;
  })(ListDlpReportsResponse$ || (ListDlpReportsResponse$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/sortoptions.js
  var OrderBy = {
    Asc: "ASC",
    Desc: "DESC"
  };
  var OrderBy$inboundSchema = nativeEnumType(OrderBy);
  var OrderBy$outboundSchema = OrderBy$inboundSchema;
  var OrderBy$;
  (function(OrderBy$2) {
    OrderBy$2.inboundSchema = OrderBy$inboundSchema;
    OrderBy$2.outboundSchema = OrderBy$outboundSchema;
  })(OrderBy$ || (OrderBy$ = {}));
  var SortOptions$inboundSchema = objectType({
    orderBy: OrderBy$inboundSchema.optional(),
    sortBy: stringType().optional()
  });
  var SortOptions$outboundSchema = objectType({
    orderBy: OrderBy$outboundSchema.optional(),
    sortBy: stringType().optional()
  });
  var SortOptions$;
  (function(SortOptions$2) {
    SortOptions$2.inboundSchema = SortOptions$inboundSchema;
    SortOptions$2.outboundSchema = SortOptions$outboundSchema;
  })(SortOptions$ || (SortOptions$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/listentitiesrequest.js
  var ListEntitiesRequestEntityType = {
    People: "PEOPLE",
    Teams: "TEAMS",
    CustomEntities: "CUSTOM_ENTITIES"
  };
  var ListEntitiesRequestIncludeField = {
    People: "PEOPLE",
    Teams: "TEAMS",
    PeopleDistance: "PEOPLE_DISTANCE",
    Permissions: "PERMISSIONS",
    Facets: "FACETS",
    InviteInfo: "INVITE_INFO",
    LastExtensionUse: "LAST_EXTENSION_USE",
    ManagementDetails: "MANAGEMENT_DETAILS",
    UnprocessedTeams: "UNPROCESSED_TEAMS"
  };
  var RequestType = {
    Standard: "STANDARD",
    FullDirectory: "FULL_DIRECTORY"
  };
  var ListEntitiesRequestEntityType$inboundSchema = nativeEnumType(ListEntitiesRequestEntityType);
  var ListEntitiesRequestEntityType$outboundSchema = ListEntitiesRequestEntityType$inboundSchema;
  var ListEntitiesRequestEntityType$;
  (function(ListEntitiesRequestEntityType$2) {
    ListEntitiesRequestEntityType$2.inboundSchema = ListEntitiesRequestEntityType$inboundSchema;
    ListEntitiesRequestEntityType$2.outboundSchema = ListEntitiesRequestEntityType$outboundSchema;
  })(ListEntitiesRequestEntityType$ || (ListEntitiesRequestEntityType$ = {}));
  var ListEntitiesRequestIncludeField$inboundSchema = nativeEnumType(ListEntitiesRequestIncludeField);
  var ListEntitiesRequestIncludeField$outboundSchema = ListEntitiesRequestIncludeField$inboundSchema;
  var ListEntitiesRequestIncludeField$;
  (function(ListEntitiesRequestIncludeField$2) {
    ListEntitiesRequestIncludeField$2.inboundSchema = ListEntitiesRequestIncludeField$inboundSchema;
    ListEntitiesRequestIncludeField$2.outboundSchema = ListEntitiesRequestIncludeField$outboundSchema;
  })(ListEntitiesRequestIncludeField$ || (ListEntitiesRequestIncludeField$ = {}));
  var RequestType$inboundSchema = nativeEnumType(RequestType);
  var RequestType$outboundSchema = RequestType$inboundSchema;
  var RequestType$;
  (function(RequestType$2) {
    RequestType$2.inboundSchema = RequestType$inboundSchema;
    RequestType$2.outboundSchema = RequestType$outboundSchema;
  })(RequestType$ || (RequestType$ = {}));
  var ListEntitiesRequest$inboundSchema = objectType({
    filter: arrayType(FacetFilter$inboundSchema).optional(),
    sort: arrayType(SortOptions$inboundSchema).optional(),
    entityType: ListEntitiesRequestEntityType$inboundSchema.default("PEOPLE"),
    datasource: stringType().optional(),
    query: stringType().optional(),
    includeFields: arrayType(ListEntitiesRequestIncludeField$inboundSchema).optional(),
    pageSize: numberType().int().optional(),
    cursor: stringType().optional(),
    source: stringType().optional(),
    requestType: RequestType$inboundSchema.default("STANDARD")
  });
  var ListEntitiesRequest$outboundSchema = objectType({
    filter: arrayType(FacetFilter$outboundSchema).optional(),
    sort: arrayType(SortOptions$outboundSchema).optional(),
    entityType: ListEntitiesRequestEntityType$outboundSchema.default("PEOPLE"),
    datasource: stringType().optional(),
    query: stringType().optional(),
    includeFields: arrayType(ListEntitiesRequestIncludeField$outboundSchema).optional(),
    pageSize: numberType().int().optional(),
    cursor: stringType().optional(),
    source: stringType().optional(),
    requestType: RequestType$outboundSchema.default("STANDARD")
  });
  var ListEntitiesRequest$;
  (function(ListEntitiesRequest$2) {
    ListEntitiesRequest$2.inboundSchema = ListEntitiesRequest$inboundSchema;
    ListEntitiesRequest$2.outboundSchema = ListEntitiesRequest$outboundSchema;
  })(ListEntitiesRequest$ || (ListEntitiesRequest$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/listentitiesresponse.js
  var ListEntitiesResponse$inboundSchema = objectType({
    results: arrayType(Person$inboundSchema).optional(),
    teamResults: arrayType(Team$inboundSchema).optional(),
    customEntityResults: arrayType(CustomEntity$inboundSchema).optional(),
    facetResults: arrayType(FacetResult$inboundSchema).optional(),
    cursor: stringType().optional(),
    totalCount: numberType().int().optional(),
    hasMoreResults: booleanType().optional(),
    sortOptions: arrayType(EntitiesSortOrder$inboundSchema).optional(),
    customFacetNames: arrayType(stringType()).optional()
  });
  var ListEntitiesResponse$outboundSchema = objectType({
    results: arrayType(Person$outboundSchema).optional(),
    teamResults: arrayType(Team$outboundSchema).optional(),
    customEntityResults: arrayType(CustomEntity$outboundSchema).optional(),
    facetResults: arrayType(FacetResult$outboundSchema).optional(),
    cursor: stringType().optional(),
    totalCount: numberType().int().optional(),
    hasMoreResults: booleanType().optional(),
    sortOptions: arrayType(EntitiesSortOrder$outboundSchema).optional(),
    customFacetNames: arrayType(stringType()).optional()
  });
  var ListEntitiesResponse$;
  (function(ListEntitiesResponse$2) {
    ListEntitiesResponse$2.inboundSchema = ListEntitiesResponse$inboundSchema;
    ListEntitiesResponse$2.outboundSchema = ListEntitiesResponse$outboundSchema;
  })(ListEntitiesResponse$ || (ListEntitiesResponse$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/listpinsresponse.js
  var ListPinsResponse$inboundSchema = objectType({
    pins: arrayType(PinDocument$inboundSchema)
  });
  var ListPinsResponse$outboundSchema = objectType({
    pins: arrayType(PinDocument$outboundSchema)
  });
  var ListPinsResponse$;
  (function(ListPinsResponse$2) {
    ListPinsResponse$2.inboundSchema = ListPinsResponse$inboundSchema;
    ListPinsResponse$2.outboundSchema = ListPinsResponse$outboundSchema;
  })(ListPinsResponse$ || (ListPinsResponse$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/listshortcutspaginatedrequest.js
  var ListShortcutsPaginatedRequestIncludeField = {
    Facets: "FACETS",
    PeopleDetails: "PEOPLE_DETAILS"
  };
  var ListShortcutsPaginatedRequestIncludeField$inboundSchema = nativeEnumType(ListShortcutsPaginatedRequestIncludeField);
  var ListShortcutsPaginatedRequestIncludeField$outboundSchema = ListShortcutsPaginatedRequestIncludeField$inboundSchema;
  var ListShortcutsPaginatedRequestIncludeField$;
  (function(ListShortcutsPaginatedRequestIncludeField$2) {
    ListShortcutsPaginatedRequestIncludeField$2.inboundSchema = ListShortcutsPaginatedRequestIncludeField$inboundSchema;
    ListShortcutsPaginatedRequestIncludeField$2.outboundSchema = ListShortcutsPaginatedRequestIncludeField$outboundSchema;
  })(ListShortcutsPaginatedRequestIncludeField$ || (ListShortcutsPaginatedRequestIncludeField$ = {}));
  var ListShortcutsPaginatedRequest$inboundSchema = objectType({
    includeFields: arrayType(ListShortcutsPaginatedRequestIncludeField$inboundSchema).optional(),
    pageSize: numberType().int(),
    cursor: stringType().optional(),
    filters: arrayType(FacetFilter$inboundSchema).optional(),
    sort: SortOptions$inboundSchema.optional(),
    query: stringType().optional()
  });
  var ListShortcutsPaginatedRequest$outboundSchema = objectType({
    includeFields: arrayType(ListShortcutsPaginatedRequestIncludeField$outboundSchema).optional(),
    pageSize: numberType().int(),
    cursor: stringType().optional(),
    filters: arrayType(FacetFilter$outboundSchema).optional(),
    sort: SortOptions$outboundSchema.optional(),
    query: stringType().optional()
  });
  var ListShortcutsPaginatedRequest$;
  (function(ListShortcutsPaginatedRequest$2) {
    ListShortcutsPaginatedRequest$2.inboundSchema = ListShortcutsPaginatedRequest$inboundSchema;
    ListShortcutsPaginatedRequest$2.outboundSchema = ListShortcutsPaginatedRequest$outboundSchema;
  })(ListShortcutsPaginatedRequest$ || (ListShortcutsPaginatedRequest$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/shortcutspaginationmetadata.js
  var ShortcutsPaginationMetadata$inboundSchema = objectType({
    cursor: stringType().optional(),
    hasNextPage: booleanType().optional(),
    totalItemCount: numberType().int().optional()
  });
  var ShortcutsPaginationMetadata$outboundSchema = objectType({
    cursor: stringType().optional(),
    hasNextPage: booleanType().optional(),
    totalItemCount: numberType().int().optional()
  });
  var ShortcutsPaginationMetadata$;
  (function(ShortcutsPaginationMetadata$2) {
    ShortcutsPaginationMetadata$2.inboundSchema = ShortcutsPaginationMetadata$inboundSchema;
    ShortcutsPaginationMetadata$2.outboundSchema = ShortcutsPaginationMetadata$outboundSchema;
  })(ShortcutsPaginationMetadata$ || (ShortcutsPaginationMetadata$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/listshortcutspaginatedresponse.js
  var ListShortcutsPaginatedResponse$inboundSchema = objectType({
    shortcuts: arrayType(Shortcut$inboundSchema),
    facetResults: arrayType(FacetResult$inboundSchema).optional(),
    meta: ShortcutsPaginationMetadata$inboundSchema
  });
  var ListShortcutsPaginatedResponse$outboundSchema = objectType({
    shortcuts: arrayType(Shortcut$outboundSchema),
    facetResults: arrayType(FacetResult$outboundSchema).optional(),
    meta: ShortcutsPaginationMetadata$outboundSchema
  });
  var ListShortcutsPaginatedResponse$;
  (function(ListShortcutsPaginatedResponse$2) {
    ListShortcutsPaginatedResponse$2.inboundSchema = ListShortcutsPaginatedResponse$inboundSchema;
    ListShortcutsPaginatedResponse$2.outboundSchema = ListShortcutsPaginatedResponse$outboundSchema;
  })(ListShortcutsPaginatedResponse$ || (ListShortcutsPaginatedResponse$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/messagesrequest.js
  var IdType = {
    ChannelName: "CHANNEL_NAME",
    ThreadId: "THREAD_ID",
    ConversationId: "CONVERSATION_ID"
  };
  var Direction = {
    Older: "OLDER",
    Newer: "NEWER"
  };
  var Datasource = {
    Slack: "SLACK",
    Microsoftteams: "MICROSOFTTEAMS",
    Facebookworkplace: "FACEBOOKWORKPLACE"
  };
  var IdType$inboundSchema = nativeEnumType(IdType);
  var IdType$outboundSchema = IdType$inboundSchema;
  var IdType$;
  (function(IdType$2) {
    IdType$2.inboundSchema = IdType$inboundSchema;
    IdType$2.outboundSchema = IdType$outboundSchema;
  })(IdType$ || (IdType$ = {}));
  var Direction$inboundSchema = nativeEnumType(Direction);
  var Direction$outboundSchema = Direction$inboundSchema;
  var Direction$;
  (function(Direction$2) {
    Direction$2.inboundSchema = Direction$inboundSchema;
    Direction$2.outboundSchema = Direction$outboundSchema;
  })(Direction$ || (Direction$ = {}));
  var Datasource$inboundSchema = nativeEnumType(Datasource);
  var Datasource$outboundSchema = Datasource$inboundSchema;
  var Datasource$;
  (function(Datasource$2) {
    Datasource$2.inboundSchema = Datasource$inboundSchema;
    Datasource$2.outboundSchema = Datasource$outboundSchema;
  })(Datasource$ || (Datasource$ = {}));
  var MessagesRequest$inboundSchema = objectType({
    idType: IdType$inboundSchema,
    id: stringType(),
    workspaceId: stringType().optional(),
    direction: Direction$inboundSchema.optional(),
    timestampMillis: numberType().int().optional(),
    includeRootMessage: booleanType().optional(),
    datasource: Datasource$inboundSchema.optional(),
    datasourceInstanceDisplayName: stringType().optional()
  });
  var MessagesRequest$outboundSchema = objectType({
    idType: IdType$outboundSchema,
    id: stringType(),
    workspaceId: stringType().optional(),
    direction: Direction$outboundSchema.optional(),
    timestampMillis: numberType().int().optional(),
    includeRootMessage: booleanType().optional(),
    datasource: Datasource$outboundSchema.optional(),
    datasourceInstanceDisplayName: stringType().optional()
  });
  var MessagesRequest$;
  (function(MessagesRequest$2) {
    MessagesRequest$2.inboundSchema = MessagesRequest$inboundSchema;
    MessagesRequest$2.outboundSchema = MessagesRequest$outboundSchema;
  })(MessagesRequest$ || (MessagesRequest$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/resultsdescription.js
  var ResultsDescription$inboundSchema = objectType({
    text: stringType().optional(),
    iconConfig: IconConfig$inboundSchema.optional()
  });
  var ResultsDescription$outboundSchema = objectType({
    text: stringType().optional(),
    iconConfig: IconConfig$outboundSchema.optional()
  });
  var ResultsDescription$;
  (function(ResultsDescription$2) {
    ResultsDescription$2.inboundSchema = ResultsDescription$inboundSchema;
    ResultsDescription$2.outboundSchema = ResultsDescription$outboundSchema;
  })(ResultsDescription$ || (ResultsDescription$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/resulttab.js
  var ResultTab$inboundSchema = objectType({
    id: stringType().optional(),
    count: numberType().int().optional(),
    datasource: stringType().optional(),
    datasourceInstance: stringType().optional()
  });
  var ResultTab$outboundSchema = objectType({
    id: stringType().optional(),
    count: numberType().int().optional(),
    datasource: stringType().optional(),
    datasourceInstance: stringType().optional()
  });
  var ResultTab$;
  (function(ResultTab$2) {
    ResultTab$2.inboundSchema = ResultTab$inboundSchema;
    ResultTab$2.outboundSchema = ResultTab$outboundSchema;
  })(ResultTab$ || (ResultTab$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/searchwarning.js
  var WarningType = {
    LongQuery: "LONG_QUERY",
    QuotedPunctuation: "QUOTED_PUNCTUATION",
    PunctuationOnly: "PUNCTUATION_ONLY",
    CopypastedQuotes: "COPYPASTED_QUOTES",
    InvalidOperator: "INVALID_OPERATOR",
    MaybeInvalidFacetQuery: "MAYBE_INVALID_FACET_QUERY",
    TooManyDatasourceGroups: "TOO_MANY_DATASOURCE_GROUPS"
  };
  var WarningType$inboundSchema = nativeEnumType(WarningType);
  var WarningType$outboundSchema = WarningType$inboundSchema;
  var WarningType$;
  (function(WarningType$2) {
    WarningType$2.inboundSchema = WarningType$inboundSchema;
    WarningType$2.outboundSchema = WarningType$outboundSchema;
  })(WarningType$ || (WarningType$ = {}));
  var SearchWarning$inboundSchema = objectType({
    warningType: WarningType$inboundSchema,
    lastUsedTerm: stringType().optional(),
    quotesIgnoredQuery: stringType().optional(),
    ignoredTerms: arrayType(stringType()).optional()
  });
  var SearchWarning$outboundSchema = objectType({
    warningType: WarningType$outboundSchema,
    lastUsedTerm: stringType().optional(),
    quotesIgnoredQuery: stringType().optional(),
    ignoredTerms: arrayType(stringType()).optional()
  });
  var SearchWarning$;
  (function(SearchWarning$2) {
    SearchWarning$2.inboundSchema = SearchWarning$inboundSchema;
    SearchWarning$2.outboundSchema = SearchWarning$outboundSchema;
  })(SearchWarning$ || (SearchWarning$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/searchresponsemetadata.js
  var SearchResponseMetadata$inboundSchema = objectType({
    rewrittenQuery: stringType().optional(),
    searchedQuery: stringType().optional(),
    searchedQueryWithoutNegation: stringType().optional(),
    searchedQueryRanges: arrayType(TextRange$inboundSchema).optional(),
    originalQuery: stringType().optional(),
    querySuggestion: QuerySuggestion$inboundSchema.optional(),
    additionalQuerySuggestions: QuerySuggestionList$inboundSchema.optional(),
    negatedTerms: arrayType(stringType()).optional(),
    modifiedQueryWasUsed: booleanType().optional(),
    originalQueryHadNoResults: booleanType().optional(),
    searchWarning: SearchWarning$inboundSchema.optional(),
    triggeredExpertDetection: booleanType().optional(),
    isNoQuotesSuggestion: booleanType().optional()
  });
  var SearchResponseMetadata$outboundSchema = objectType({
    rewrittenQuery: stringType().optional(),
    searchedQuery: stringType().optional(),
    searchedQueryWithoutNegation: stringType().optional(),
    searchedQueryRanges: arrayType(TextRange$outboundSchema).optional(),
    originalQuery: stringType().optional(),
    querySuggestion: QuerySuggestion$outboundSchema.optional(),
    additionalQuerySuggestions: QuerySuggestionList$outboundSchema.optional(),
    negatedTerms: arrayType(stringType()).optional(),
    modifiedQueryWasUsed: booleanType().optional(),
    originalQueryHadNoResults: booleanType().optional(),
    searchWarning: SearchWarning$outboundSchema.optional(),
    triggeredExpertDetection: booleanType().optional(),
    isNoQuotesSuggestion: booleanType().optional()
  });
  var SearchResponseMetadata$;
  (function(SearchResponseMetadata$2) {
    SearchResponseMetadata$2.inboundSchema = SearchResponseMetadata$inboundSchema;
    SearchResponseMetadata$2.outboundSchema = SearchResponseMetadata$outboundSchema;
  })(SearchResponseMetadata$ || (SearchResponseMetadata$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/searchresponse.js
  var SearchResponse$inboundSchema = objectType({
    trackingToken: stringType().optional(),
    sessionInfo: SessionInfo$inboundSchema.optional(),
    results: arrayType(SearchResult$inboundSchema).optional(),
    structuredResults: arrayType(StructuredResult$inboundSchema).optional(),
    generatedQnaResult: GeneratedQna$inboundSchema.optional(),
    errorInfo: GleanDataError$inboundSchema.optional(),
    requestID: stringType().optional(),
    backendTimeMillis: numberType().int().optional(),
    experimentIds: arrayType(numberType().int()).optional(),
    metadata: SearchResponseMetadata$inboundSchema.optional(),
    facetResults: arrayType(FacetResult$inboundSchema).optional(),
    resultTabs: arrayType(ResultTab$inboundSchema).optional(),
    resultTabIds: arrayType(stringType()).optional(),
    resultsDescription: ResultsDescription$inboundSchema.optional(),
    rewrittenFacetFilters: arrayType(FacetFilter$inboundSchema).optional(),
    cursor: stringType().optional(),
    hasMoreResults: booleanType().optional()
  }).transform((v) => {
    return remap(v, {
      "errorInfo": "gleanDataError"
    });
  });
  var SearchResponse$outboundSchema = objectType({
    trackingToken: stringType().optional(),
    sessionInfo: SessionInfo$outboundSchema.optional(),
    results: arrayType(SearchResult$outboundSchema).optional(),
    structuredResults: arrayType(StructuredResult$outboundSchema).optional(),
    generatedQnaResult: GeneratedQna$outboundSchema.optional(),
    gleanDataError: GleanDataError$outboundSchema.optional(),
    requestID: stringType().optional(),
    backendTimeMillis: numberType().int().optional(),
    experimentIds: arrayType(numberType().int()).optional(),
    metadata: SearchResponseMetadata$outboundSchema.optional(),
    facetResults: arrayType(FacetResult$outboundSchema).optional(),
    resultTabs: arrayType(ResultTab$outboundSchema).optional(),
    resultTabIds: arrayType(stringType()).optional(),
    resultsDescription: ResultsDescription$outboundSchema.optional(),
    rewrittenFacetFilters: arrayType(FacetFilter$outboundSchema).optional(),
    cursor: stringType().optional(),
    hasMoreResults: booleanType().optional()
  }).transform((v) => {
    return remap(v, {
      gleanDataError: "errorInfo"
    });
  });
  var SearchResponse$;
  (function(SearchResponse$2) {
    SearchResponse$2.inboundSchema = SearchResponse$inboundSchema;
    SearchResponse$2.outboundSchema = SearchResponse$outboundSchema;
  })(SearchResponse$ || (SearchResponse$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/messagesresponse.js
  var MessagesResponse$inboundSchema = objectType({
    hasMore: booleanType(),
    searchResponse: SearchResponse$inboundSchema.optional(),
    rootMessage: SearchResult$inboundSchema.optional()
  });
  var MessagesResponse$outboundSchema = objectType({
    hasMore: booleanType(),
    searchResponse: SearchResponse$outboundSchema.optional(),
    rootMessage: SearchResult$outboundSchema.optional()
  });
  var MessagesResponse$;
  (function(MessagesResponse$2) {
    MessagesResponse$2.inboundSchema = MessagesResponse$inboundSchema;
    MessagesResponse$2.outboundSchema = MessagesResponse$outboundSchema;
  })(MessagesResponse$ || (MessagesResponse$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/peoplerequest.js
  var PeopleRequestIncludeField = {
    Badges: "BADGES",
    BusyEvents: "BUSY_EVENTS",
    DocumentActivity: "DOCUMENT_ACTIVITY",
    InviteInfo: "INVITE_INFO",
    PeopleDistance: "PEOPLE_DISTANCE",
    Permissions: "PERMISSIONS",
    PeopleDetails: "PEOPLE_DETAILS",
    ManagementDetails: "MANAGEMENT_DETAILS",
    PeopleProfileSettings: "PEOPLE_PROFILE_SETTINGS",
    PeopleWithoutManager: "PEOPLE_WITHOUT_MANAGER"
  };
  var IncludeType = {
    PeopleWithoutManager: "PEOPLE_WITHOUT_MANAGER",
    InvalidEntities: "INVALID_ENTITIES"
  };
  var PeopleRequestIncludeField$inboundSchema = nativeEnumType(PeopleRequestIncludeField);
  var PeopleRequestIncludeField$outboundSchema = PeopleRequestIncludeField$inboundSchema;
  var PeopleRequestIncludeField$;
  (function(PeopleRequestIncludeField$2) {
    PeopleRequestIncludeField$2.inboundSchema = PeopleRequestIncludeField$inboundSchema;
    PeopleRequestIncludeField$2.outboundSchema = PeopleRequestIncludeField$outboundSchema;
  })(PeopleRequestIncludeField$ || (PeopleRequestIncludeField$ = {}));
  var IncludeType$inboundSchema = nativeEnumType(IncludeType);
  var IncludeType$outboundSchema = IncludeType$inboundSchema;
  var IncludeType$;
  (function(IncludeType$2) {
    IncludeType$2.inboundSchema = IncludeType$inboundSchema;
    IncludeType$2.outboundSchema = IncludeType$outboundSchema;
  })(IncludeType$ || (IncludeType$ = {}));
  var PeopleRequest$inboundSchema = objectType({
    timezoneOffset: numberType().int().optional(),
    obfuscatedIds: arrayType(stringType()).optional(),
    emailIds: arrayType(stringType()).optional(),
    includeFields: arrayType(PeopleRequestIncludeField$inboundSchema).optional(),
    includeTypes: arrayType(IncludeType$inboundSchema).optional(),
    source: stringType().optional()
  });
  var PeopleRequest$outboundSchema = objectType({
    timezoneOffset: numberType().int().optional(),
    obfuscatedIds: arrayType(stringType()).optional(),
    emailIds: arrayType(stringType()).optional(),
    includeFields: arrayType(PeopleRequestIncludeField$outboundSchema).optional(),
    includeTypes: arrayType(IncludeType$outboundSchema).optional(),
    source: stringType().optional()
  });
  var PeopleRequest$;
  (function(PeopleRequest$2) {
    PeopleRequest$2.inboundSchema = PeopleRequest$inboundSchema;
    PeopleRequest$2.outboundSchema = PeopleRequest$outboundSchema;
  })(PeopleRequest$ || (PeopleRequest$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/peopleresponse.js
  var PeopleResponse$inboundSchema = objectType({
    results: arrayType(Person$inboundSchema).optional(),
    relatedDocuments: arrayType(RelatedDocuments$inboundSchema).optional(),
    errors: arrayType(stringType()).optional()
  });
  var PeopleResponse$outboundSchema = objectType({
    results: arrayType(Person$outboundSchema).optional(),
    relatedDocuments: arrayType(RelatedDocuments$outboundSchema).optional(),
    errors: arrayType(stringType()).optional()
  });
  var PeopleResponse$;
  (function(PeopleResponse$2) {
    PeopleResponse$2.inboundSchema = PeopleResponse$inboundSchema;
    PeopleResponse$2.outboundSchema = PeopleResponse$outboundSchema;
  })(PeopleResponse$ || (PeopleResponse$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/pinrequest.js
  var PinRequest$inboundSchema = objectType({
    queries: arrayType(stringType()).optional(),
    audienceFilters: arrayType(FacetFilter$inboundSchema).optional(),
    documentId: stringType().optional()
  });
  var PinRequest$outboundSchema = objectType({
    queries: arrayType(stringType()).optional(),
    audienceFilters: arrayType(FacetFilter$outboundSchema).optional(),
    documentId: stringType().optional()
  });
  var PinRequest$;
  (function(PinRequest$2) {
    PinRequest$2.inboundSchema = PinRequest$inboundSchema;
    PinRequest$2.outboundSchema = PinRequest$outboundSchema;
  })(PinRequest$ || (PinRequest$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/processalldocumentsrequest.js
  var ProcessAllDocumentsRequest$inboundSchema = objectType({
    datasource: stringType().optional()
  });
  var ProcessAllDocumentsRequest$outboundSchema = objectType({
    datasource: stringType().optional()
  });
  var ProcessAllDocumentsRequest$;
  (function(ProcessAllDocumentsRequest$2) {
    ProcessAllDocumentsRequest$2.inboundSchema = ProcessAllDocumentsRequest$inboundSchema;
    ProcessAllDocumentsRequest$2.outboundSchema = ProcessAllDocumentsRequest$outboundSchema;
  })(ProcessAllDocumentsRequest$ || (ProcessAllDocumentsRequest$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/processallmembershipsrequest.js
  var ProcessAllMembershipsRequest$inboundSchema = objectType({
    datasource: stringType().optional()
  });
  var ProcessAllMembershipsRequest$outboundSchema = objectType({
    datasource: stringType().optional()
  });
  var ProcessAllMembershipsRequest$;
  (function(ProcessAllMembershipsRequest$2) {
    ProcessAllMembershipsRequest$2.inboundSchema = ProcessAllMembershipsRequest$inboundSchema;
    ProcessAllMembershipsRequest$2.outboundSchema = ProcessAllMembershipsRequest$outboundSchema;
  })(ProcessAllMembershipsRequest$ || (ProcessAllMembershipsRequest$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/recommendationsrequestoptions.js
  var RecommendationsRequestOptions$inboundSchema = objectType({
    datasourceFilter: stringType().optional(),
    datasourcesFilter: arrayType(stringType()).optional(),
    facetFilterSets: arrayType(FacetFilterSet$inboundSchema).optional(),
    context: Document$inboundSchema.optional(),
    resultProminence: arrayType(SearchResultProminenceEnum$inboundSchema).optional()
  });
  var RecommendationsRequestOptions$outboundSchema = objectType({
    datasourceFilter: stringType().optional(),
    datasourcesFilter: arrayType(stringType()).optional(),
    facetFilterSets: arrayType(FacetFilterSet$outboundSchema).optional(),
    context: Document$outboundSchema.optional(),
    resultProminence: arrayType(SearchResultProminenceEnum$outboundSchema).optional()
  });
  var RecommendationsRequestOptions$;
  (function(RecommendationsRequestOptions$2) {
    RecommendationsRequestOptions$2.inboundSchema = RecommendationsRequestOptions$inboundSchema;
    RecommendationsRequestOptions$2.outboundSchema = RecommendationsRequestOptions$outboundSchema;
  })(RecommendationsRequestOptions$ || (RecommendationsRequestOptions$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/recommendationsrequest.js
  var RecommendationsRequest$inboundSchema = objectType({
    timestamp: stringType().datetime({ offset: true }).transform((v) => new Date(v)).optional(),
    trackingToken: stringType().optional(),
    sessionInfo: SessionInfo$inboundSchema.optional(),
    sourceDocument: Document$inboundSchema.optional(),
    pageSize: numberType().int().optional(),
    maxSnippetSize: numberType().int().optional(),
    recommendationDocumentSpec: DocumentSpecUnion$inboundSchema.optional(),
    requestOptions: RecommendationsRequestOptions$inboundSchema.optional()
  });
  var RecommendationsRequest$outboundSchema = objectType({
    timestamp: dateType().transform((v) => v.toISOString()).optional(),
    trackingToken: stringType().optional(),
    sessionInfo: SessionInfo$outboundSchema.optional(),
    sourceDocument: Document$outboundSchema.optional(),
    pageSize: numberType().int().optional(),
    maxSnippetSize: numberType().int().optional(),
    recommendationDocumentSpec: DocumentSpecUnion$outboundSchema.optional(),
    requestOptions: RecommendationsRequestOptions$outboundSchema.optional()
  });
  var RecommendationsRequest$;
  (function(RecommendationsRequest$2) {
    RecommendationsRequest$2.inboundSchema = RecommendationsRequest$inboundSchema;
    RecommendationsRequest$2.outboundSchema = RecommendationsRequest$outboundSchema;
  })(RecommendationsRequest$ || (RecommendationsRequest$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/reminderrequest.js
  var ReminderRequest$inboundSchema = objectType({
    documentId: stringType(),
    assignee: stringType().optional(),
    remindInDays: numberType().int().optional(),
    reason: stringType().optional()
  });
  var ReminderRequest$outboundSchema = objectType({
    documentId: stringType(),
    assignee: stringType().optional(),
    remindInDays: numberType().int().optional(),
    reason: stringType().optional()
  });
  var ReminderRequest$;
  (function(ReminderRequest$2) {
    ReminderRequest$2.inboundSchema = ReminderRequest$inboundSchema;
    ReminderRequest$2.outboundSchema = ReminderRequest$outboundSchema;
  })(ReminderRequest$ || (ReminderRequest$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/reportstatusresponse.js
  var ReportStatusResponseStatus = {
    Pending: "PENDING",
    Success: "SUCCESS",
    Failure: "FAILURE",
    Cancelled: "CANCELLED",
    Cancelling: "CANCELLING",
    Active: "ACTIVE"
  };
  var ReportStatusResponseStatus$inboundSchema = nativeEnumType(ReportStatusResponseStatus);
  var ReportStatusResponseStatus$outboundSchema = ReportStatusResponseStatus$inboundSchema;
  var ReportStatusResponseStatus$;
  (function(ReportStatusResponseStatus$2) {
    ReportStatusResponseStatus$2.inboundSchema = ReportStatusResponseStatus$inboundSchema;
    ReportStatusResponseStatus$2.outboundSchema = ReportStatusResponseStatus$outboundSchema;
  })(ReportStatusResponseStatus$ || (ReportStatusResponseStatus$ = {}));
  var ReportStatusResponse$inboundSchema = objectType({
    status: ReportStatusResponseStatus$inboundSchema.optional(),
    startTime: stringType().optional()
  });
  var ReportStatusResponse$outboundSchema = objectType({
    status: ReportStatusResponseStatus$outboundSchema.optional(),
    startTime: stringType().optional()
  });
  var ReportStatusResponse$;
  (function(ReportStatusResponse$2) {
    ReportStatusResponse$2.inboundSchema = ReportStatusResponse$inboundSchema;
    ReportStatusResponse$2.outboundSchema = ReportStatusResponse$outboundSchema;
  })(ReportStatusResponse$ || (ReportStatusResponse$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/resultsresponse.js
  var ResultsResponse$inboundSchema = objectType({
    trackingToken: stringType().optional(),
    sessionInfo: SessionInfo$inboundSchema.optional(),
    results: arrayType(SearchResult$inboundSchema).optional(),
    structuredResults: arrayType(StructuredResult$inboundSchema).optional(),
    generatedQnaResult: GeneratedQna$inboundSchema.optional(),
    errorInfo: GleanDataError$inboundSchema.optional(),
    requestID: stringType().optional(),
    backendTimeMillis: numberType().int().optional()
  }).transform((v) => {
    return remap(v, {
      "errorInfo": "gleanDataError"
    });
  });
  var ResultsResponse$outboundSchema = objectType({
    trackingToken: stringType().optional(),
    sessionInfo: SessionInfo$outboundSchema.optional(),
    results: arrayType(SearchResult$outboundSchema).optional(),
    structuredResults: arrayType(StructuredResult$outboundSchema).optional(),
    generatedQnaResult: GeneratedQna$outboundSchema.optional(),
    gleanDataError: GleanDataError$outboundSchema.optional(),
    requestID: stringType().optional(),
    backendTimeMillis: numberType().int().optional()
  }).transform((v) => {
    return remap(v, {
      gleanDataError: "errorInfo"
    });
  });
  var ResultsResponse$;
  (function(ResultsResponse$2) {
    ResultsResponse$2.inboundSchema = ResultsResponse$inboundSchema;
    ResultsResponse$2.outboundSchema = ResultsResponse$outboundSchema;
  })(ResultsResponse$ || (ResultsResponse$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/rotatetokenresponse.js
  var RotateTokenResponse$inboundSchema = objectType({
    rawSecret: stringType().optional(),
    createdAt: numberType().int().optional(),
    rotationPeriodMinutes: numberType().int().optional()
  });
  var RotateTokenResponse$outboundSchema = objectType({
    rawSecret: stringType().optional(),
    createdAt: numberType().int().optional(),
    rotationPeriodMinutes: numberType().int().optional()
  });
  var RotateTokenResponse$;
  (function(RotateTokenResponse$2) {
    RotateTokenResponse$2.inboundSchema = RotateTokenResponse$inboundSchema;
    RotateTokenResponse$2.outboundSchema = RotateTokenResponse$outboundSchema;
  })(RotateTokenResponse$ || (RotateTokenResponse$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/searchagentsrequest.js
  var SearchAgentsRequest$inboundSchema = objectType({
    name: stringType().optional()
  });
  var SearchAgentsRequest$outboundSchema = objectType({
    name: stringType().optional()
  });
  var SearchAgentsRequest$;
  (function(SearchAgentsRequest$2) {
    SearchAgentsRequest$2.inboundSchema = SearchAgentsRequest$inboundSchema;
    SearchAgentsRequest$2.outboundSchema = SearchAgentsRequest$outboundSchema;
  })(SearchAgentsRequest$ || (SearchAgentsRequest$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/searchagentsresponse.js
  var SearchAgentsResponse$inboundSchema = objectType({
    agents: arrayType(Agent$inboundSchema).optional()
  });
  var SearchAgentsResponse$outboundSchema = objectType({
    agents: arrayType(Agent$outboundSchema).optional()
  });
  var SearchAgentsResponse$;
  (function(SearchAgentsResponse$2) {
    SearchAgentsResponse$2.inboundSchema = SearchAgentsResponse$inboundSchema;
    SearchAgentsResponse$2.outboundSchema = SearchAgentsResponse$outboundSchema;
  })(SearchAgentsResponse$ || (SearchAgentsResponse$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/searchrequest.js
  var SearchRequest$inboundSchema = objectType({
    timestamp: stringType().datetime({ offset: true }).transform((v) => new Date(v)).optional(),
    trackingToken: stringType().optional(),
    sessionInfo: SessionInfo$inboundSchema.optional(),
    sourceDocument: Document$inboundSchema.optional(),
    pageSize: numberType().int().optional(),
    maxSnippetSize: numberType().int().optional(),
    query: stringType(),
    cursor: stringType().optional(),
    resultTabIds: arrayType(stringType()).optional(),
    inputDetails: SearchRequestInputDetails$inboundSchema.optional(),
    requestOptions: SearchRequestOptions$inboundSchema.optional(),
    timeoutMillis: numberType().int().optional(),
    disableSpellcheck: booleanType().optional()
  });
  var SearchRequest$outboundSchema = objectType({
    timestamp: dateType().transform((v) => v.toISOString()).optional(),
    trackingToken: stringType().optional(),
    sessionInfo: SessionInfo$outboundSchema.optional(),
    sourceDocument: Document$outboundSchema.optional(),
    pageSize: numberType().int().optional(),
    maxSnippetSize: numberType().int().optional(),
    query: stringType(),
    cursor: stringType().optional(),
    resultTabIds: arrayType(stringType()).optional(),
    inputDetails: SearchRequestInputDetails$outboundSchema.optional(),
    requestOptions: SearchRequestOptions$outboundSchema.optional(),
    timeoutMillis: numberType().int().optional(),
    disableSpellcheck: booleanType().optional()
  });
  var SearchRequest$;
  (function(SearchRequest$2) {
    SearchRequest$2.inboundSchema = SearchRequest$inboundSchema;
    SearchRequest$2.outboundSchema = SearchRequest$outboundSchema;
  })(SearchRequest$ || (SearchRequest$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/security.js
  var Security$inboundSchema = objectType({
    APIToken: stringType().optional()
  }).transform((v) => {
    return remap(v, {
      "APIToken": "apiToken"
    });
  });
  var Security$outboundSchema = objectType({
    apiToken: stringType().optional()
  }).transform((v) => {
    return remap(v, {
      apiToken: "APIToken"
    });
  });
  var Security$;
  (function(Security$2) {
    Security$2.inboundSchema = Security$inboundSchema;
    Security$2.outboundSchema = Security$outboundSchema;
  })(Security$ || (Security$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/summarizerequest.js
  var SummarizeRequest$inboundSchema = objectType({
    timestamp: stringType().datetime({ offset: true }).transform((v) => new Date(v)).optional(),
    query: stringType().optional(),
    preferredSummaryLength: numberType().int().optional(),
    documentSpecs: arrayType(DocumentSpecUnion$inboundSchema),
    trackingToken: stringType().optional()
  });
  var SummarizeRequest$outboundSchema = objectType({
    timestamp: dateType().transform((v) => v.toISOString()).optional(),
    query: stringType().optional(),
    preferredSummaryLength: numberType().int().optional(),
    documentSpecs: arrayType(DocumentSpecUnion$outboundSchema),
    trackingToken: stringType().optional()
  });
  var SummarizeRequest$;
  (function(SummarizeRequest$2) {
    SummarizeRequest$2.inboundSchema = SummarizeRequest$inboundSchema;
    SummarizeRequest$2.outboundSchema = SummarizeRequest$outboundSchema;
  })(SummarizeRequest$ || (SummarizeRequest$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/summary.js
  var Summary$inboundSchema = objectType({
    text: stringType().optional(),
    followUpPrompts: arrayType(stringType()).optional()
  });
  var Summary$outboundSchema = objectType({
    text: stringType().optional(),
    followUpPrompts: arrayType(stringType()).optional()
  });
  var Summary$;
  (function(Summary$2) {
    Summary$2.inboundSchema = Summary$inboundSchema;
    Summary$2.outboundSchema = Summary$outboundSchema;
  })(Summary$ || (Summary$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/summarizeresponse.js
  var ErrorT$inboundSchema = objectType({
    message: stringType().optional()
  });
  var ErrorT$outboundSchema = objectType({
    message: stringType().optional()
  });
  var ErrorT$;
  (function(ErrorT$2) {
    ErrorT$2.inboundSchema = ErrorT$inboundSchema;
    ErrorT$2.outboundSchema = ErrorT$outboundSchema;
  })(ErrorT$ || (ErrorT$ = {}));
  var SummarizeResponse$inboundSchema = objectType({
    error: lazyType(() => ErrorT$inboundSchema).optional(),
    summary: Summary$inboundSchema.optional(),
    trackingToken: stringType().optional()
  });
  var SummarizeResponse$outboundSchema = objectType({
    error: lazyType(() => ErrorT$outboundSchema).optional(),
    summary: Summary$outboundSchema.optional(),
    trackingToken: stringType().optional()
  });
  var SummarizeResponse$;
  (function(SummarizeResponse$2) {
    SummarizeResponse$2.inboundSchema = SummarizeResponse$inboundSchema;
    SummarizeResponse$2.outboundSchema = SummarizeResponse$outboundSchema;
  })(SummarizeResponse$ || (SummarizeResponse$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/toolparameter.js
  var ToolParameterType = {
    String: "string",
    Number: "number",
    Boolean: "boolean",
    Object: "object",
    Array: "array"
  };
  var ToolParameterType$inboundSchema = nativeEnumType(ToolParameterType);
  var ToolParameterType$outboundSchema = ToolParameterType$inboundSchema;
  var ToolParameterType$;
  (function(ToolParameterType$2) {
    ToolParameterType$2.inboundSchema = ToolParameterType$inboundSchema;
    ToolParameterType$2.outboundSchema = ToolParameterType$outboundSchema;
  })(ToolParameterType$ || (ToolParameterType$ = {}));
  var ToolParameter$inboundSchema = objectType({
    type: ToolParameterType$inboundSchema.optional(),
    name: stringType().optional(),
    description: stringType().optional(),
    isRequired: booleanType().optional(),
    possibleValues: arrayType(stringType()).optional(),
    items: lazyType(() => ToolParameter$inboundSchema).optional(),
    properties: recordType(lazyType(() => ToolParameter$inboundSchema)).optional()
  });
  var ToolParameter$outboundSchema = objectType({
    type: ToolParameterType$outboundSchema.optional(),
    name: stringType().optional(),
    description: stringType().optional(),
    isRequired: booleanType().optional(),
    possibleValues: arrayType(stringType()).optional(),
    items: lazyType(() => ToolParameter$outboundSchema).optional(),
    properties: recordType(lazyType(() => ToolParameter$outboundSchema)).optional()
  });
  var ToolParameter$;
  (function(ToolParameter$2) {
    ToolParameter$2.inboundSchema = ToolParameter$inboundSchema;
    ToolParameter$2.outboundSchema = ToolParameter$outboundSchema;
  })(ToolParameter$ || (ToolParameter$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/tool.js
  var ToolType = {
    Read: "READ",
    Write: "WRITE"
  };
  var ToolType$inboundSchema = nativeEnumType(ToolType);
  var ToolType$outboundSchema = ToolType$inboundSchema;
  var ToolType$;
  (function(ToolType$2) {
    ToolType$2.inboundSchema = ToolType$inboundSchema;
    ToolType$2.outboundSchema = ToolType$outboundSchema;
  })(ToolType$ || (ToolType$ = {}));
  var Tool$inboundSchema = objectType({
    type: ToolType$inboundSchema.optional(),
    name: stringType().optional(),
    displayName: stringType().optional(),
    description: stringType().optional(),
    parameters: recordType(ToolParameter$inboundSchema).optional()
  });
  var Tool$outboundSchema = objectType({
    type: ToolType$outboundSchema.optional(),
    name: stringType().optional(),
    displayName: stringType().optional(),
    description: stringType().optional(),
    parameters: recordType(ToolParameter$outboundSchema).optional()
  });
  var Tool$;
  (function(Tool$2) {
    Tool$2.inboundSchema = Tool$inboundSchema;
    Tool$2.outboundSchema = Tool$outboundSchema;
  })(Tool$ || (Tool$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/toolscallparameter.js
  var ToolsCallParameter$inboundSchema = objectType({
    name: stringType(),
    value: stringType(),
    items: arrayType(lazyType(() => ToolsCallParameter$inboundSchema)).optional(),
    properties: recordType(lazyType(() => ToolsCallParameter$inboundSchema)).optional()
  });
  var ToolsCallParameter$outboundSchema = objectType({
    name: stringType(),
    value: stringType(),
    items: arrayType(lazyType(() => ToolsCallParameter$outboundSchema)).optional(),
    properties: recordType(lazyType(() => ToolsCallParameter$outboundSchema)).optional()
  });
  var ToolsCallParameter$;
  (function(ToolsCallParameter$2) {
    ToolsCallParameter$2.inboundSchema = ToolsCallParameter$inboundSchema;
    ToolsCallParameter$2.outboundSchema = ToolsCallParameter$outboundSchema;
  })(ToolsCallParameter$ || (ToolsCallParameter$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/toolscallrequest.js
  var ToolsCallRequest$inboundSchema = objectType({
    name: stringType(),
    parameters: recordType(ToolsCallParameter$inboundSchema)
  });
  var ToolsCallRequest$outboundSchema = objectType({
    name: stringType(),
    parameters: recordType(ToolsCallParameter$outboundSchema)
  });
  var ToolsCallRequest$;
  (function(ToolsCallRequest$2) {
    ToolsCallRequest$2.inboundSchema = ToolsCallRequest$inboundSchema;
    ToolsCallRequest$2.outboundSchema = ToolsCallRequest$outboundSchema;
  })(ToolsCallRequest$ || (ToolsCallRequest$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/toolscallresponse.js
  var ToolsCallResponse$inboundSchema = objectType({
    rawResponse: recordType(anyType()).optional(),
    error: stringType().optional()
  });
  var ToolsCallResponse$outboundSchema = objectType({
    rawResponse: recordType(anyType()).optional(),
    error: stringType().optional()
  });
  var ToolsCallResponse$;
  (function(ToolsCallResponse$2) {
    ToolsCallResponse$2.inboundSchema = ToolsCallResponse$inboundSchema;
    ToolsCallResponse$2.outboundSchema = ToolsCallResponse$outboundSchema;
  })(ToolsCallResponse$ || (ToolsCallResponse$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/toolslistresponse.js
  var ToolsListResponse$inboundSchema = objectType({
    tools: arrayType(Tool$inboundSchema).optional()
  });
  var ToolsListResponse$outboundSchema = objectType({
    tools: arrayType(Tool$outboundSchema).optional()
  });
  var ToolsListResponse$;
  (function(ToolsListResponse$2) {
    ToolsListResponse$2.inboundSchema = ToolsListResponse$inboundSchema;
    ToolsListResponse$2.outboundSchema = ToolsListResponse$outboundSchema;
  })(ToolsListResponse$ || (ToolsListResponse$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/unpin.js
  var Unpin$inboundSchema = objectType({
    id: stringType().optional()
  });
  var Unpin$outboundSchema = objectType({
    id: stringType().optional()
  });
  var Unpin$;
  (function(Unpin$2) {
    Unpin$2.inboundSchema = Unpin$inboundSchema;
    Unpin$2.outboundSchema = Unpin$outboundSchema;
  })(Unpin$ || (Unpin$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/updateannouncementrequest.js
  var UpdateAnnouncementRequestChannel = {
    Main: "MAIN",
    SocialFeed: "SOCIAL_FEED"
  };
  var UpdateAnnouncementRequestPostType = {
    Text: "TEXT",
    Link: "LINK"
  };
  var UpdateAnnouncementRequestChannel$inboundSchema = nativeEnumType(UpdateAnnouncementRequestChannel);
  var UpdateAnnouncementRequestChannel$outboundSchema = UpdateAnnouncementRequestChannel$inboundSchema;
  var UpdateAnnouncementRequestChannel$;
  (function(UpdateAnnouncementRequestChannel$2) {
    UpdateAnnouncementRequestChannel$2.inboundSchema = UpdateAnnouncementRequestChannel$inboundSchema;
    UpdateAnnouncementRequestChannel$2.outboundSchema = UpdateAnnouncementRequestChannel$outboundSchema;
  })(UpdateAnnouncementRequestChannel$ || (UpdateAnnouncementRequestChannel$ = {}));
  var UpdateAnnouncementRequestPostType$inboundSchema = nativeEnumType(UpdateAnnouncementRequestPostType);
  var UpdateAnnouncementRequestPostType$outboundSchema = UpdateAnnouncementRequestPostType$inboundSchema;
  var UpdateAnnouncementRequestPostType$;
  (function(UpdateAnnouncementRequestPostType$2) {
    UpdateAnnouncementRequestPostType$2.inboundSchema = UpdateAnnouncementRequestPostType$inboundSchema;
    UpdateAnnouncementRequestPostType$2.outboundSchema = UpdateAnnouncementRequestPostType$outboundSchema;
  })(UpdateAnnouncementRequestPostType$ || (UpdateAnnouncementRequestPostType$ = {}));
  var UpdateAnnouncementRequest$inboundSchema = objectType({
    startTime: stringType().datetime({ offset: true }).transform((v) => new Date(v)),
    endTime: stringType().datetime({ offset: true }).transform((v) => new Date(v)),
    title: stringType(),
    body: StructuredText$inboundSchema.optional(),
    emoji: stringType().optional(),
    thumbnail: Thumbnail$inboundSchema.optional(),
    banner: Thumbnail$inboundSchema.optional(),
    audienceFilters: arrayType(FacetFilter$inboundSchema).optional(),
    sourceDocumentId: stringType().optional(),
    hideAttribution: booleanType().optional(),
    channel: UpdateAnnouncementRequestChannel$inboundSchema.optional(),
    postType: UpdateAnnouncementRequestPostType$inboundSchema.optional(),
    isPrioritized: booleanType().optional(),
    viewUrl: stringType().optional(),
    id: numberType().int()
  });
  var UpdateAnnouncementRequest$outboundSchema = objectType({
    startTime: dateType().transform((v) => v.toISOString()),
    endTime: dateType().transform((v) => v.toISOString()),
    title: stringType(),
    body: StructuredText$outboundSchema.optional(),
    emoji: stringType().optional(),
    thumbnail: Thumbnail$outboundSchema.optional(),
    banner: Thumbnail$outboundSchema.optional(),
    audienceFilters: arrayType(FacetFilter$outboundSchema).optional(),
    sourceDocumentId: stringType().optional(),
    hideAttribution: booleanType().optional(),
    channel: UpdateAnnouncementRequestChannel$outboundSchema.optional(),
    postType: UpdateAnnouncementRequestPostType$outboundSchema.optional(),
    isPrioritized: booleanType().optional(),
    viewUrl: stringType().optional(),
    id: numberType().int()
  });
  var UpdateAnnouncementRequest$;
  (function(UpdateAnnouncementRequest$2) {
    UpdateAnnouncementRequest$2.inboundSchema = UpdateAnnouncementRequest$inboundSchema;
    UpdateAnnouncementRequest$2.outboundSchema = UpdateAnnouncementRequest$outboundSchema;
  })(UpdateAnnouncementRequest$ || (UpdateAnnouncementRequest$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/updatedlpconfigrequest.js
  var UpdateDlpConfigRequest$inboundSchema = objectType({
    config: DlpConfig$inboundSchema.optional(),
    frequency: stringType().optional()
  });
  var UpdateDlpConfigRequest$outboundSchema = objectType({
    config: DlpConfig$outboundSchema.optional(),
    frequency: stringType().optional()
  });
  var UpdateDlpConfigRequest$;
  (function(UpdateDlpConfigRequest$2) {
    UpdateDlpConfigRequest$2.inboundSchema = UpdateDlpConfigRequest$inboundSchema;
    UpdateDlpConfigRequest$2.outboundSchema = UpdateDlpConfigRequest$outboundSchema;
  })(UpdateDlpConfigRequest$ || (UpdateDlpConfigRequest$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/updatedlpconfigresponse.js
  var UpdateDlpConfigResponse$inboundSchema = objectType({
    result: DlpSimpleResult$inboundSchema.optional(),
    reportId: stringType().optional()
  });
  var UpdateDlpConfigResponse$outboundSchema = objectType({
    result: DlpSimpleResult$outboundSchema.optional(),
    reportId: stringType().optional()
  });
  var UpdateDlpConfigResponse$;
  (function(UpdateDlpConfigResponse$2) {
    UpdateDlpConfigResponse$2.inboundSchema = UpdateDlpConfigResponse$inboundSchema;
    UpdateDlpConfigResponse$2.outboundSchema = UpdateDlpConfigResponse$outboundSchema;
  })(UpdateDlpConfigResponse$ || (UpdateDlpConfigResponse$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/updatedlpreportrequest.js
  var UpdateDlpReportRequest$inboundSchema = objectType({
    config: DlpConfig$inboundSchema.optional(),
    frequency: DlpFrequency$inboundSchema.optional(),
    status: DlpReportStatus$inboundSchema.optional(),
    autoHideDocs: booleanType().optional(),
    reportName: stringType().optional()
  });
  var UpdateDlpReportRequest$outboundSchema = objectType({
    config: DlpConfig$outboundSchema.optional(),
    frequency: DlpFrequency$outboundSchema.optional(),
    status: DlpReportStatus$outboundSchema.optional(),
    autoHideDocs: booleanType().optional(),
    reportName: stringType().optional()
  });
  var UpdateDlpReportRequest$;
  (function(UpdateDlpReportRequest$2) {
    UpdateDlpReportRequest$2.inboundSchema = UpdateDlpReportRequest$inboundSchema;
    UpdateDlpReportRequest$2.outboundSchema = UpdateDlpReportRequest$outboundSchema;
  })(UpdateDlpReportRequest$ || (UpdateDlpReportRequest$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/updatedlpreportresponse.js
  var UpdateDlpReportResponse$inboundSchema = objectType({
    result: DlpSimpleResult$inboundSchema.optional()
  });
  var UpdateDlpReportResponse$outboundSchema = objectType({
    result: DlpSimpleResult$outboundSchema.optional()
  });
  var UpdateDlpReportResponse$;
  (function(UpdateDlpReportResponse$2) {
    UpdateDlpReportResponse$2.inboundSchema = UpdateDlpReportResponse$inboundSchema;
    UpdateDlpReportResponse$2.outboundSchema = UpdateDlpReportResponse$outboundSchema;
  })(UpdateDlpReportResponse$ || (UpdateDlpReportResponse$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/updatedocumentvisibilityoverridesrequest.js
  var UpdateDocumentVisibilityOverridesRequest$inboundSchema = objectType({
    visibilityOverrides: arrayType(DocumentVisibilityOverride$inboundSchema).optional()
  });
  var UpdateDocumentVisibilityOverridesRequest$outboundSchema = objectType({
    visibilityOverrides: arrayType(DocumentVisibilityOverride$outboundSchema).optional()
  });
  var UpdateDocumentVisibilityOverridesRequest$;
  (function(UpdateDocumentVisibilityOverridesRequest$2) {
    UpdateDocumentVisibilityOverridesRequest$2.inboundSchema = UpdateDocumentVisibilityOverridesRequest$inboundSchema;
    UpdateDocumentVisibilityOverridesRequest$2.outboundSchema = UpdateDocumentVisibilityOverridesRequest$outboundSchema;
  })(UpdateDocumentVisibilityOverridesRequest$ || (UpdateDocumentVisibilityOverridesRequest$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/updatedocumentvisibilityoverridesresponse.js
  var UpdateDocumentVisibilityOverridesResponse$inboundSchema = objectType({
    results: arrayType(DocumentVisibilityUpdateResult$inboundSchema).optional()
  });
  var UpdateDocumentVisibilityOverridesResponse$outboundSchema = objectType({
    results: arrayType(DocumentVisibilityUpdateResult$outboundSchema).optional()
  });
  var UpdateDocumentVisibilityOverridesResponse$;
  (function(UpdateDocumentVisibilityOverridesResponse$2) {
    UpdateDocumentVisibilityOverridesResponse$2.inboundSchema = UpdateDocumentVisibilityOverridesResponse$inboundSchema;
    UpdateDocumentVisibilityOverridesResponse$2.outboundSchema = UpdateDocumentVisibilityOverridesResponse$outboundSchema;
  })(UpdateDocumentVisibilityOverridesResponse$ || (UpdateDocumentVisibilityOverridesResponse$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/updatepermissionsrequest.js
  var UpdatePermissionsRequest$inboundSchema = objectType({
    datasource: stringType(),
    objectType: stringType().optional(),
    id: stringType().optional(),
    viewURL: stringType().optional(),
    permissions: DocumentPermissionsDefinition$inboundSchema
  });
  var UpdatePermissionsRequest$outboundSchema = objectType({
    datasource: stringType(),
    objectType: stringType().optional(),
    id: stringType().optional(),
    viewURL: stringType().optional(),
    permissions: DocumentPermissionsDefinition$outboundSchema
  });
  var UpdatePermissionsRequest$;
  (function(UpdatePermissionsRequest$2) {
    UpdatePermissionsRequest$2.inboundSchema = UpdatePermissionsRequest$inboundSchema;
    UpdatePermissionsRequest$2.outboundSchema = UpdatePermissionsRequest$outboundSchema;
  })(UpdatePermissionsRequest$ || (UpdatePermissionsRequest$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/updateshortcutrequest.js
  var UpdateShortcutRequest$inboundSchema = objectType({
    id: numberType().int(),
    inputAlias: stringType().optional(),
    destinationUrl: stringType().optional(),
    destinationDocumentId: stringType().optional(),
    description: stringType().optional(),
    unlisted: booleanType().optional(),
    urlTemplate: stringType().optional(),
    addedRoles: arrayType(UserRoleSpecification$inboundSchema).optional(),
    removedRoles: arrayType(UserRoleSpecification$inboundSchema).optional()
  });
  var UpdateShortcutRequest$outboundSchema = objectType({
    id: numberType().int(),
    inputAlias: stringType().optional(),
    destinationUrl: stringType().optional(),
    destinationDocumentId: stringType().optional(),
    description: stringType().optional(),
    unlisted: booleanType().optional(),
    urlTemplate: stringType().optional(),
    addedRoles: arrayType(UserRoleSpecification$outboundSchema).optional(),
    removedRoles: arrayType(UserRoleSpecification$outboundSchema).optional()
  });
  var UpdateShortcutRequest$;
  (function(UpdateShortcutRequest$2) {
    UpdateShortcutRequest$2.inboundSchema = UpdateShortcutRequest$inboundSchema;
    UpdateShortcutRequest$2.outboundSchema = UpdateShortcutRequest$outboundSchema;
  })(UpdateShortcutRequest$ || (UpdateShortcutRequest$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/updateshortcutresponse.js
  var UpdateShortcutResponse$inboundSchema = objectType({
    shortcut: Shortcut$inboundSchema.optional(),
    error: ShortcutError$inboundSchema.optional()
  });
  var UpdateShortcutResponse$outboundSchema = objectType({
    shortcut: Shortcut$outboundSchema.optional(),
    error: ShortcutError$outboundSchema.optional()
  });
  var UpdateShortcutResponse$;
  (function(UpdateShortcutResponse$2) {
    UpdateShortcutResponse$2.inboundSchema = UpdateShortcutResponse$inboundSchema;
    UpdateShortcutResponse$2.outboundSchema = UpdateShortcutResponse$outboundSchema;
  })(UpdateShortcutResponse$ || (UpdateShortcutResponse$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/uploadchatfilesrequest.js
  var FileT$inboundSchema = objectType({
    fileName: stringType(),
    content: unionType([
      instanceOfType(ReadableStream),
      instanceOfType(Blob),
      instanceOfType(ArrayBuffer),
      instanceOfType(Uint8Array)
    ])
  });
  var FileT$outboundSchema = objectType({
    fileName: stringType(),
    content: unionType([
      instanceOfType(ReadableStream),
      instanceOfType(Blob),
      instanceOfType(ArrayBuffer),
      instanceOfType(Uint8Array)
    ])
  });
  var FileT$;
  (function(FileT$2) {
    FileT$2.inboundSchema = FileT$inboundSchema;
    FileT$2.outboundSchema = FileT$outboundSchema;
  })(FileT$ || (FileT$ = {}));
  var UploadChatFilesRequest$inboundSchema = objectType({
    files: arrayType(lazyType(() => FileT$inboundSchema))
  });
  var UploadChatFilesRequest$outboundSchema = objectType({
    files: arrayType(lazyType(() => FileT$outboundSchema))
  });
  var UploadChatFilesRequest$;
  (function(UploadChatFilesRequest$2) {
    UploadChatFilesRequest$2.inboundSchema = UploadChatFilesRequest$inboundSchema;
    UploadChatFilesRequest$2.outboundSchema = UploadChatFilesRequest$outboundSchema;
  })(UploadChatFilesRequest$ || (UploadChatFilesRequest$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/uploadchatfilesresponse.js
  var UploadChatFilesResponse$inboundSchema = objectType({
    files: arrayType(ChatFile$inboundSchema).optional()
  });
  var UploadChatFilesResponse$outboundSchema = objectType({
    files: arrayType(ChatFile$outboundSchema).optional()
  });
  var UploadChatFilesResponse$;
  (function(UploadChatFilesResponse$2) {
    UploadChatFilesResponse$2.inboundSchema = UploadChatFilesResponse$inboundSchema;
    UploadChatFilesResponse$2.outboundSchema = UploadChatFilesResponse$outboundSchema;
  })(UploadChatFilesResponse$ || (UploadChatFilesResponse$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/uploadshortcutsrequest.js
  var UploadShortcutsRequest$inboundSchema = objectType({
    uploadId: stringType(),
    isFirstPage: booleanType().optional(),
    isLastPage: booleanType().optional(),
    forceRestartUpload: booleanType().optional(),
    shortcuts: arrayType(IndexingShortcut$inboundSchema)
  });
  var UploadShortcutsRequest$outboundSchema = objectType({
    uploadId: stringType(),
    isFirstPage: booleanType().optional(),
    isLastPage: booleanType().optional(),
    forceRestartUpload: booleanType().optional(),
    shortcuts: arrayType(IndexingShortcut$outboundSchema)
  });
  var UploadShortcutsRequest$;
  (function(UploadShortcutsRequest$2) {
    UploadShortcutsRequest$2.inboundSchema = UploadShortcutsRequest$inboundSchema;
    UploadShortcutsRequest$2.outboundSchema = UploadShortcutsRequest$outboundSchema;
  })(UploadShortcutsRequest$ || (UploadShortcutsRequest$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/verificationfeed.js
  var VerificationFeed$inboundSchema = objectType({
    documents: arrayType(Verification$inboundSchema).optional()
  });
  var VerificationFeed$outboundSchema = objectType({
    documents: arrayType(Verification$outboundSchema).optional()
  });
  var VerificationFeed$;
  (function(VerificationFeed$2) {
    VerificationFeed$2.inboundSchema = VerificationFeed$inboundSchema;
    VerificationFeed$2.outboundSchema = VerificationFeed$outboundSchema;
  })(VerificationFeed$ || (VerificationFeed$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/components/verifyrequest.js
  var VerifyRequestAction = {
    Verify: "VERIFY",
    Deprecate: "DEPRECATE",
    Unverify: "UNVERIFY"
  };
  var VerifyRequestAction$inboundSchema = nativeEnumType(VerifyRequestAction);
  var VerifyRequestAction$outboundSchema = VerifyRequestAction$inboundSchema;
  var VerifyRequestAction$;
  (function(VerifyRequestAction$2) {
    VerifyRequestAction$2.inboundSchema = VerifyRequestAction$inboundSchema;
    VerifyRequestAction$2.outboundSchema = VerifyRequestAction$outboundSchema;
  })(VerifyRequestAction$ || (VerifyRequestAction$ = {}));
  var VerifyRequest$inboundSchema = objectType({
    documentId: stringType(),
    action: VerifyRequestAction$inboundSchema.optional()
  });
  var VerifyRequest$outboundSchema = objectType({
    documentId: stringType(),
    action: VerifyRequestAction$outboundSchema.optional()
  });
  var VerifyRequest$;
  (function(VerifyRequest$2) {
    VerifyRequest$2.inboundSchema = VerifyRequest$inboundSchema;
    VerifyRequest$2.outboundSchema = VerifyRequest$outboundSchema;
  })(VerifyRequest$ || (VerifyRequest$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/operations/chat.js
  var ChatRequest$inboundSchema2 = objectType({
    timezoneOffset: numberType().int().optional(),
    ChatRequest: ChatRequest$inboundSchema
  }).transform((v) => {
    return remap(v, {
      "ChatRequest": "chatRequest"
    });
  });
  var ChatRequest$outboundSchema2 = objectType({
    timezoneOffset: numberType().int().optional(),
    chatRequest: ChatRequest$outboundSchema
  }).transform((v) => {
    return remap(v, {
      chatRequest: "ChatRequest"
    });
  });
  var ChatRequest$2;
  (function(ChatRequest$3) {
    ChatRequest$3.inboundSchema = ChatRequest$inboundSchema2;
    ChatRequest$3.outboundSchema = ChatRequest$outboundSchema2;
  })(ChatRequest$2 || (ChatRequest$2 = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/operations/chatstream.js
  var ChatStreamRequest$inboundSchema = objectType({
    timezoneOffset: numberType().int().optional(),
    ChatRequest: ChatRequest$inboundSchema
  }).transform((v) => {
    return remap(v, {
      "ChatRequest": "chatRequest"
    });
  });
  var ChatStreamRequest$outboundSchema = objectType({
    timezoneOffset: numberType().int().optional(),
    chatRequest: ChatRequest$outboundSchema
  }).transform((v) => {
    return remap(v, {
      chatRequest: "ChatRequest"
    });
  });
  var ChatStreamRequest$;
  (function(ChatStreamRequest$2) {
    ChatStreamRequest$2.inboundSchema = ChatStreamRequest$inboundSchema;
    ChatStreamRequest$2.outboundSchema = ChatStreamRequest$outboundSchema;
  })(ChatStreamRequest$ || (ChatStreamRequest$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/operations/createcollection.js
  var ResponseBody2$inboundSchema = objectType({
    collection: Collection$inboundSchema.optional(),
    error: CollectionError$inboundSchema
  });
  var ResponseBody2$outboundSchema = objectType({
    collection: Collection$outboundSchema.optional(),
    error: CollectionError$outboundSchema
  });
  var ResponseBody2$;
  (function(ResponseBody2$2) {
    ResponseBody2$2.inboundSchema = ResponseBody2$inboundSchema;
    ResponseBody2$2.outboundSchema = ResponseBody2$outboundSchema;
  })(ResponseBody2$ || (ResponseBody2$ = {}));
  var ResponseBody1$inboundSchema = objectType({
    collection: Collection$inboundSchema,
    error: CollectionError$inboundSchema.optional()
  });
  var ResponseBody1$outboundSchema = objectType({
    collection: Collection$outboundSchema,
    error: CollectionError$outboundSchema.optional()
  });
  var ResponseBody1$;
  (function(ResponseBody1$2) {
    ResponseBody1$2.inboundSchema = ResponseBody1$inboundSchema;
    ResponseBody1$2.outboundSchema = ResponseBody1$outboundSchema;
  })(ResponseBody1$ || (ResponseBody1$ = {}));
  var CreatecollectionResponse$inboundSchema = unionType([
    lazyType(() => ResponseBody1$inboundSchema),
    lazyType(() => ResponseBody2$inboundSchema)
  ]);
  var CreatecollectionResponse$outboundSchema = unionType([
    lazyType(() => ResponseBody1$outboundSchema),
    lazyType(() => ResponseBody2$outboundSchema)
  ]);
  var CreatecollectionResponse$;
  (function(CreatecollectionResponse$2) {
    CreatecollectionResponse$2.inboundSchema = CreatecollectionResponse$inboundSchema;
    CreatecollectionResponse$2.outboundSchema = CreatecollectionResponse$outboundSchema;
  })(CreatecollectionResponse$ || (CreatecollectionResponse$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/operations/deleteallchats.js
  var DeleteallchatsRequest$inboundSchema = objectType({
    timezoneOffset: numberType().int().optional()
  });
  var DeleteallchatsRequest$outboundSchema = objectType({
    timezoneOffset: numberType().int().optional()
  });
  var DeleteallchatsRequest$;
  (function(DeleteallchatsRequest$2) {
    DeleteallchatsRequest$2.inboundSchema = DeleteallchatsRequest$inboundSchema;
    DeleteallchatsRequest$2.outboundSchema = DeleteallchatsRequest$outboundSchema;
  })(DeleteallchatsRequest$ || (DeleteallchatsRequest$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/operations/deletechatfiles.js
  var DeletechatfilesRequest$inboundSchema = objectType({
    timezoneOffset: numberType().int().optional(),
    DeleteChatFilesRequest: DeleteChatFilesRequest$inboundSchema
  }).transform((v) => {
    return remap(v, {
      "DeleteChatFilesRequest": "deleteChatFilesRequest"
    });
  });
  var DeletechatfilesRequest$outboundSchema = objectType({
    timezoneOffset: numberType().int().optional(),
    deleteChatFilesRequest: DeleteChatFilesRequest$outboundSchema
  }).transform((v) => {
    return remap(v, {
      deleteChatFilesRequest: "DeleteChatFilesRequest"
    });
  });
  var DeletechatfilesRequest$;
  (function(DeletechatfilesRequest$2) {
    DeletechatfilesRequest$2.inboundSchema = DeletechatfilesRequest$inboundSchema;
    DeletechatfilesRequest$2.outboundSchema = DeletechatfilesRequest$outboundSchema;
  })(DeletechatfilesRequest$ || (DeletechatfilesRequest$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/operations/deletechats.js
  var DeletechatsRequest$inboundSchema = objectType({
    timezoneOffset: numberType().int().optional(),
    DeleteChatsRequest: DeleteChatsRequest$inboundSchema
  }).transform((v) => {
    return remap(v, {
      "DeleteChatsRequest": "deleteChatsRequest"
    });
  });
  var DeletechatsRequest$outboundSchema = objectType({
    timezoneOffset: numberType().int().optional(),
    deleteChatsRequest: DeleteChatsRequest$outboundSchema
  }).transform((v) => {
    return remap(v, {
      deleteChatsRequest: "DeleteChatsRequest"
    });
  });
  var DeletechatsRequest$;
  (function(DeletechatsRequest$2) {
    DeletechatsRequest$2.inboundSchema = DeletechatsRequest$inboundSchema;
    DeletechatsRequest$2.outboundSchema = DeletechatsRequest$outboundSchema;
  })(DeletechatsRequest$ || (DeletechatsRequest$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/operations/downloadpolicycsv.js
  var DownloadpolicycsvRequest$inboundSchema = objectType({
    id: stringType()
  });
  var DownloadpolicycsvRequest$outboundSchema = objectType({
    id: stringType()
  });
  var DownloadpolicycsvRequest$;
  (function(DownloadpolicycsvRequest$2) {
    DownloadpolicycsvRequest$2.inboundSchema = DownloadpolicycsvRequest$inboundSchema;
    DownloadpolicycsvRequest$2.outboundSchema = DownloadpolicycsvRequest$outboundSchema;
  })(DownloadpolicycsvRequest$ || (DownloadpolicycsvRequest$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/operations/downloadreportcsv.js
  var DownloadreportcsvRequest$inboundSchema = objectType({
    id: stringType()
  });
  var DownloadreportcsvRequest$outboundSchema = objectType({
    id: stringType()
  });
  var DownloadreportcsvRequest$;
  (function(DownloadreportcsvRequest$2) {
    DownloadreportcsvRequest$2.inboundSchema = DownloadreportcsvRequest$inboundSchema;
    DownloadreportcsvRequest$2.outboundSchema = DownloadreportcsvRequest$outboundSchema;
  })(DownloadreportcsvRequest$ || (DownloadreportcsvRequest$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/operations/feedback.js
  var FeedbackRequest$inboundSchema = objectType({
    feedbackQueryParameter: stringType().optional(),
    Feedback1: Feedback$inboundSchema.optional()
  }).transform((v) => {
    return remap(v, {
      "Feedback1": "feedback1"
    });
  });
  var FeedbackRequest$outboundSchema = objectType({
    feedbackQueryParameter: stringType().optional(),
    feedback1: Feedback$outboundSchema.optional()
  }).transform((v) => {
    return remap(v, {
      feedback1: "Feedback1"
    });
  });
  var FeedbackRequest$;
  (function(FeedbackRequest$2) {
    FeedbackRequest$2.inboundSchema = FeedbackRequest$inboundSchema;
    FeedbackRequest$2.outboundSchema = FeedbackRequest$outboundSchema;
  })(FeedbackRequest$ || (FeedbackRequest$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/operations/getagent.js
  var GetAgentRequest$inboundSchema = objectType({
    timezoneOffset: numberType().int().optional(),
    agent_id: stringType()
  }).transform((v) => {
    return remap(v, {
      "agent_id": "agentId"
    });
  });
  var GetAgentRequest$outboundSchema = objectType({
    timezoneOffset: numberType().int().optional(),
    agentId: stringType()
  }).transform((v) => {
    return remap(v, {
      agentId: "agent_id"
    });
  });
  var GetAgentRequest$;
  (function(GetAgentRequest$2) {
    GetAgentRequest$2.inboundSchema = GetAgentRequest$inboundSchema;
    GetAgentRequest$2.outboundSchema = GetAgentRequest$outboundSchema;
  })(GetAgentRequest$ || (GetAgentRequest$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/operations/getagentschemas.js
  var GetAgentSchemasRequest$inboundSchema = objectType({
    timezoneOffset: numberType().int().optional(),
    agent_id: stringType()
  }).transform((v) => {
    return remap(v, {
      "agent_id": "agentId"
    });
  });
  var GetAgentSchemasRequest$outboundSchema = objectType({
    timezoneOffset: numberType().int().optional(),
    agentId: stringType()
  }).transform((v) => {
    return remap(v, {
      agentId: "agent_id"
    });
  });
  var GetAgentSchemasRequest$;
  (function(GetAgentSchemasRequest$2) {
    GetAgentSchemasRequest$2.inboundSchema = GetAgentSchemasRequest$inboundSchema;
    GetAgentSchemasRequest$2.outboundSchema = GetAgentSchemasRequest$outboundSchema;
  })(GetAgentSchemasRequest$ || (GetAgentSchemasRequest$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/operations/getchat.js
  var GetchatRequest$inboundSchema = objectType({
    timezoneOffset: numberType().int().optional(),
    GetChatRequest: GetChatRequest$inboundSchema
  }).transform((v) => {
    return remap(v, {
      "GetChatRequest": "getChatRequest"
    });
  });
  var GetchatRequest$outboundSchema = objectType({
    timezoneOffset: numberType().int().optional(),
    getChatRequest: GetChatRequest$outboundSchema
  }).transform((v) => {
    return remap(v, {
      getChatRequest: "GetChatRequest"
    });
  });
  var GetchatRequest$;
  (function(GetchatRequest$2) {
    GetchatRequest$2.inboundSchema = GetchatRequest$inboundSchema;
    GetchatRequest$2.outboundSchema = GetchatRequest$outboundSchema;
  })(GetchatRequest$ || (GetchatRequest$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/operations/getchatapplication.js
  var GetchatapplicationRequest$inboundSchema = objectType({
    timezoneOffset: numberType().int().optional(),
    GetChatApplicationRequest: GetChatApplicationRequest$inboundSchema
  }).transform((v) => {
    return remap(v, {
      "GetChatApplicationRequest": "getChatApplicationRequest"
    });
  });
  var GetchatapplicationRequest$outboundSchema = objectType({
    timezoneOffset: numberType().int().optional(),
    getChatApplicationRequest: GetChatApplicationRequest$outboundSchema
  }).transform((v) => {
    return remap(v, {
      getChatApplicationRequest: "GetChatApplicationRequest"
    });
  });
  var GetchatapplicationRequest$;
  (function(GetchatapplicationRequest$2) {
    GetchatapplicationRequest$2.inboundSchema = GetchatapplicationRequest$inboundSchema;
    GetchatapplicationRequest$2.outboundSchema = GetchatapplicationRequest$outboundSchema;
  })(GetchatapplicationRequest$ || (GetchatapplicationRequest$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/operations/getchatfiles.js
  var GetchatfilesRequest$inboundSchema = objectType({
    timezoneOffset: numberType().int().optional(),
    GetChatFilesRequest: GetChatFilesRequest$inboundSchema
  }).transform((v) => {
    return remap(v, {
      "GetChatFilesRequest": "getChatFilesRequest"
    });
  });
  var GetchatfilesRequest$outboundSchema = objectType({
    timezoneOffset: numberType().int().optional(),
    getChatFilesRequest: GetChatFilesRequest$outboundSchema
  }).transform((v) => {
    return remap(v, {
      getChatFilesRequest: "GetChatFilesRequest"
    });
  });
  var GetchatfilesRequest$;
  (function(GetchatfilesRequest$2) {
    GetchatfilesRequest$2.inboundSchema = GetchatfilesRequest$inboundSchema;
    GetchatfilesRequest$2.outboundSchema = GetchatfilesRequest$outboundSchema;
  })(GetchatfilesRequest$ || (GetchatfilesRequest$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/operations/getdocvisibility.js
  var GetdocvisibilityRequest$inboundSchema = objectType({
    docIds: arrayType(stringType()).optional()
  });
  var GetdocvisibilityRequest$outboundSchema = objectType({
    docIds: arrayType(stringType()).optional()
  });
  var GetdocvisibilityRequest$;
  (function(GetdocvisibilityRequest$2) {
    GetdocvisibilityRequest$2.inboundSchema = GetdocvisibilityRequest$inboundSchema;
    GetdocvisibilityRequest$2.outboundSchema = GetdocvisibilityRequest$outboundSchema;
  })(GetdocvisibilityRequest$ || (GetdocvisibilityRequest$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/operations/getpolicy.js
  var GetpolicyRequest$inboundSchema = objectType({
    id: stringType(),
    version: numberType().int().optional()
  });
  var GetpolicyRequest$outboundSchema = objectType({
    id: stringType(),
    version: numberType().int().optional()
  });
  var GetpolicyRequest$;
  (function(GetpolicyRequest$2) {
    GetpolicyRequest$2.inboundSchema = GetpolicyRequest$inboundSchema;
    GetpolicyRequest$2.outboundSchema = GetpolicyRequest$outboundSchema;
  })(GetpolicyRequest$ || (GetpolicyRequest$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/operations/getreportstatus.js
  var GetreportstatusRequest$inboundSchema = objectType({
    id: stringType()
  });
  var GetreportstatusRequest$outboundSchema = objectType({
    id: stringType()
  });
  var GetreportstatusRequest$;
  (function(GetreportstatusRequest$2) {
    GetreportstatusRequest$2.inboundSchema = GetreportstatusRequest$inboundSchema;
    GetreportstatusRequest$2.outboundSchema = GetreportstatusRequest$outboundSchema;
  })(GetreportstatusRequest$ || (GetreportstatusRequest$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/operations/getrestapiv1toolslist.js
  var GetRestApiV1ToolsListRequest$inboundSchema = objectType({
    toolNames: arrayType(stringType()).optional()
  });
  var GetRestApiV1ToolsListRequest$outboundSchema = objectType({
    toolNames: arrayType(stringType()).optional()
  });
  var GetRestApiV1ToolsListRequest$;
  (function(GetRestApiV1ToolsListRequest$2) {
    GetRestApiV1ToolsListRequest$2.inboundSchema = GetRestApiV1ToolsListRequest$inboundSchema;
    GetRestApiV1ToolsListRequest$2.outboundSchema = GetRestApiV1ToolsListRequest$outboundSchema;
  })(GetRestApiV1ToolsListRequest$ || (GetRestApiV1ToolsListRequest$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/operations/listchats.js
  var ListchatsRequest$inboundSchema = objectType({
    timezoneOffset: numberType().int().optional()
  });
  var ListchatsRequest$outboundSchema = objectType({
    timezoneOffset: numberType().int().optional()
  });
  var ListchatsRequest$;
  (function(ListchatsRequest$2) {
    ListchatsRequest$2.inboundSchema = ListchatsRequest$inboundSchema;
    ListchatsRequest$2.outboundSchema = ListchatsRequest$outboundSchema;
  })(ListchatsRequest$ || (ListchatsRequest$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/operations/listpins.js
  var ListpinsRequest$inboundSchema = objectType({});
  var ListpinsRequest$outboundSchema = objectType({});
  var ListpinsRequest$;
  (function(ListpinsRequest$2) {
    ListpinsRequest$2.inboundSchema = ListpinsRequest$inboundSchema;
    ListpinsRequest$2.outboundSchema = ListpinsRequest$outboundSchema;
  })(ListpinsRequest$ || (ListpinsRequest$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/operations/listpolicies.js
  var ListpoliciesRequest$inboundSchema = objectType({
    autoHide: booleanType().optional(),
    frequency: stringType().optional()
  });
  var ListpoliciesRequest$outboundSchema = objectType({
    autoHide: booleanType().optional(),
    frequency: stringType().optional()
  });
  var ListpoliciesRequest$;
  (function(ListpoliciesRequest$2) {
    ListpoliciesRequest$2.inboundSchema = ListpoliciesRequest$inboundSchema;
    ListpoliciesRequest$2.outboundSchema = ListpoliciesRequest$outboundSchema;
  })(ListpoliciesRequest$ || (ListpoliciesRequest$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/operations/listverifications.js
  var ListverificationsRequest$inboundSchema = objectType({
    count: numberType().int().optional()
  });
  var ListverificationsRequest$outboundSchema = objectType({
    count: numberType().int().optional()
  });
  var ListverificationsRequest$;
  (function(ListverificationsRequest$2) {
    ListverificationsRequest$2.inboundSchema = ListverificationsRequest$inboundSchema;
    ListverificationsRequest$2.outboundSchema = ListverificationsRequest$outboundSchema;
  })(ListverificationsRequest$ || (ListverificationsRequest$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/operations/postapiindexv1debugdatasourcedocument.js
  var PostApiIndexV1DebugDatasourceDocumentRequest$inboundSchema = objectType({
    datasource: stringType(),
    DebugDocumentRequest: DebugDocumentRequest$inboundSchema
  }).transform((v) => {
    return remap(v, {
      "DebugDocumentRequest": "debugDocumentRequest"
    });
  });
  var PostApiIndexV1DebugDatasourceDocumentRequest$outboundSchema = objectType({
    datasource: stringType(),
    debugDocumentRequest: DebugDocumentRequest$outboundSchema
  }).transform((v) => {
    return remap(v, {
      debugDocumentRequest: "DebugDocumentRequest"
    });
  });
  var PostApiIndexV1DebugDatasourceDocumentRequest$;
  (function(PostApiIndexV1DebugDatasourceDocumentRequest$2) {
    PostApiIndexV1DebugDatasourceDocumentRequest$2.inboundSchema = PostApiIndexV1DebugDatasourceDocumentRequest$inboundSchema;
    PostApiIndexV1DebugDatasourceDocumentRequest$2.outboundSchema = PostApiIndexV1DebugDatasourceDocumentRequest$outboundSchema;
  })(PostApiIndexV1DebugDatasourceDocumentRequest$ || (PostApiIndexV1DebugDatasourceDocumentRequest$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/operations/postapiindexv1debugdatasourcedocuments.js
  var PostApiIndexV1DebugDatasourceDocumentsRequest$inboundSchema = objectType({
    datasource: stringType(),
    DebugDocumentsRequest: DebugDocumentsRequest$inboundSchema
  }).transform((v) => {
    return remap(v, {
      "DebugDocumentsRequest": "debugDocumentsRequest"
    });
  });
  var PostApiIndexV1DebugDatasourceDocumentsRequest$outboundSchema = objectType({
    datasource: stringType(),
    debugDocumentsRequest: DebugDocumentsRequest$outboundSchema
  }).transform((v) => {
    return remap(v, {
      debugDocumentsRequest: "DebugDocumentsRequest"
    });
  });
  var PostApiIndexV1DebugDatasourceDocumentsRequest$;
  (function(PostApiIndexV1DebugDatasourceDocumentsRequest$2) {
    PostApiIndexV1DebugDatasourceDocumentsRequest$2.inboundSchema = PostApiIndexV1DebugDatasourceDocumentsRequest$inboundSchema;
    PostApiIndexV1DebugDatasourceDocumentsRequest$2.outboundSchema = PostApiIndexV1DebugDatasourceDocumentsRequest$outboundSchema;
  })(PostApiIndexV1DebugDatasourceDocumentsRequest$ || (PostApiIndexV1DebugDatasourceDocumentsRequest$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/operations/postapiindexv1debugdatasourcestatus.js
  var PostApiIndexV1DebugDatasourceStatusRequest$inboundSchema = objectType({
    datasource: stringType()
  });
  var PostApiIndexV1DebugDatasourceStatusRequest$outboundSchema = objectType({
    datasource: stringType()
  });
  var PostApiIndexV1DebugDatasourceStatusRequest$;
  (function(PostApiIndexV1DebugDatasourceStatusRequest$2) {
    PostApiIndexV1DebugDatasourceStatusRequest$2.inboundSchema = PostApiIndexV1DebugDatasourceStatusRequest$inboundSchema;
    PostApiIndexV1DebugDatasourceStatusRequest$2.outboundSchema = PostApiIndexV1DebugDatasourceStatusRequest$outboundSchema;
  })(PostApiIndexV1DebugDatasourceStatusRequest$ || (PostApiIndexV1DebugDatasourceStatusRequest$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/operations/postapiindexv1debugdatasourceuser.js
  var PostApiIndexV1DebugDatasourceUserRequest$inboundSchema = objectType({
    datasource: stringType(),
    DebugUserRequest: DebugUserRequest$inboundSchema
  }).transform((v) => {
    return remap(v, {
      "DebugUserRequest": "debugUserRequest"
    });
  });
  var PostApiIndexV1DebugDatasourceUserRequest$outboundSchema = objectType({
    datasource: stringType(),
    debugUserRequest: DebugUserRequest$outboundSchema
  }).transform((v) => {
    return remap(v, {
      debugUserRequest: "DebugUserRequest"
    });
  });
  var PostApiIndexV1DebugDatasourceUserRequest$;
  (function(PostApiIndexV1DebugDatasourceUserRequest$2) {
    PostApiIndexV1DebugDatasourceUserRequest$2.inboundSchema = PostApiIndexV1DebugDatasourceUserRequest$inboundSchema;
    PostApiIndexV1DebugDatasourceUserRequest$2.outboundSchema = PostApiIndexV1DebugDatasourceUserRequest$outboundSchema;
  })(PostApiIndexV1DebugDatasourceUserRequest$ || (PostApiIndexV1DebugDatasourceUserRequest$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/operations/updatepolicy.js
  var UpdatepolicyRequest$inboundSchema = objectType({
    id: stringType(),
    UpdateDlpReportRequest: UpdateDlpReportRequest$inboundSchema
  }).transform((v) => {
    return remap(v, {
      "UpdateDlpReportRequest": "updateDlpReportRequest"
    });
  });
  var UpdatepolicyRequest$outboundSchema = objectType({
    id: stringType(),
    updateDlpReportRequest: UpdateDlpReportRequest$outboundSchema
  }).transform((v) => {
    return remap(v, {
      updateDlpReportRequest: "UpdateDlpReportRequest"
    });
  });
  var UpdatepolicyRequest$;
  (function(UpdatepolicyRequest$2) {
    UpdatepolicyRequest$2.inboundSchema = UpdatepolicyRequest$inboundSchema;
    UpdatepolicyRequest$2.outboundSchema = UpdatepolicyRequest$outboundSchema;
  })(UpdatepolicyRequest$ || (UpdatepolicyRequest$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/operations/uploadchatfiles.js
  var UploadchatfilesRequest$inboundSchema = objectType({
    timezoneOffset: numberType().int().optional(),
    UploadChatFilesRequest: UploadChatFilesRequest$inboundSchema
  }).transform((v) => {
    return remap(v, {
      "UploadChatFilesRequest": "uploadChatFilesRequest"
    });
  });
  var UploadchatfilesRequest$outboundSchema = objectType({
    timezoneOffset: numberType().int().optional(),
    uploadChatFilesRequest: UploadChatFilesRequest$outboundSchema
  }).transform((v) => {
    return remap(v, {
      uploadChatFilesRequest: "UploadChatFilesRequest"
    });
  });
  var UploadchatfilesRequest$;
  (function(UploadchatfilesRequest$2) {
    UploadchatfilesRequest$2.inboundSchema = UploadchatfilesRequest$inboundSchema;
    UploadchatfilesRequest$2.outboundSchema = UploadchatfilesRequest$outboundSchema;
  })(UploadchatfilesRequest$ || (UploadchatfilesRequest$ = {}));

  // node_modules/@gleanwork/api-client/dist/esm/types/async.js
  var __classPrivateFieldSet2 = function(receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
  };
  var __classPrivateFieldGet2 = function(receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
  };
  var _APIPromise_promise;
  var _APIPromise_unwrapped;
  var _a;
  var APIPromise = class {
    constructor(p) {
      _APIPromise_promise.set(this, void 0);
      _APIPromise_unwrapped.set(this, void 0);
      this[_a] = "APIPromise";
      __classPrivateFieldSet2(this, _APIPromise_promise, p instanceof Promise ? p : Promise.resolve(p), "f");
      __classPrivateFieldSet2(this, _APIPromise_unwrapped, p instanceof Promise ? __classPrivateFieldGet2(this, _APIPromise_promise, "f").then(([value]) => value) : Promise.resolve(p[0]), "f");
    }
    then(onfulfilled, onrejected) {
      return __classPrivateFieldGet2(this, _APIPromise_promise, "f").then(onfulfilled ? ([value]) => onfulfilled(value) : void 0, onrejected);
    }
    catch(onrejected) {
      return __classPrivateFieldGet2(this, _APIPromise_unwrapped, "f").catch(onrejected);
    }
    finally(onfinally) {
      return __classPrivateFieldGet2(this, _APIPromise_unwrapped, "f").finally(onfinally);
    }
    $inspect() {
      return __classPrivateFieldGet2(this, _APIPromise_promise, "f");
    }
  };
  _APIPromise_promise = /* @__PURE__ */ new WeakMap(), _APIPromise_unwrapped = /* @__PURE__ */ new WeakMap(), _a = Symbol.toStringTag;

  // node_modules/@gleanwork/api-client/dist/esm/funcs/clientActivityFeedback.js
  function clientActivityFeedback(client, feedback1, feedbackQueryParameter, options) {
    return new APIPromise($do(client, feedback1, feedbackQueryParameter, options));
  }
  async function $do(client, feedback1, feedbackQueryParameter, options) {
    const input = {
      feedback1,
      feedbackQueryParameter
    };
    const parsed = safeParse(input, (value) => FeedbackRequest$outboundSchema.parse(value), "Input validation failed");
    if (!parsed.ok) {
      return [parsed, { status: "invalid" }];
    }
    const payload = parsed.value;
    const body = encodeJSON("body", payload.Feedback1, { explode: true });
    const path = pathToFunc("/rest/api/v1/feedback")();
    const query = encodeFormQuery({
      "feedback": payload.feedbackQueryParameter
    });
    const headers = new Headers(compactMap({
      "Content-Type": "application/json",
      Accept: "*/*"
    }));
    const secConfig = await extractSecurity(client._options.apiToken);
    const securityInput = secConfig == null ? {} : { apiToken: secConfig };
    const requestSecurity = resolveGlobalSecurity(securityInput);
    const context = {
      options: client._options,
      baseURL: options?.serverURL ?? client._baseURL ?? "",
      operationID: "feedback",
      oAuth2Scopes: [],
      resolvedSecurity: requestSecurity,
      securitySource: client._options.apiToken,
      retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
      retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
    };
    const requestRes = client._createRequest(context, {
      security: requestSecurity,
      method: "POST",
      baseURL: options?.serverURL,
      path,
      headers,
      query,
      body,
      userAgent: client._options.userAgent,
      timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
    }, options);
    if (!requestRes.ok) {
      return [requestRes, { status: "invalid" }];
    }
    const req = requestRes.value;
    const doResult = await client._do(req, {
      context,
      errorCodes: ["400", "401", "429", "4XX", "5XX"],
      retryConfig: context.retryConfig,
      retryCodes: context.retryCodes
    });
    if (!doResult.ok) {
      return [doResult, { status: "request-error", request: req }];
    }
    const response = doResult.value;
    const [result] = await match(nil(200, voidType()), fail([400, 401, 429, "4XX"]), fail("5XX"))(response, req);
    if (!result.ok) {
      return [result, { status: "complete", request: req, response }];
    }
    return [result, { status: "complete", request: req, response }];
  }

  // node_modules/@gleanwork/api-client/dist/esm/funcs/clientActivityReport.js
  function clientActivityReport(client, request, options) {
    return new APIPromise($do2(client, request, options));
  }
  async function $do2(client, request, options) {
    const parsed = safeParse(request, (value) => Activity$outboundSchema.parse(value), "Input validation failed");
    if (!parsed.ok) {
      return [parsed, { status: "invalid" }];
    }
    const payload = parsed.value;
    const body = encodeJSON("body", payload, { explode: true });
    const path = pathToFunc("/rest/api/v1/activity")();
    const headers = new Headers(compactMap({
      "Content-Type": "application/json",
      Accept: "*/*"
    }));
    const secConfig = await extractSecurity(client._options.apiToken);
    const securityInput = secConfig == null ? {} : { apiToken: secConfig };
    const requestSecurity = resolveGlobalSecurity(securityInput);
    const context = {
      options: client._options,
      baseURL: options?.serverURL ?? client._baseURL ?? "",
      operationID: "activity",
      oAuth2Scopes: [],
      resolvedSecurity: requestSecurity,
      securitySource: client._options.apiToken,
      retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
      retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
    };
    const requestRes = client._createRequest(context, {
      security: requestSecurity,
      method: "POST",
      baseURL: options?.serverURL,
      path,
      headers,
      body,
      userAgent: client._options.userAgent,
      timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
    }, options);
    if (!requestRes.ok) {
      return [requestRes, { status: "invalid" }];
    }
    const req = requestRes.value;
    const doResult = await client._do(req, {
      context,
      errorCodes: ["400", "401", "429", "4XX", "5XX"],
      retryConfig: context.retryConfig,
      retryCodes: context.retryCodes
    });
    if (!doResult.ok) {
      return [doResult, { status: "request-error", request: req }];
    }
    const response = doResult.value;
    const [result] = await match(nil(200, voidType()), fail([400, 401, 429, "4XX"]), fail("5XX"))(response, req);
    if (!result.ok) {
      return [result, { status: "complete", request: req, response }];
    }
    return [result, { status: "complete", request: req, response }];
  }

  // node_modules/@gleanwork/api-client/dist/esm/sdk/activity.js
  var Activity = class extends ClientSDK {
    /**
     * Report document activity
     *
     * @remarks
     * Report user activity that occurs on indexed documents such as viewing or editing. This signal improves search quality.
     */
    async report(request, options) {
      return unwrapAsync(clientActivityReport(this, request, options));
    }
    /**
     * Report client activity
     *
     * @remarks
     * Report events that happen to results within a Glean client UI, such as search result views and clicks.  This signal improves search quality.
     */
    async feedback(feedback1, feedbackQueryParameter, options) {
      return unwrapAsync(clientActivityFeedback(this, feedback1, feedbackQueryParameter, options));
    }
  };

  // node_modules/@gleanwork/api-client/dist/esm/funcs/clientAgentsList.js
  function clientAgentsList(client, request, options) {
    return new APIPromise($do3(client, request, options));
  }
  async function $do3(client, request, options) {
    const parsed = safeParse(request, (value) => SearchAgentsRequest$outboundSchema.parse(value), "Input validation failed");
    if (!parsed.ok) {
      return [parsed, { status: "invalid" }];
    }
    const payload = parsed.value;
    const body = encodeJSON("body", payload, { explode: true });
    const path = pathToFunc("/rest/api/v1/agents/search")();
    const headers = new Headers(compactMap({
      "Content-Type": "application/json",
      Accept: "application/json"
    }));
    const secConfig = await extractSecurity(client._options.apiToken);
    const securityInput = secConfig == null ? {} : { apiToken: secConfig };
    const requestSecurity = resolveGlobalSecurity(securityInput);
    const context = {
      options: client._options,
      baseURL: options?.serverURL ?? client._baseURL ?? "",
      operationID: "searchAgents",
      oAuth2Scopes: [],
      resolvedSecurity: requestSecurity,
      securitySource: client._options.apiToken,
      retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
      retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
    };
    const requestRes = client._createRequest(context, {
      security: requestSecurity,
      method: "POST",
      baseURL: options?.serverURL,
      path,
      headers,
      body,
      userAgent: client._options.userAgent,
      timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
    }, options);
    if (!requestRes.ok) {
      return [requestRes, { status: "invalid" }];
    }
    const req = requestRes.value;
    const doResult = await client._do(req, {
      context,
      errorCodes: ["400", "403", "404", "422", "4XX", "500", "5XX"],
      retryConfig: context.retryConfig,
      retryCodes: context.retryCodes
    });
    if (!doResult.ok) {
      return [doResult, { status: "request-error", request: req }];
    }
    const response = doResult.value;
    const [result] = await match(json(200, SearchAgentsResponse$inboundSchema), fail([400, 403, 404, 422, "4XX"]), fail([500, "5XX"]))(response, req);
    if (!result.ok) {
      return [result, { status: "complete", request: req, response }];
    }
    return [result, { status: "complete", request: req, response }];
  }

  // node_modules/@gleanwork/api-client/dist/esm/funcs/clientAgentsRetrieve.js
  function clientAgentsRetrieve(client, agentId, timezoneOffset, options) {
    return new APIPromise($do4(client, agentId, timezoneOffset, options));
  }
  async function $do4(client, agentId, timezoneOffset, options) {
    const input = {
      agentId,
      timezoneOffset
    };
    const parsed = safeParse(input, (value) => GetAgentRequest$outboundSchema.parse(value), "Input validation failed");
    if (!parsed.ok) {
      return [parsed, { status: "invalid" }];
    }
    const payload = parsed.value;
    const body = null;
    const pathParams = {
      agent_id: encodeSimple("agent_id", payload.agent_id, {
        explode: false,
        charEncoding: "percent"
      })
    };
    const path = pathToFunc("/rest/api/v1/agents/{agent_id}")(pathParams);
    const query = encodeFormQuery({
      "timezoneOffset": payload.timezoneOffset
    });
    const headers = new Headers(compactMap({
      Accept: "application/json"
    }));
    const secConfig = await extractSecurity(client._options.apiToken);
    const securityInput = secConfig == null ? {} : { apiToken: secConfig };
    const requestSecurity = resolveGlobalSecurity(securityInput);
    const context = {
      options: client._options,
      baseURL: options?.serverURL ?? client._baseURL ?? "",
      operationID: "getAgent",
      oAuth2Scopes: [],
      resolvedSecurity: requestSecurity,
      securitySource: client._options.apiToken,
      retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
      retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
    };
    const requestRes = client._createRequest(context, {
      security: requestSecurity,
      method: "GET",
      baseURL: options?.serverURL,
      path,
      headers,
      query,
      body,
      userAgent: client._options.userAgent,
      timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
    }, options);
    if (!requestRes.ok) {
      return [requestRes, { status: "invalid" }];
    }
    const req = requestRes.value;
    const doResult = await client._do(req, {
      context,
      errorCodes: ["400", "403", "404", "4XX", "500", "5XX"],
      retryConfig: context.retryConfig,
      retryCodes: context.retryCodes
    });
    if (!doResult.ok) {
      return [doResult, { status: "request-error", request: req }];
    }
    const response = doResult.value;
    const [result] = await match(json(200, Agent$inboundSchema), fail([400, 403, 404, "4XX"]), fail([500, "5XX"]))(response, req);
    if (!result.ok) {
      return [result, { status: "complete", request: req, response }];
    }
    return [result, { status: "complete", request: req, response }];
  }

  // node_modules/@gleanwork/api-client/dist/esm/funcs/clientAgentsRetrieveSchemas.js
  function clientAgentsRetrieveSchemas(client, agentId, timezoneOffset, options) {
    return new APIPromise($do5(client, agentId, timezoneOffset, options));
  }
  async function $do5(client, agentId, timezoneOffset, options) {
    const input = {
      agentId,
      timezoneOffset
    };
    const parsed = safeParse(input, (value) => GetAgentSchemasRequest$outboundSchema.parse(value), "Input validation failed");
    if (!parsed.ok) {
      return [parsed, { status: "invalid" }];
    }
    const payload = parsed.value;
    const body = null;
    const pathParams = {
      agent_id: encodeSimple("agent_id", payload.agent_id, {
        explode: false,
        charEncoding: "percent"
      })
    };
    const path = pathToFunc("/rest/api/v1/agents/{agent_id}/schemas")(pathParams);
    const query = encodeFormQuery({
      "timezoneOffset": payload.timezoneOffset
    });
    const headers = new Headers(compactMap({
      Accept: "application/json"
    }));
    const secConfig = await extractSecurity(client._options.apiToken);
    const securityInput = secConfig == null ? {} : { apiToken: secConfig };
    const requestSecurity = resolveGlobalSecurity(securityInput);
    const context = {
      options: client._options,
      baseURL: options?.serverURL ?? client._baseURL ?? "",
      operationID: "getAgentSchemas",
      oAuth2Scopes: [],
      resolvedSecurity: requestSecurity,
      securitySource: client._options.apiToken,
      retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
      retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
    };
    const requestRes = client._createRequest(context, {
      security: requestSecurity,
      method: "GET",
      baseURL: options?.serverURL,
      path,
      headers,
      query,
      body,
      userAgent: client._options.userAgent,
      timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
    }, options);
    if (!requestRes.ok) {
      return [requestRes, { status: "invalid" }];
    }
    const req = requestRes.value;
    const doResult = await client._do(req, {
      context,
      errorCodes: ["400", "403", "404", "422", "4XX", "500", "5XX"],
      retryConfig: context.retryConfig,
      retryCodes: context.retryCodes
    });
    if (!doResult.ok) {
      return [doResult, { status: "request-error", request: req }];
    }
    const response = doResult.value;
    const [result] = await match(json(200, AgentSchemas$inboundSchema), fail([400, 403, 404, 422, "4XX"]), fail([500, "5XX"]))(response, req);
    if (!result.ok) {
      return [result, { status: "complete", request: req, response }];
    }
    return [result, { status: "complete", request: req, response }];
  }

  // node_modules/@gleanwork/api-client/dist/esm/funcs/clientAgentsRun.js
  function clientAgentsRun(client, request, options) {
    return new APIPromise($do6(client, request, options));
  }
  async function $do6(client, request, options) {
    const parsed = safeParse(request, (value) => AgentRunCreate$outboundSchema.parse(value), "Input validation failed");
    if (!parsed.ok) {
      return [parsed, { status: "invalid" }];
    }
    const payload = parsed.value;
    const body = encodeJSON("body", payload, { explode: true });
    const path = pathToFunc("/rest/api/v1/agents/runs/wait")();
    const headers = new Headers(compactMap({
      "Content-Type": "application/json",
      Accept: "application/json"
    }));
    const secConfig = await extractSecurity(client._options.apiToken);
    const securityInput = secConfig == null ? {} : { apiToken: secConfig };
    const requestSecurity = resolveGlobalSecurity(securityInput);
    const context = {
      options: client._options,
      baseURL: options?.serverURL ?? client._baseURL ?? "",
      operationID: "createAndWaitRun",
      oAuth2Scopes: [],
      resolvedSecurity: requestSecurity,
      securitySource: client._options.apiToken,
      retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
      retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
    };
    const requestRes = client._createRequest(context, {
      security: requestSecurity,
      method: "POST",
      baseURL: options?.serverURL,
      path,
      headers,
      body,
      userAgent: client._options.userAgent,
      timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
    }, options);
    if (!requestRes.ok) {
      return [requestRes, { status: "invalid" }];
    }
    const req = requestRes.value;
    const doResult = await client._do(req, {
      context,
      errorCodes: ["400", "403", "404", "409", "422", "4XX", "500", "5XX"],
      retryConfig: context.retryConfig,
      retryCodes: context.retryCodes
    });
    if (!doResult.ok) {
      return [doResult, { status: "request-error", request: req }];
    }
    const response = doResult.value;
    const [result] = await match(json(200, AgentRunWaitResponse$inboundSchema), fail([400, 403, 404, 409, 422, "4XX"]), fail([500, "5XX"]))(response, req);
    if (!result.ok) {
      return [result, { status: "complete", request: req, response }];
    }
    return [result, { status: "complete", request: req, response }];
  }

  // node_modules/@gleanwork/api-client/dist/esm/funcs/clientAgentsRunStream.js
  function clientAgentsRunStream(client, request, options) {
    return new APIPromise($do7(client, request, options));
  }
  async function $do7(client, request, options) {
    const parsed = safeParse(request, (value) => AgentRunCreate$outboundSchema.parse(value), "Input validation failed");
    if (!parsed.ok) {
      return [parsed, { status: "invalid" }];
    }
    const payload = parsed.value;
    const body = encodeJSON("body", payload, { explode: true });
    const path = pathToFunc("/rest/api/v1/agents/runs/stream")();
    const headers = new Headers(compactMap({
      "Content-Type": "application/json",
      Accept: "text/event-stream"
    }));
    const secConfig = await extractSecurity(client._options.apiToken);
    const securityInput = secConfig == null ? {} : { apiToken: secConfig };
    const requestSecurity = resolveGlobalSecurity(securityInput);
    const context = {
      options: client._options,
      baseURL: options?.serverURL ?? client._baseURL ?? "",
      operationID: "createAndStreamRun",
      oAuth2Scopes: [],
      resolvedSecurity: requestSecurity,
      securitySource: client._options.apiToken,
      retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
      retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
    };
    const requestRes = client._createRequest(context, {
      security: requestSecurity,
      method: "POST",
      baseURL: options?.serverURL,
      path,
      headers,
      body,
      userAgent: client._options.userAgent,
      timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
    }, options);
    if (!requestRes.ok) {
      return [requestRes, { status: "invalid" }];
    }
    const req = requestRes.value;
    const doResult = await client._do(req, {
      context,
      errorCodes: ["400", "403", "404", "409", "422", "4XX", "500", "5XX"],
      retryConfig: context.retryConfig,
      retryCodes: context.retryCodes
    });
    if (!doResult.ok) {
      return [doResult, { status: "request-error", request: req }];
    }
    const response = doResult.value;
    const [result] = await match(text(200, stringType(), { ctype: "text/event-stream" }), fail([400, 403, 404, 409, 422, "4XX"]), fail([500, "5XX"]))(response, req);
    if (!result.ok) {
      return [result, { status: "complete", request: req, response }];
    }
    return [result, { status: "complete", request: req, response }];
  }

  // node_modules/@gleanwork/api-client/dist/esm/sdk/agents.js
  var Agents = class extends ClientSDK {
    /**
     * Retrieve an agent
     *
     * @remarks
     * Returns details of an [agent](https://developers.glean.com/agents/agents-api) created in the Agent Builder.
     */
    async retrieve(agentId, timezoneOffset, options) {
      return unwrapAsync(clientAgentsRetrieve(this, agentId, timezoneOffset, options));
    }
    /**
     * List an agent's schemas
     *
     * @remarks
     * Return [agent](https://developers.glean.com/agents/agents-api)'s input and output schemas. You can use these schemas to detect changes to an agent's input or output structure.
     */
    async retrieveSchemas(agentId, timezoneOffset, options) {
      return unwrapAsync(clientAgentsRetrieveSchemas(this, agentId, timezoneOffset, options));
    }
    /**
     * Search agents
     *
     * @remarks
     * Search for [agents](https://developers.glean.com/agents/agents-api) by agent name.
     */
    async list(request, options) {
      return unwrapAsync(clientAgentsList(this, request, options));
    }
    /**
     * Create an agent run and stream the response
     *
     * @remarks
     * Executes an [agent](https://developers.glean.com/agents/agents-api) run and returns the result as a stream of server-sent events (SSE).
     */
    async runStream(request, options) {
      return unwrapAsync(clientAgentsRunStream(this, request, options));
    }
    /**
     * Create an agent run and wait for the response
     *
     * @remarks
     * Executes an [agent](https://developers.glean.com/agents/agents-api) run and returns the final response.
     */
    async run(request, options) {
      return unwrapAsync(clientAgentsRun(this, request, options));
    }
  };

  // node_modules/@gleanwork/api-client/dist/esm/funcs/clientAnnouncementsCreate.js
  function clientAnnouncementsCreate(client, request, options) {
    return new APIPromise($do8(client, request, options));
  }
  async function $do8(client, request, options) {
    const parsed = safeParse(request, (value) => CreateAnnouncementRequest$outboundSchema.parse(value), "Input validation failed");
    if (!parsed.ok) {
      return [parsed, { status: "invalid" }];
    }
    const payload = parsed.value;
    const body = encodeJSON("body", payload, { explode: true });
    const path = pathToFunc("/rest/api/v1/createannouncement")();
    const headers = new Headers(compactMap({
      "Content-Type": "application/json",
      Accept: "application/json"
    }));
    const secConfig = await extractSecurity(client._options.apiToken);
    const securityInput = secConfig == null ? {} : { apiToken: secConfig };
    const requestSecurity = resolveGlobalSecurity(securityInput);
    const context = {
      options: client._options,
      baseURL: options?.serverURL ?? client._baseURL ?? "",
      operationID: "createannouncement",
      oAuth2Scopes: [],
      resolvedSecurity: requestSecurity,
      securitySource: client._options.apiToken,
      retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
      retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
    };
    const requestRes = client._createRequest(context, {
      security: requestSecurity,
      method: "POST",
      baseURL: options?.serverURL,
      path,
      headers,
      body,
      userAgent: client._options.userAgent,
      timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
    }, options);
    if (!requestRes.ok) {
      return [requestRes, { status: "invalid" }];
    }
    const req = requestRes.value;
    const doResult = await client._do(req, {
      context,
      errorCodes: ["400", "401", "429", "4XX", "5XX"],
      retryConfig: context.retryConfig,
      retryCodes: context.retryCodes
    });
    if (!doResult.ok) {
      return [doResult, { status: "request-error", request: req }];
    }
    const response = doResult.value;
    const [result] = await match(json(200, Announcement$inboundSchema), fail([400, 401, 429, "4XX"]), fail("5XX"))(response, req);
    if (!result.ok) {
      return [result, { status: "complete", request: req, response }];
    }
    return [result, { status: "complete", request: req, response }];
  }

  // node_modules/@gleanwork/api-client/dist/esm/funcs/clientAnnouncementsDelete.js
  function clientAnnouncementsDelete(client, request, options) {
    return new APIPromise($do9(client, request, options));
  }
  async function $do9(client, request, options) {
    const parsed = safeParse(request, (value) => DeleteAnnouncementRequest$outboundSchema.parse(value), "Input validation failed");
    if (!parsed.ok) {
      return [parsed, { status: "invalid" }];
    }
    const payload = parsed.value;
    const body = encodeJSON("body", payload, { explode: true });
    const path = pathToFunc("/rest/api/v1/deleteannouncement")();
    const headers = new Headers(compactMap({
      "Content-Type": "application/json",
      Accept: "*/*"
    }));
    const secConfig = await extractSecurity(client._options.apiToken);
    const securityInput = secConfig == null ? {} : { apiToken: secConfig };
    const requestSecurity = resolveGlobalSecurity(securityInput);
    const context = {
      options: client._options,
      baseURL: options?.serverURL ?? client._baseURL ?? "",
      operationID: "deleteannouncement",
      oAuth2Scopes: [],
      resolvedSecurity: requestSecurity,
      securitySource: client._options.apiToken,
      retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
      retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
    };
    const requestRes = client._createRequest(context, {
      security: requestSecurity,
      method: "POST",
      baseURL: options?.serverURL,
      path,
      headers,
      body,
      userAgent: client._options.userAgent,
      timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
    }, options);
    if (!requestRes.ok) {
      return [requestRes, { status: "invalid" }];
    }
    const req = requestRes.value;
    const doResult = await client._do(req, {
      context,
      errorCodes: ["400", "401", "429", "4XX", "5XX"],
      retryConfig: context.retryConfig,
      retryCodes: context.retryCodes
    });
    if (!doResult.ok) {
      return [doResult, { status: "request-error", request: req }];
    }
    const response = doResult.value;
    const [result] = await match(nil(200, voidType()), fail([400, 401, 429, "4XX"]), fail("5XX"))(response, req);
    if (!result.ok) {
      return [result, { status: "complete", request: req, response }];
    }
    return [result, { status: "complete", request: req, response }];
  }

  // node_modules/@gleanwork/api-client/dist/esm/funcs/clientAnnouncementsUpdate.js
  function clientAnnouncementsUpdate(client, request, options) {
    return new APIPromise($do10(client, request, options));
  }
  async function $do10(client, request, options) {
    const parsed = safeParse(request, (value) => UpdateAnnouncementRequest$outboundSchema.parse(value), "Input validation failed");
    if (!parsed.ok) {
      return [parsed, { status: "invalid" }];
    }
    const payload = parsed.value;
    const body = encodeJSON("body", payload, { explode: true });
    const path = pathToFunc("/rest/api/v1/updateannouncement")();
    const headers = new Headers(compactMap({
      "Content-Type": "application/json",
      Accept: "application/json"
    }));
    const secConfig = await extractSecurity(client._options.apiToken);
    const securityInput = secConfig == null ? {} : { apiToken: secConfig };
    const requestSecurity = resolveGlobalSecurity(securityInput);
    const context = {
      options: client._options,
      baseURL: options?.serverURL ?? client._baseURL ?? "",
      operationID: "updateannouncement",
      oAuth2Scopes: [],
      resolvedSecurity: requestSecurity,
      securitySource: client._options.apiToken,
      retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
      retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
    };
    const requestRes = client._createRequest(context, {
      security: requestSecurity,
      method: "POST",
      baseURL: options?.serverURL,
      path,
      headers,
      body,
      userAgent: client._options.userAgent,
      timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
    }, options);
    if (!requestRes.ok) {
      return [requestRes, { status: "invalid" }];
    }
    const req = requestRes.value;
    const doResult = await client._do(req, {
      context,
      errorCodes: ["400", "401", "429", "4XX", "5XX"],
      retryConfig: context.retryConfig,
      retryCodes: context.retryCodes
    });
    if (!doResult.ok) {
      return [doResult, { status: "request-error", request: req }];
    }
    const response = doResult.value;
    const [result] = await match(json(200, Announcement$inboundSchema), fail([400, 401, 429, "4XX"]), fail("5XX"))(response, req);
    if (!result.ok) {
      return [result, { status: "complete", request: req, response }];
    }
    return [result, { status: "complete", request: req, response }];
  }

  // node_modules/@gleanwork/api-client/dist/esm/sdk/announcements.js
  var Announcements = class extends ClientSDK {
    /**
     * Create Announcement
     *
     * @remarks
     * Create a textual announcement visible to some set of users based on department and location.
     */
    async create(request, options) {
      return unwrapAsync(clientAnnouncementsCreate(this, request, options));
    }
    /**
     * Delete Announcement
     *
     * @remarks
     * Delete an existing user-generated announcement.
     */
    async delete(request, options) {
      return unwrapAsync(clientAnnouncementsDelete(this, request, options));
    }
    /**
     * Update Announcement
     *
     * @remarks
     * Update a textual announcement visible to some set of users based on department and location.
     */
    async update(request, options) {
      return unwrapAsync(clientAnnouncementsUpdate(this, request, options));
    }
  };

  // node_modules/@gleanwork/api-client/dist/esm/funcs/clientAnswersCreate.js
  function clientAnswersCreate(client, request, options) {
    return new APIPromise($do11(client, request, options));
  }
  async function $do11(client, request, options) {
    const parsed = safeParse(request, (value) => CreateAnswerRequest$outboundSchema.parse(value), "Input validation failed");
    if (!parsed.ok) {
      return [parsed, { status: "invalid" }];
    }
    const payload = parsed.value;
    const body = encodeJSON("body", payload, { explode: true });
    const path = pathToFunc("/rest/api/v1/createanswer")();
    const headers = new Headers(compactMap({
      "Content-Type": "application/json",
      Accept: "application/json"
    }));
    const secConfig = await extractSecurity(client._options.apiToken);
    const securityInput = secConfig == null ? {} : { apiToken: secConfig };
    const requestSecurity = resolveGlobalSecurity(securityInput);
    const context = {
      options: client._options,
      baseURL: options?.serverURL ?? client._baseURL ?? "",
      operationID: "createanswer",
      oAuth2Scopes: [],
      resolvedSecurity: requestSecurity,
      securitySource: client._options.apiToken,
      retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
      retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
    };
    const requestRes = client._createRequest(context, {
      security: requestSecurity,
      method: "POST",
      baseURL: options?.serverURL,
      path,
      headers,
      body,
      userAgent: client._options.userAgent,
      timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
    }, options);
    if (!requestRes.ok) {
      return [requestRes, { status: "invalid" }];
    }
    const req = requestRes.value;
    const doResult = await client._do(req, {
      context,
      errorCodes: ["400", "401", "429", "4XX", "5XX"],
      retryConfig: context.retryConfig,
      retryCodes: context.retryCodes
    });
    if (!doResult.ok) {
      return [doResult, { status: "request-error", request: req }];
    }
    const response = doResult.value;
    const [result] = await match(json(200, Answer$inboundSchema), fail([400, 401, 429, "4XX"]), fail("5XX"))(response, req);
    if (!result.ok) {
      return [result, { status: "complete", request: req, response }];
    }
    return [result, { status: "complete", request: req, response }];
  }

  // node_modules/@gleanwork/api-client/dist/esm/funcs/clientAnswersDelete.js
  function clientAnswersDelete(client, request, options) {
    return new APIPromise($do12(client, request, options));
  }
  async function $do12(client, request, options) {
    const parsed = safeParse(request, (value) => DeleteAnswerRequest$outboundSchema.parse(value), "Input validation failed");
    if (!parsed.ok) {
      return [parsed, { status: "invalid" }];
    }
    const payload = parsed.value;
    const body = encodeJSON("body", payload, { explode: true });
    const path = pathToFunc("/rest/api/v1/deleteanswer")();
    const headers = new Headers(compactMap({
      "Content-Type": "application/json",
      Accept: "*/*"
    }));
    const secConfig = await extractSecurity(client._options.apiToken);
    const securityInput = secConfig == null ? {} : { apiToken: secConfig };
    const requestSecurity = resolveGlobalSecurity(securityInput);
    const context = {
      options: client._options,
      baseURL: options?.serverURL ?? client._baseURL ?? "",
      operationID: "deleteanswer",
      oAuth2Scopes: [],
      resolvedSecurity: requestSecurity,
      securitySource: client._options.apiToken,
      retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
      retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
    };
    const requestRes = client._createRequest(context, {
      security: requestSecurity,
      method: "POST",
      baseURL: options?.serverURL,
      path,
      headers,
      body,
      userAgent: client._options.userAgent,
      timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
    }, options);
    if (!requestRes.ok) {
      return [requestRes, { status: "invalid" }];
    }
    const req = requestRes.value;
    const doResult = await client._do(req, {
      context,
      errorCodes: ["400", "401", "429", "4XX", "5XX"],
      retryConfig: context.retryConfig,
      retryCodes: context.retryCodes
    });
    if (!doResult.ok) {
      return [doResult, { status: "request-error", request: req }];
    }
    const response = doResult.value;
    const [result] = await match(nil(200, voidType()), fail([400, 401, 429, "4XX"]), fail("5XX"))(response, req);
    if (!result.ok) {
      return [result, { status: "complete", request: req, response }];
    }
    return [result, { status: "complete", request: req, response }];
  }

  // node_modules/@gleanwork/api-client/dist/esm/funcs/clientAnswersList.js
  function clientAnswersList(client, request, options) {
    return new APIPromise($do13(client, request, options));
  }
  async function $do13(client, request, options) {
    const parsed = safeParse(request, (value) => ListAnswersRequest$outboundSchema.parse(value), "Input validation failed");
    if (!parsed.ok) {
      return [parsed, { status: "invalid" }];
    }
    const payload = parsed.value;
    const body = encodeJSON("body", payload, { explode: true });
    const path = pathToFunc("/rest/api/v1/listanswers")();
    const headers = new Headers(compactMap({
      "Content-Type": "application/json",
      Accept: "application/json"
    }));
    const secConfig = await extractSecurity(client._options.apiToken);
    const securityInput = secConfig == null ? {} : { apiToken: secConfig };
    const requestSecurity = resolveGlobalSecurity(securityInput);
    const context = {
      options: client._options,
      baseURL: options?.serverURL ?? client._baseURL ?? "",
      operationID: "listanswers",
      oAuth2Scopes: [],
      resolvedSecurity: requestSecurity,
      securitySource: client._options.apiToken,
      retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
      retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
    };
    const requestRes = client._createRequest(context, {
      security: requestSecurity,
      method: "POST",
      baseURL: options?.serverURL,
      path,
      headers,
      body,
      userAgent: client._options.userAgent,
      timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
    }, options);
    if (!requestRes.ok) {
      return [requestRes, { status: "invalid" }];
    }
    const req = requestRes.value;
    const doResult = await client._do(req, {
      context,
      errorCodes: ["400", "401", "429", "4XX", "5XX"],
      retryConfig: context.retryConfig,
      retryCodes: context.retryCodes
    });
    if (!doResult.ok) {
      return [doResult, { status: "request-error", request: req }];
    }
    const response = doResult.value;
    const [result] = await match(json(200, ListAnswersResponse$inboundSchema), fail([400, 401, 429, "4XX"]), fail("5XX"))(response, req);
    if (!result.ok) {
      return [result, { status: "complete", request: req, response }];
    }
    return [result, { status: "complete", request: req, response }];
  }

  // node_modules/@gleanwork/api-client/dist/esm/funcs/clientAnswersRetrieve.js
  function clientAnswersRetrieve(client, request, options) {
    return new APIPromise($do14(client, request, options));
  }
  async function $do14(client, request, options) {
    const parsed = safeParse(request, (value) => GetAnswerRequest$outboundSchema.parse(value), "Input validation failed");
    if (!parsed.ok) {
      return [parsed, { status: "invalid" }];
    }
    const payload = parsed.value;
    const body = encodeJSON("body", payload, { explode: true });
    const path = pathToFunc("/rest/api/v1/getanswer")();
    const headers = new Headers(compactMap({
      "Content-Type": "application/json",
      Accept: "application/json"
    }));
    const secConfig = await extractSecurity(client._options.apiToken);
    const securityInput = secConfig == null ? {} : { apiToken: secConfig };
    const requestSecurity = resolveGlobalSecurity(securityInput);
    const context = {
      options: client._options,
      baseURL: options?.serverURL ?? client._baseURL ?? "",
      operationID: "getanswer",
      oAuth2Scopes: [],
      resolvedSecurity: requestSecurity,
      securitySource: client._options.apiToken,
      retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
      retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
    };
    const requestRes = client._createRequest(context, {
      security: requestSecurity,
      method: "POST",
      baseURL: options?.serverURL,
      path,
      headers,
      body,
      userAgent: client._options.userAgent,
      timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
    }, options);
    if (!requestRes.ok) {
      return [requestRes, { status: "invalid" }];
    }
    const req = requestRes.value;
    const doResult = await client._do(req, {
      context,
      errorCodes: ["400", "401", "429", "4XX", "5XX"],
      retryConfig: context.retryConfig,
      retryCodes: context.retryCodes
    });
    if (!doResult.ok) {
      return [doResult, { status: "request-error", request: req }];
    }
    const response = doResult.value;
    const [result] = await match(json(200, GetAnswerResponse$inboundSchema), fail([400, 401, 429, "4XX"]), fail("5XX"))(response, req);
    if (!result.ok) {
      return [result, { status: "complete", request: req, response }];
    }
    return [result, { status: "complete", request: req, response }];
  }

  // node_modules/@gleanwork/api-client/dist/esm/funcs/clientAnswersUpdate.js
  function clientAnswersUpdate(client, request, options) {
    return new APIPromise($do15(client, request, options));
  }
  async function $do15(client, request, options) {
    const parsed = safeParse(request, (value) => EditAnswerRequest$outboundSchema.parse(value), "Input validation failed");
    if (!parsed.ok) {
      return [parsed, { status: "invalid" }];
    }
    const payload = parsed.value;
    const body = encodeJSON("body", payload, { explode: true });
    const path = pathToFunc("/rest/api/v1/editanswer")();
    const headers = new Headers(compactMap({
      "Content-Type": "application/json",
      Accept: "application/json"
    }));
    const secConfig = await extractSecurity(client._options.apiToken);
    const securityInput = secConfig == null ? {} : { apiToken: secConfig };
    const requestSecurity = resolveGlobalSecurity(securityInput);
    const context = {
      options: client._options,
      baseURL: options?.serverURL ?? client._baseURL ?? "",
      operationID: "editanswer",
      oAuth2Scopes: [],
      resolvedSecurity: requestSecurity,
      securitySource: client._options.apiToken,
      retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
      retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
    };
    const requestRes = client._createRequest(context, {
      security: requestSecurity,
      method: "POST",
      baseURL: options?.serverURL,
      path,
      headers,
      body,
      userAgent: client._options.userAgent,
      timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
    }, options);
    if (!requestRes.ok) {
      return [requestRes, { status: "invalid" }];
    }
    const req = requestRes.value;
    const doResult = await client._do(req, {
      context,
      errorCodes: ["400", "401", "429", "4XX", "5XX"],
      retryConfig: context.retryConfig,
      retryCodes: context.retryCodes
    });
    if (!doResult.ok) {
      return [doResult, { status: "request-error", request: req }];
    }
    const response = doResult.value;
    const [result] = await match(json(200, Answer$inboundSchema), fail([400, 401, 429, "4XX"]), fail("5XX"))(response, req);
    if (!result.ok) {
      return [result, { status: "complete", request: req, response }];
    }
    return [result, { status: "complete", request: req, response }];
  }

  // node_modules/@gleanwork/api-client/dist/esm/sdk/answers.js
  var Answers = class extends ClientSDK {
    /**
     * Create Answer
     *
     * @remarks
     * Create a user-generated Answer that contains a question and answer.
     */
    async create(request, options) {
      return unwrapAsync(clientAnswersCreate(this, request, options));
    }
    /**
     * Delete Answer
     *
     * @remarks
     * Delete an existing user-generated Answer.
     */
    async delete(request, options) {
      return unwrapAsync(clientAnswersDelete(this, request, options));
    }
    /**
     * Update Answer
     *
     * @remarks
     * Update an existing user-generated Answer.
     */
    async update(request, options) {
      return unwrapAsync(clientAnswersUpdate(this, request, options));
    }
    /**
     * Read Answer
     *
     * @remarks
     * Read the details of a particular Answer given its ID.
     */
    async retrieve(request, options) {
      return unwrapAsync(clientAnswersRetrieve(this, request, options));
    }
    /**
     * List Answers
     *
     * @remarks
     * List Answers created by the current user.
     */
    async list(request, options) {
      return unwrapAsync(clientAnswersList(this, request, options));
    }
  };

  // node_modules/@gleanwork/api-client/dist/esm/funcs/clientChatCreate.js
  function clientChatCreate(client, chatRequest, timezoneOffset, options) {
    return new APIPromise($do16(client, chatRequest, timezoneOffset, options));
  }
  async function $do16(client, chatRequest, timezoneOffset, options) {
    const input = {
      chatRequest,
      timezoneOffset
    };
    const parsed = safeParse(input, (value) => ChatRequest$outboundSchema2.parse(value), "Input validation failed");
    if (!parsed.ok) {
      return [parsed, { status: "invalid" }];
    }
    const payload = parsed.value;
    const body = encodeJSON("body", payload.ChatRequest, { explode: true });
    const path = pathToFunc("/rest/api/v1/chat")();
    const query = encodeFormQuery({
      "timezoneOffset": payload.timezoneOffset
    });
    const headers = new Headers(compactMap({
      "Content-Type": "application/json",
      Accept: "application/json"
    }));
    const secConfig = await extractSecurity(client._options.apiToken);
    const securityInput = secConfig == null ? {} : { apiToken: secConfig };
    const requestSecurity = resolveGlobalSecurity(securityInput);
    const context = {
      options: client._options,
      baseURL: options?.serverURL ?? client._baseURL ?? "",
      operationID: "chat",
      oAuth2Scopes: [],
      resolvedSecurity: requestSecurity,
      securitySource: client._options.apiToken,
      retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
      retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
    };
    const requestRes = client._createRequest(context, {
      security: requestSecurity,
      method: "POST",
      baseURL: options?.serverURL,
      path,
      headers,
      query,
      body,
      userAgent: client._options.userAgent,
      timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
    }, options);
    if (!requestRes.ok) {
      return [requestRes, { status: "invalid" }];
    }
    const req = requestRes.value;
    const doResult = await client._do(req, {
      context,
      errorCodes: ["400", "401", "408", "429", "4XX", "5XX"],
      retryConfig: context.retryConfig,
      retryCodes: context.retryCodes
    });
    if (!doResult.ok) {
      return [doResult, { status: "request-error", request: req }];
    }
    const response = doResult.value;
    const [result] = await match(json(200, ChatResponse$inboundSchema), fail([400, 401, 408, 429, "4XX"]), fail("5XX"))(response, req);
    if (!result.ok) {
      return [result, { status: "complete", request: req, response }];
    }
    return [result, { status: "complete", request: req, response }];
  }

  // node_modules/@gleanwork/api-client/dist/esm/funcs/clientChatCreateStream.js
  function clientChatCreateStream(client, chatRequest, timezoneOffset, options) {
    return new APIPromise($do17(client, chatRequest, timezoneOffset, options));
  }
  async function $do17(client, chatRequest, timezoneOffset, options) {
    const input = {
      chatRequest,
      timezoneOffset
    };
    const parsed = safeParse(input, (value) => ChatStreamRequest$outboundSchema.parse(value), "Input validation failed");
    if (!parsed.ok) {
      return [parsed, { status: "invalid" }];
    }
    const payload = parsed.value;
    const body = encodeJSON("body", payload.ChatRequest, { explode: true });
    const path = pathToFunc("/rest/api/v1/chat#stream")();
    const query = encodeFormQuery({
      "timezoneOffset": payload.timezoneOffset
    });
    const headers = new Headers(compactMap({
      "Content-Type": "application/json",
      Accept: "text/plain"
    }));
    const secConfig = await extractSecurity(client._options.apiToken);
    const securityInput = secConfig == null ? {} : { apiToken: secConfig };
    const requestSecurity = resolveGlobalSecurity(securityInput);
    const context = {
      options: client._options,
      baseURL: options?.serverURL ?? client._baseURL ?? "",
      operationID: "chatStream",
      oAuth2Scopes: [],
      resolvedSecurity: requestSecurity,
      securitySource: client._options.apiToken,
      retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
      retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
    };
    const requestRes = client._createRequest(context, {
      security: requestSecurity,
      method: "POST",
      baseURL: options?.serverURL,
      path,
      headers,
      query,
      body,
      userAgent: client._options.userAgent,
      timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
    }, options);
    if (!requestRes.ok) {
      return [requestRes, { status: "invalid" }];
    }
    const req = requestRes.value;
    const doResult = await client._do(req, {
      context,
      errorCodes: ["400", "401", "408", "429", "4XX", "5XX"],
      retryConfig: context.retryConfig,
      retryCodes: context.retryCodes
    });
    if (!doResult.ok) {
      return [doResult, { status: "request-error", request: req }];
    }
    const response = doResult.value;
    const [result] = await match(text(200, stringType()), fail([400, 401, 408, 429, "4XX"]), fail("5XX"))(response, req);
    if (!result.ok) {
      return [result, { status: "complete", request: req, response }];
    }
    return [result, { status: "complete", request: req, response }];
  }

  // node_modules/@gleanwork/api-client/dist/esm/funcs/clientChatDelete.js
  function clientChatDelete(client, deleteChatsRequest, timezoneOffset, options) {
    return new APIPromise($do18(client, deleteChatsRequest, timezoneOffset, options));
  }
  async function $do18(client, deleteChatsRequest, timezoneOffset, options) {
    const input = {
      deleteChatsRequest,
      timezoneOffset
    };
    const parsed = safeParse(input, (value) => DeletechatsRequest$outboundSchema.parse(value), "Input validation failed");
    if (!parsed.ok) {
      return [parsed, { status: "invalid" }];
    }
    const payload = parsed.value;
    const body = encodeJSON("body", payload.DeleteChatsRequest, {
      explode: true
    });
    const path = pathToFunc("/rest/api/v1/deletechats")();
    const query = encodeFormQuery({
      "timezoneOffset": payload.timezoneOffset
    });
    const headers = new Headers(compactMap({
      "Content-Type": "application/json",
      Accept: "*/*"
    }));
    const secConfig = await extractSecurity(client._options.apiToken);
    const securityInput = secConfig == null ? {} : { apiToken: secConfig };
    const requestSecurity = resolveGlobalSecurity(securityInput);
    const context = {
      options: client._options,
      baseURL: options?.serverURL ?? client._baseURL ?? "",
      operationID: "deletechats",
      oAuth2Scopes: [],
      resolvedSecurity: requestSecurity,
      securitySource: client._options.apiToken,
      retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
      retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
    };
    const requestRes = client._createRequest(context, {
      security: requestSecurity,
      method: "POST",
      baseURL: options?.serverURL,
      path,
      headers,
      query,
      body,
      userAgent: client._options.userAgent,
      timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
    }, options);
    if (!requestRes.ok) {
      return [requestRes, { status: "invalid" }];
    }
    const req = requestRes.value;
    const doResult = await client._do(req, {
      context,
      errorCodes: ["400", "401", "403", "429", "4XX", "5XX"],
      retryConfig: context.retryConfig,
      retryCodes: context.retryCodes
    });
    if (!doResult.ok) {
      return [doResult, { status: "request-error", request: req }];
    }
    const response = doResult.value;
    const [result] = await match(nil(200, voidType()), fail([400, 401, 403, 429, "4XX"]), fail("5XX"))(response, req);
    if (!result.ok) {
      return [result, { status: "complete", request: req, response }];
    }
    return [result, { status: "complete", request: req, response }];
  }

  // node_modules/@gleanwork/api-client/dist/esm/funcs/clientChatDeleteAll.js
  function clientChatDeleteAll(client, timezoneOffset, options) {
    return new APIPromise($do19(client, timezoneOffset, options));
  }
  async function $do19(client, timezoneOffset, options) {
    const input = {
      timezoneOffset
    };
    const parsed = safeParse(input, (value) => DeleteallchatsRequest$outboundSchema.parse(value), "Input validation failed");
    if (!parsed.ok) {
      return [parsed, { status: "invalid" }];
    }
    const payload = parsed.value;
    const body = null;
    const path = pathToFunc("/rest/api/v1/deleteallchats")();
    const query = encodeFormQuery({
      "timezoneOffset": payload.timezoneOffset
    });
    const headers = new Headers(compactMap({
      Accept: "*/*"
    }));
    const secConfig = await extractSecurity(client._options.apiToken);
    const securityInput = secConfig == null ? {} : { apiToken: secConfig };
    const requestSecurity = resolveGlobalSecurity(securityInput);
    const context = {
      options: client._options,
      baseURL: options?.serverURL ?? client._baseURL ?? "",
      operationID: "deleteallchats",
      oAuth2Scopes: [],
      resolvedSecurity: requestSecurity,
      securitySource: client._options.apiToken,
      retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
      retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
    };
    const requestRes = client._createRequest(context, {
      security: requestSecurity,
      method: "POST",
      baseURL: options?.serverURL,
      path,
      headers,
      query,
      body,
      userAgent: client._options.userAgent,
      timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
    }, options);
    if (!requestRes.ok) {
      return [requestRes, { status: "invalid" }];
    }
    const req = requestRes.value;
    const doResult = await client._do(req, {
      context,
      errorCodes: ["400", "401", "403", "4XX", "5XX"],
      retryConfig: context.retryConfig,
      retryCodes: context.retryCodes
    });
    if (!doResult.ok) {
      return [doResult, { status: "request-error", request: req }];
    }
    const response = doResult.value;
    const [result] = await match(nil(200, voidType()), fail([400, 401, 403, "4XX"]), fail("5XX"))(response, req);
    if (!result.ok) {
      return [result, { status: "complete", request: req, response }];
    }
    return [result, { status: "complete", request: req, response }];
  }

  // node_modules/@gleanwork/api-client/dist/esm/funcs/clientChatDeleteFiles.js
  function clientChatDeleteFiles(client, deleteChatFilesRequest, timezoneOffset, options) {
    return new APIPromise($do20(client, deleteChatFilesRequest, timezoneOffset, options));
  }
  async function $do20(client, deleteChatFilesRequest, timezoneOffset, options) {
    const input = {
      deleteChatFilesRequest,
      timezoneOffset
    };
    const parsed = safeParse(input, (value) => DeletechatfilesRequest$outboundSchema.parse(value), "Input validation failed");
    if (!parsed.ok) {
      return [parsed, { status: "invalid" }];
    }
    const payload = parsed.value;
    const body = encodeJSON("body", payload.DeleteChatFilesRequest, {
      explode: true
    });
    const path = pathToFunc("/rest/api/v1/deletechatfiles")();
    const query = encodeFormQuery({
      "timezoneOffset": payload.timezoneOffset
    });
    const headers = new Headers(compactMap({
      "Content-Type": "application/json",
      Accept: "*/*"
    }));
    const secConfig = await extractSecurity(client._options.apiToken);
    const securityInput = secConfig == null ? {} : { apiToken: secConfig };
    const requestSecurity = resolveGlobalSecurity(securityInput);
    const context = {
      options: client._options,
      baseURL: options?.serverURL ?? client._baseURL ?? "",
      operationID: "deletechatfiles",
      oAuth2Scopes: [],
      resolvedSecurity: requestSecurity,
      securitySource: client._options.apiToken,
      retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
      retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
    };
    const requestRes = client._createRequest(context, {
      security: requestSecurity,
      method: "POST",
      baseURL: options?.serverURL,
      path,
      headers,
      query,
      body,
      userAgent: client._options.userAgent,
      timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
    }, options);
    if (!requestRes.ok) {
      return [requestRes, { status: "invalid" }];
    }
    const req = requestRes.value;
    const doResult = await client._do(req, {
      context,
      errorCodes: ["400", "401", "403", "429", "4XX", "5XX"],
      retryConfig: context.retryConfig,
      retryCodes: context.retryCodes
    });
    if (!doResult.ok) {
      return [doResult, { status: "request-error", request: req }];
    }
    const response = doResult.value;
    const [result] = await match(nil(200, voidType()), fail([400, 401, 403, 429, "4XX"]), fail("5XX"))(response, req);
    if (!result.ok) {
      return [result, { status: "complete", request: req, response }];
    }
    return [result, { status: "complete", request: req, response }];
  }

  // node_modules/@gleanwork/api-client/dist/esm/funcs/clientChatList.js
  function clientChatList(client, timezoneOffset, options) {
    return new APIPromise($do21(client, timezoneOffset, options));
  }
  async function $do21(client, timezoneOffset, options) {
    const input = {
      timezoneOffset
    };
    const parsed = safeParse(input, (value) => ListchatsRequest$outboundSchema.parse(value), "Input validation failed");
    if (!parsed.ok) {
      return [parsed, { status: "invalid" }];
    }
    const payload = parsed.value;
    const body = null;
    const path = pathToFunc("/rest/api/v1/listchats")();
    const query = encodeFormQuery({
      "timezoneOffset": payload.timezoneOffset
    });
    const headers = new Headers(compactMap({
      Accept: "application/json"
    }));
    const secConfig = await extractSecurity(client._options.apiToken);
    const securityInput = secConfig == null ? {} : { apiToken: secConfig };
    const requestSecurity = resolveGlobalSecurity(securityInput);
    const context = {
      options: client._options,
      baseURL: options?.serverURL ?? client._baseURL ?? "",
      operationID: "listchats",
      oAuth2Scopes: [],
      resolvedSecurity: requestSecurity,
      securitySource: client._options.apiToken,
      retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
      retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
    };
    const requestRes = client._createRequest(context, {
      security: requestSecurity,
      method: "POST",
      baseURL: options?.serverURL,
      path,
      headers,
      query,
      body,
      userAgent: client._options.userAgent,
      timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
    }, options);
    if (!requestRes.ok) {
      return [requestRes, { status: "invalid" }];
    }
    const req = requestRes.value;
    const doResult = await client._do(req, {
      context,
      errorCodes: ["401", "403", "429", "4XX", "5XX"],
      retryConfig: context.retryConfig,
      retryCodes: context.retryCodes
    });
    if (!doResult.ok) {
      return [doResult, { status: "request-error", request: req }];
    }
    const response = doResult.value;
    const [result] = await match(json(200, ListChatsResponse$inboundSchema), fail([401, 403, 429, "4XX"]), fail("5XX"))(response, req);
    if (!result.ok) {
      return [result, { status: "complete", request: req, response }];
    }
    return [result, { status: "complete", request: req, response }];
  }

  // node_modules/@gleanwork/api-client/dist/esm/funcs/clientChatRetrieve.js
  function clientChatRetrieve(client, getChatRequest, timezoneOffset, options) {
    return new APIPromise($do22(client, getChatRequest, timezoneOffset, options));
  }
  async function $do22(client, getChatRequest, timezoneOffset, options) {
    const input = {
      getChatRequest,
      timezoneOffset
    };
    const parsed = safeParse(input, (value) => GetchatRequest$outboundSchema.parse(value), "Input validation failed");
    if (!parsed.ok) {
      return [parsed, { status: "invalid" }];
    }
    const payload = parsed.value;
    const body = encodeJSON("body", payload.GetChatRequest, { explode: true });
    const path = pathToFunc("/rest/api/v1/getchat")();
    const query = encodeFormQuery({
      "timezoneOffset": payload.timezoneOffset
    });
    const headers = new Headers(compactMap({
      "Content-Type": "application/json",
      Accept: "application/json"
    }));
    const secConfig = await extractSecurity(client._options.apiToken);
    const securityInput = secConfig == null ? {} : { apiToken: secConfig };
    const requestSecurity = resolveGlobalSecurity(securityInput);
    const context = {
      options: client._options,
      baseURL: options?.serverURL ?? client._baseURL ?? "",
      operationID: "getchat",
      oAuth2Scopes: [],
      resolvedSecurity: requestSecurity,
      securitySource: client._options.apiToken,
      retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
      retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
    };
    const requestRes = client._createRequest(context, {
      security: requestSecurity,
      method: "POST",
      baseURL: options?.serverURL,
      path,
      headers,
      query,
      body,
      userAgent: client._options.userAgent,
      timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
    }, options);
    if (!requestRes.ok) {
      return [requestRes, { status: "invalid" }];
    }
    const req = requestRes.value;
    const doResult = await client._do(req, {
      context,
      errorCodes: ["400", "401", "403", "429", "4XX", "5XX"],
      retryConfig: context.retryConfig,
      retryCodes: context.retryCodes
    });
    if (!doResult.ok) {
      return [doResult, { status: "request-error", request: req }];
    }
    const response = doResult.value;
    const [result] = await match(json(200, GetChatResponse$inboundSchema), fail([400, 401, 403, 429, "4XX"]), fail("5XX"))(response, req);
    if (!result.ok) {
      return [result, { status: "complete", request: req, response }];
    }
    return [result, { status: "complete", request: req, response }];
  }

  // node_modules/@gleanwork/api-client/dist/esm/funcs/clientChatRetrieveApplication.js
  function clientChatRetrieveApplication(client, getChatApplicationRequest, timezoneOffset, options) {
    return new APIPromise($do23(client, getChatApplicationRequest, timezoneOffset, options));
  }
  async function $do23(client, getChatApplicationRequest, timezoneOffset, options) {
    const input = {
      getChatApplicationRequest,
      timezoneOffset
    };
    const parsed = safeParse(input, (value) => GetchatapplicationRequest$outboundSchema.parse(value), "Input validation failed");
    if (!parsed.ok) {
      return [parsed, { status: "invalid" }];
    }
    const payload = parsed.value;
    const body = encodeJSON("body", payload.GetChatApplicationRequest, {
      explode: true
    });
    const path = pathToFunc("/rest/api/v1/getchatapplication")();
    const query = encodeFormQuery({
      "timezoneOffset": payload.timezoneOffset
    });
    const headers = new Headers(compactMap({
      "Content-Type": "application/json",
      Accept: "application/json"
    }));
    const secConfig = await extractSecurity(client._options.apiToken);
    const securityInput = secConfig == null ? {} : { apiToken: secConfig };
    const requestSecurity = resolveGlobalSecurity(securityInput);
    const context = {
      options: client._options,
      baseURL: options?.serverURL ?? client._baseURL ?? "",
      operationID: "getchatapplication",
      oAuth2Scopes: [],
      resolvedSecurity: requestSecurity,
      securitySource: client._options.apiToken,
      retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
      retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
    };
    const requestRes = client._createRequest(context, {
      security: requestSecurity,
      method: "POST",
      baseURL: options?.serverURL,
      path,
      headers,
      query,
      body,
      userAgent: client._options.userAgent,
      timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
    }, options);
    if (!requestRes.ok) {
      return [requestRes, { status: "invalid" }];
    }
    const req = requestRes.value;
    const doResult = await client._do(req, {
      context,
      errorCodes: ["400", "401", "403", "4XX", "5XX"],
      retryConfig: context.retryConfig,
      retryCodes: context.retryCodes
    });
    if (!doResult.ok) {
      return [doResult, { status: "request-error", request: req }];
    }
    const response = doResult.value;
    const [result] = await match(json(200, GetChatApplicationResponse$inboundSchema), fail([400, 401, 403, "4XX"]), fail("5XX"))(response, req);
    if (!result.ok) {
      return [result, { status: "complete", request: req, response }];
    }
    return [result, { status: "complete", request: req, response }];
  }

  // node_modules/@gleanwork/api-client/dist/esm/funcs/clientChatRetrieveFiles.js
  function clientChatRetrieveFiles(client, getChatFilesRequest, timezoneOffset, options) {
    return new APIPromise($do24(client, getChatFilesRequest, timezoneOffset, options));
  }
  async function $do24(client, getChatFilesRequest, timezoneOffset, options) {
    const input = {
      getChatFilesRequest,
      timezoneOffset
    };
    const parsed = safeParse(input, (value) => GetchatfilesRequest$outboundSchema.parse(value), "Input validation failed");
    if (!parsed.ok) {
      return [parsed, { status: "invalid" }];
    }
    const payload = parsed.value;
    const body = encodeJSON("body", payload.GetChatFilesRequest, {
      explode: true
    });
    const path = pathToFunc("/rest/api/v1/getchatfiles")();
    const query = encodeFormQuery({
      "timezoneOffset": payload.timezoneOffset
    });
    const headers = new Headers(compactMap({
      "Content-Type": "application/json",
      Accept: "application/json"
    }));
    const secConfig = await extractSecurity(client._options.apiToken);
    const securityInput = secConfig == null ? {} : { apiToken: secConfig };
    const requestSecurity = resolveGlobalSecurity(securityInput);
    const context = {
      options: client._options,
      baseURL: options?.serverURL ?? client._baseURL ?? "",
      operationID: "getchatfiles",
      oAuth2Scopes: [],
      resolvedSecurity: requestSecurity,
      securitySource: client._options.apiToken,
      retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
      retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
    };
    const requestRes = client._createRequest(context, {
      security: requestSecurity,
      method: "POST",
      baseURL: options?.serverURL,
      path,
      headers,
      query,
      body,
      userAgent: client._options.userAgent,
      timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
    }, options);
    if (!requestRes.ok) {
      return [requestRes, { status: "invalid" }];
    }
    const req = requestRes.value;
    const doResult = await client._do(req, {
      context,
      errorCodes: ["400", "401", "403", "429", "4XX", "5XX"],
      retryConfig: context.retryConfig,
      retryCodes: context.retryCodes
    });
    if (!doResult.ok) {
      return [doResult, { status: "request-error", request: req }];
    }
    const response = doResult.value;
    const [result] = await match(json(200, GetChatFilesResponse$inboundSchema), fail([400, 401, 403, 429, "4XX"]), fail("5XX"))(response, req);
    if (!result.ok) {
      return [result, { status: "complete", request: req, response }];
    }
    return [result, { status: "complete", request: req, response }];
  }

  // node_modules/@gleanwork/api-client/dist/esm/types/blobs.js
  var blobLikeSchema = custom(isBlobLike, {
    message: "expected a Blob, File or Blob-like object",
    fatal: true
  });
  function isBlobLike(val) {
    if (val instanceof Blob) {
      return true;
    }
    if (typeof val !== "object" || val == null || !(Symbol.toStringTag in val)) {
      return false;
    }
    const name = val[Symbol.toStringTag];
    if (typeof name !== "string") {
      return false;
    }
    if (name !== "Blob" && name !== "File") {
      return false;
    }
    return "stream" in val && typeof val.stream === "function";
  }

  // node_modules/@gleanwork/api-client/dist/esm/types/streams.js
  function isReadableStream(val) {
    if (typeof val !== "object" || val === null) {
      return false;
    }
    const stream = val;
    return typeof stream.getReader === "function" && typeof stream.cancel === "function" && typeof stream.tee === "function";
  }

  // node_modules/@gleanwork/api-client/dist/esm/funcs/clientChatUploadFiles.js
  function clientChatUploadFiles(client, uploadChatFilesRequest, timezoneOffset, options) {
    return new APIPromise($do25(client, uploadChatFilesRequest, timezoneOffset, options));
  }
  async function $do25(client, uploadChatFilesRequest, timezoneOffset, options) {
    const input = {
      uploadChatFilesRequest,
      timezoneOffset
    };
    const parsed = safeParse(input, (value) => UploadchatfilesRequest$outboundSchema.parse(value), "Input validation failed");
    if (!parsed.ok) {
      return [parsed, { status: "invalid" }];
    }
    const payload = parsed.value;
    const body = new FormData();
    for (const fileItem of payload.UploadChatFilesRequest.files) {
      if (isBlobLike(fileItem)) {
        appendForm(body, "files[]", fileItem);
      } else if (isReadableStream(fileItem.content)) {
        const buffer = await readableStreamToArrayBuffer(fileItem.content);
        const contentType = getContentTypeFromFileName(fileItem.fileName) || "application/octet-stream";
        const blob = new Blob([buffer], { type: contentType });
        appendForm(body, "files[]", blob, fileItem.fileName);
      } else {
        const contentType = getContentTypeFromFileName(fileItem.fileName) || "application/octet-stream";
        appendForm(body, "files[]", new Blob([fileItem.content], { type: contentType }), fileItem.fileName);
      }
    }
    const path = pathToFunc("/rest/api/v1/uploadchatfiles")();
    const query = encodeFormQuery({
      "timezoneOffset": payload.timezoneOffset
    });
    const headers = new Headers(compactMap({
      Accept: "application/json"
    }));
    const secConfig = await extractSecurity(client._options.apiToken);
    const securityInput = secConfig == null ? {} : { apiToken: secConfig };
    const requestSecurity = resolveGlobalSecurity(securityInput);
    const context = {
      options: client._options,
      baseURL: options?.serverURL ?? client._baseURL ?? "",
      operationID: "uploadchatfiles",
      oAuth2Scopes: [],
      resolvedSecurity: requestSecurity,
      securitySource: client._options.apiToken,
      retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
      retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
    };
    const requestRes = client._createRequest(context, {
      security: requestSecurity,
      method: "POST",
      baseURL: options?.serverURL,
      path,
      headers,
      query,
      body,
      userAgent: client._options.userAgent,
      timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
    }, options);
    if (!requestRes.ok) {
      return [requestRes, { status: "invalid" }];
    }
    const req = requestRes.value;
    const doResult = await client._do(req, {
      context,
      errorCodes: ["400", "401", "403", "429", "4XX", "5XX"],
      retryConfig: context.retryConfig,
      retryCodes: context.retryCodes
    });
    if (!doResult.ok) {
      return [doResult, { status: "request-error", request: req }];
    }
    const response = doResult.value;
    const [result] = await match(json(200, UploadChatFilesResponse$inboundSchema), fail([400, 401, 403, 429, "4XX"]), fail("5XX"))(response, req);
    if (!result.ok) {
      return [result, { status: "complete", request: req, response }];
    }
    return [result, { status: "complete", request: req, response }];
  }

  // node_modules/@gleanwork/api-client/dist/esm/sdk/chat.js
  var Chat = class extends ClientSDK {
    /**
     * Chat
     *
     * @remarks
     * Have a conversation with Glean AI.
     */
    async create(chatRequest, timezoneOffset, options) {
      return unwrapAsync(clientChatCreate(this, chatRequest, timezoneOffset, options));
    }
    /**
     * Deletes all saved Chats owned by a user
     *
     * @remarks
     * Deletes all saved Chats a user has had and all their contained conversational content.
     */
    async deleteAll(timezoneOffset, options) {
      return unwrapAsync(clientChatDeleteAll(this, timezoneOffset, options));
    }
    /**
     * Deletes saved Chats
     *
     * @remarks
     * Deletes saved Chats and all their contained conversational content.
     */
    async delete(deleteChatsRequest, timezoneOffset, options) {
      return unwrapAsync(clientChatDelete(this, deleteChatsRequest, timezoneOffset, options));
    }
    /**
     * Retrieves a Chat
     *
     * @remarks
     * Retrieves the chat history between Glean Assistant and the user for a given Chat.
     */
    async retrieve(getChatRequest, timezoneOffset, options) {
      return unwrapAsync(clientChatRetrieve(this, getChatRequest, timezoneOffset, options));
    }
    /**
     * Retrieves all saved Chats
     *
     * @remarks
     * Retrieves all the saved Chats between Glean Assistant and the user. The returned Chats contain only metadata and no conversational content.
     */
    async list(timezoneOffset, options) {
      return unwrapAsync(clientChatList(this, timezoneOffset, options));
    }
    /**
     * Gets the metadata for a custom Chat application
     *
     * @remarks
     * Gets the Chat application details for the specified application ID.
     */
    async retrieveApplication(getChatApplicationRequest, timezoneOffset, options) {
      return unwrapAsync(clientChatRetrieveApplication(this, getChatApplicationRequest, timezoneOffset, options));
    }
    /**
     * Upload files for Chat.
     *
     * @remarks
     * Upload files for Chat.
     */
    async uploadFiles(uploadChatFilesRequest, timezoneOffset, options) {
      return unwrapAsync(clientChatUploadFiles(this, uploadChatFilesRequest, timezoneOffset, options));
    }
    /**
     * Get files uploaded by a user for Chat.
     *
     * @remarks
     * Get files uploaded by a user for Chat.
     */
    async retrieveFiles(getChatFilesRequest, timezoneOffset, options) {
      return unwrapAsync(clientChatRetrieveFiles(this, getChatFilesRequest, timezoneOffset, options));
    }
    /**
     * Delete files uploaded by a user for chat.
     *
     * @remarks
     * Delete files uploaded by a user for Chat.
     */
    async deleteFiles(deleteChatFilesRequest, timezoneOffset, options) {
      return unwrapAsync(clientChatDeleteFiles(this, deleteChatFilesRequest, timezoneOffset, options));
    }
    /**
     * Chat
     *
     * @remarks
     * Have a conversation with Glean AI.
     */
    async createStream(chatRequest, timezoneOffset, options) {
      return unwrapAsync(clientChatCreateStream(this, chatRequest, timezoneOffset, options));
    }
  };

  // node_modules/@gleanwork/api-client/dist/esm/funcs/clientAuthenticationCreateToken.js
  function clientAuthenticationCreateToken(client, options) {
    return new APIPromise($do26(client, options));
  }
  async function $do26(client, options) {
    const path = pathToFunc("/rest/api/v1/createauthtoken")();
    const headers = new Headers(compactMap({
      Accept: "application/json"
    }));
    const secConfig = await extractSecurity(client._options.apiToken);
    const securityInput = secConfig == null ? {} : { apiToken: secConfig };
    const requestSecurity = resolveGlobalSecurity(securityInput);
    const context = {
      options: client._options,
      baseURL: options?.serverURL ?? client._baseURL ?? "",
      operationID: "createauthtoken",
      oAuth2Scopes: [],
      resolvedSecurity: requestSecurity,
      securitySource: client._options.apiToken,
      retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
      retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
    };
    const requestRes = client._createRequest(context, {
      security: requestSecurity,
      method: "POST",
      baseURL: options?.serverURL,
      path,
      headers,
      userAgent: client._options.userAgent,
      timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
    }, options);
    if (!requestRes.ok) {
      return [requestRes, { status: "invalid" }];
    }
    const req = requestRes.value;
    const doResult = await client._do(req, {
      context,
      errorCodes: ["400", "401", "429", "4XX", "5XX"],
      retryConfig: context.retryConfig,
      retryCodes: context.retryCodes
    });
    if (!doResult.ok) {
      return [doResult, { status: "request-error", request: req }];
    }
    const response = doResult.value;
    const [result] = await match(json(200, CreateAuthTokenResponse$inboundSchema), fail([400, 401, 429, "4XX"]), fail("5XX"))(response, req);
    if (!result.ok) {
      return [result, { status: "complete", request: req, response }];
    }
    return [result, { status: "complete", request: req, response }];
  }

  // node_modules/@gleanwork/api-client/dist/esm/sdk/clientauthentication.js
  var ClientAuthentication = class extends ClientSDK {
    /**
     * Create authentication token
     *
     * @remarks
     * Creates an authentication token for the authenticated user. These are
     * specifically intended to be used with the [Web SDK](https://developers.glean.com/web).
     *
     * Note: The tokens generated from this endpoint are **not** valid tokens
     * for use with the Client API (e.g. `/rest/api/v1/*`).
     */
    async createToken(options) {
      return unwrapAsync(clientAuthenticationCreateToken(this, options));
    }
  };

  // node_modules/@gleanwork/api-client/dist/esm/funcs/clientDocumentsRetrieve.js
  function clientDocumentsRetrieve(client, request, options) {
    return new APIPromise($do27(client, request, options));
  }
  async function $do27(client, request, options) {
    const parsed = safeParse(request, (value) => GetDocumentsRequest$outboundSchema.optional().parse(value), "Input validation failed");
    if (!parsed.ok) {
      return [parsed, { status: "invalid" }];
    }
    const payload = parsed.value;
    const body = payload === void 0 ? null : encodeJSON("body", payload, { explode: true });
    const path = pathToFunc("/rest/api/v1/getdocuments")();
    const headers = new Headers(compactMap({
      "Content-Type": "application/json",
      Accept: "application/json"
    }));
    const secConfig = await extractSecurity(client._options.apiToken);
    const securityInput = secConfig == null ? {} : { apiToken: secConfig };
    const requestSecurity = resolveGlobalSecurity(securityInput);
    const context = {
      options: client._options,
      baseURL: options?.serverURL ?? client._baseURL ?? "",
      operationID: "getdocuments",
      oAuth2Scopes: [],
      resolvedSecurity: requestSecurity,
      securitySource: client._options.apiToken,
      retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
      retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
    };
    const requestRes = client._createRequest(context, {
      security: requestSecurity,
      method: "POST",
      baseURL: options?.serverURL,
      path,
      headers,
      body,
      userAgent: client._options.userAgent,
      timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
    }, options);
    if (!requestRes.ok) {
      return [requestRes, { status: "invalid" }];
    }
    const req = requestRes.value;
    const doResult = await client._do(req, {
      context,
      errorCodes: ["400", "401", "403", "429", "4XX", "5XX"],
      retryConfig: context.retryConfig,
      retryCodes: context.retryCodes
    });
    if (!doResult.ok) {
      return [doResult, { status: "request-error", request: req }];
    }
    const response = doResult.value;
    const [result] = await match(json(200, GetDocumentsResponse$inboundSchema), fail([400, 401, 403, 429, "4XX"]), fail("5XX"))(response, req);
    if (!result.ok) {
      return [result, { status: "complete", request: req, response }];
    }
    return [result, { status: "complete", request: req, response }];
  }

  // node_modules/@gleanwork/api-client/dist/esm/funcs/clientDocumentsRetrieveByFacets.js
  function clientDocumentsRetrieveByFacets(client, request, options) {
    return new APIPromise($do28(client, request, options));
  }
  async function $do28(client, request, options) {
    const parsed = safeParse(request, (value) => GetDocumentsByFacetsRequest$outboundSchema.optional().parse(value), "Input validation failed");
    if (!parsed.ok) {
      return [parsed, { status: "invalid" }];
    }
    const payload = parsed.value;
    const body = payload === void 0 ? null : encodeJSON("body", payload, { explode: true });
    const path = pathToFunc("/rest/api/v1/getdocumentsbyfacets")();
    const headers = new Headers(compactMap({
      "Content-Type": "application/json",
      Accept: "application/json"
    }));
    const secConfig = await extractSecurity(client._options.apiToken);
    const securityInput = secConfig == null ? {} : { apiToken: secConfig };
    const requestSecurity = resolveGlobalSecurity(securityInput);
    const context = {
      options: client._options,
      baseURL: options?.serverURL ?? client._baseURL ?? "",
      operationID: "getdocumentsbyfacets",
      oAuth2Scopes: [],
      resolvedSecurity: requestSecurity,
      securitySource: client._options.apiToken,
      retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
      retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
    };
    const requestRes = client._createRequest(context, {
      security: requestSecurity,
      method: "POST",
      baseURL: options?.serverURL,
      path,
      headers,
      body,
      userAgent: client._options.userAgent,
      timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
    }, options);
    if (!requestRes.ok) {
      return [requestRes, { status: "invalid" }];
    }
    const req = requestRes.value;
    const doResult = await client._do(req, {
      context,
      errorCodes: ["400", "401", "404", "429", "4XX", "5XX"],
      retryConfig: context.retryConfig,
      retryCodes: context.retryCodes
    });
    if (!doResult.ok) {
      return [doResult, { status: "request-error", request: req }];
    }
    const response = doResult.value;
    const [result] = await match(json(200, GetDocumentsByFacetsResponse$inboundSchema), fail([400, 401, 404, 429, "4XX"]), fail("5XX"))(response, req);
    if (!result.ok) {
      return [result, { status: "complete", request: req, response }];
    }
    return [result, { status: "complete", request: req, response }];
  }

  // node_modules/@gleanwork/api-client/dist/esm/funcs/clientDocumentsRetrievePermissions.js
  function clientDocumentsRetrievePermissions(client, request, options) {
    return new APIPromise($do29(client, request, options));
  }
  async function $do29(client, request, options) {
    const parsed = safeParse(request, (value) => GetDocPermissionsRequest$outboundSchema.parse(value), "Input validation failed");
    if (!parsed.ok) {
      return [parsed, { status: "invalid" }];
    }
    const payload = parsed.value;
    const body = encodeJSON("body", payload, { explode: true });
    const path = pathToFunc("/rest/api/v1/getdocpermissions")();
    const headers = new Headers(compactMap({
      "Content-Type": "application/json",
      Accept: "application/json"
    }));
    const secConfig = await extractSecurity(client._options.apiToken);
    const securityInput = secConfig == null ? {} : { apiToken: secConfig };
    const requestSecurity = resolveGlobalSecurity(securityInput);
    const context = {
      options: client._options,
      baseURL: options?.serverURL ?? client._baseURL ?? "",
      operationID: "getdocpermissions",
      oAuth2Scopes: [],
      resolvedSecurity: requestSecurity,
      securitySource: client._options.apiToken,
      retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
      retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
    };
    const requestRes = client._createRequest(context, {
      security: requestSecurity,
      method: "POST",
      baseURL: options?.serverURL,
      path,
      headers,
      body,
      userAgent: client._options.userAgent,
      timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
    }, options);
    if (!requestRes.ok) {
      return [requestRes, { status: "invalid" }];
    }
    const req = requestRes.value;
    const doResult = await client._do(req, {
      context,
      errorCodes: ["400", "401", "403", "429", "4XX", "5XX"],
      retryConfig: context.retryConfig,
      retryCodes: context.retryCodes
    });
    if (!doResult.ok) {
      return [doResult, { status: "request-error", request: req }];
    }
    const response = doResult.value;
    const [result] = await match(json(200, GetDocPermissionsResponse$inboundSchema), fail([400, 401, 403, 429, "4XX"]), fail("5XX"))(response, req);
    if (!result.ok) {
      return [result, { status: "complete", request: req, response }];
    }
    return [result, { status: "complete", request: req, response }];
  }

  // node_modules/@gleanwork/api-client/dist/esm/funcs/clientDocumentsSummarize.js
  function clientDocumentsSummarize(client, request, options) {
    return new APIPromise($do30(client, request, options));
  }
  async function $do30(client, request, options) {
    const parsed = safeParse(request, (value) => SummarizeRequest$outboundSchema.parse(value), "Input validation failed");
    if (!parsed.ok) {
      return [parsed, { status: "invalid" }];
    }
    const payload = parsed.value;
    const body = encodeJSON("body", payload, { explode: true });
    const path = pathToFunc("/rest/api/v1/summarize")();
    const headers = new Headers(compactMap({
      "Content-Type": "application/json",
      Accept: "application/json"
    }));
    const secConfig = await extractSecurity(client._options.apiToken);
    const securityInput = secConfig == null ? {} : { apiToken: secConfig };
    const requestSecurity = resolveGlobalSecurity(securityInput);
    const context = {
      options: client._options,
      baseURL: options?.serverURL ?? client._baseURL ?? "",
      operationID: "summarize",
      oAuth2Scopes: [],
      resolvedSecurity: requestSecurity,
      securitySource: client._options.apiToken,
      retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
      retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
    };
    const requestRes = client._createRequest(context, {
      security: requestSecurity,
      method: "POST",
      baseURL: options?.serverURL,
      path,
      headers,
      body,
      userAgent: client._options.userAgent,
      timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
    }, options);
    if (!requestRes.ok) {
      return [requestRes, { status: "invalid" }];
    }
    const req = requestRes.value;
    const doResult = await client._do(req, {
      context,
      errorCodes: ["400", "401", "429", "4XX", "5XX"],
      retryConfig: context.retryConfig,
      retryCodes: context.retryCodes
    });
    if (!doResult.ok) {
      return [doResult, { status: "request-error", request: req }];
    }
    const response = doResult.value;
    const [result] = await match(json(200, SummarizeResponse$inboundSchema), fail([400, 401, 429, "4XX"]), fail("5XX"))(response, req);
    if (!result.ok) {
      return [result, { status: "complete", request: req, response }];
    }
    return [result, { status: "complete", request: req, response }];
  }

  // node_modules/@gleanwork/api-client/dist/esm/sdk/clientdocuments.js
  var ClientDocuments = class extends ClientSDK {
    /**
     * Read document permissions
     *
     * @remarks
     * Read the emails of all users who have access to the given document.
     */
    async retrievePermissions(request, options) {
      return unwrapAsync(clientDocumentsRetrievePermissions(this, request, options));
    }
    /**
     * Read documents
     *
     * @remarks
     * Read the documents including metadata (does not include enhanced metadata via `/documentmetadata`) for the given list of Glean Document IDs or URLs specified in the request.
     */
    async retrieve(request, options) {
      return unwrapAsync(clientDocumentsRetrieve(this, request, options));
    }
    /**
     * Read documents by facets
     *
     * @remarks
     * Read the documents including metadata (does not include enhanced metadata via `/documentmetadata`) macthing the given facet conditions.
     */
    async retrieveByFacets(request, options) {
      return unwrapAsync(clientDocumentsRetrieveByFacets(this, request, options));
    }
    /**
     * Summarize documents
     *
     * @remarks
     * Generate an AI summary of the requested documents.
     */
    async summarize(request, options) {
      return unwrapAsync(clientDocumentsSummarize(this, request, options));
    }
  };

  // node_modules/@gleanwork/api-client/dist/esm/funcs/clientShortcutsCreate.js
  function clientShortcutsCreate(client, request, options) {
    return new APIPromise($do31(client, request, options));
  }
  async function $do31(client, request, options) {
    const parsed = safeParse(request, (value) => CreateShortcutRequest$outboundSchema.parse(value), "Input validation failed");
    if (!parsed.ok) {
      return [parsed, { status: "invalid" }];
    }
    const payload = parsed.value;
    const body = encodeJSON("body", payload, { explode: true });
    const path = pathToFunc("/rest/api/v1/createshortcut")();
    const headers = new Headers(compactMap({
      "Content-Type": "application/json",
      Accept: "application/json"
    }));
    const secConfig = await extractSecurity(client._options.apiToken);
    const securityInput = secConfig == null ? {} : { apiToken: secConfig };
    const requestSecurity = resolveGlobalSecurity(securityInput);
    const context = {
      options: client._options,
      baseURL: options?.serverURL ?? client._baseURL ?? "",
      operationID: "createshortcut",
      oAuth2Scopes: [],
      resolvedSecurity: requestSecurity,
      securitySource: client._options.apiToken,
      retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
      retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
    };
    const requestRes = client._createRequest(context, {
      security: requestSecurity,
      method: "POST",
      baseURL: options?.serverURL,
      path,
      headers,
      body,
      userAgent: client._options.userAgent,
      timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
    }, options);
    if (!requestRes.ok) {
      return [requestRes, { status: "invalid" }];
    }
    const req = requestRes.value;
    const doResult = await client._do(req, {
      context,
      errorCodes: ["400", "401", "429", "4XX", "5XX"],
      retryConfig: context.retryConfig,
      retryCodes: context.retryCodes
    });
    if (!doResult.ok) {
      return [doResult, { status: "request-error", request: req }];
    }
    const response = doResult.value;
    const [result] = await match(json(200, CreateShortcutResponse$inboundSchema), fail([400, 401, 429, "4XX"]), fail("5XX"))(response, req);
    if (!result.ok) {
      return [result, { status: "complete", request: req, response }];
    }
    return [result, { status: "complete", request: req, response }];
  }

  // node_modules/@gleanwork/api-client/dist/esm/funcs/clientShortcutsDelete.js
  function clientShortcutsDelete(client, request, options) {
    return new APIPromise($do32(client, request, options));
  }
  async function $do32(client, request, options) {
    const parsed = safeParse(request, (value) => DeleteShortcutRequest$outboundSchema.parse(value), "Input validation failed");
    if (!parsed.ok) {
      return [parsed, { status: "invalid" }];
    }
    const payload = parsed.value;
    const body = encodeJSON("body", payload, { explode: true });
    const path = pathToFunc("/rest/api/v1/deleteshortcut")();
    const headers = new Headers(compactMap({
      "Content-Type": "application/json",
      Accept: "*/*"
    }));
    const secConfig = await extractSecurity(client._options.apiToken);
    const securityInput = secConfig == null ? {} : { apiToken: secConfig };
    const requestSecurity = resolveGlobalSecurity(securityInput);
    const context = {
      options: client._options,
      baseURL: options?.serverURL ?? client._baseURL ?? "",
      operationID: "deleteshortcut",
      oAuth2Scopes: [],
      resolvedSecurity: requestSecurity,
      securitySource: client._options.apiToken,
      retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
      retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
    };
    const requestRes = client._createRequest(context, {
      security: requestSecurity,
      method: "POST",
      baseURL: options?.serverURL,
      path,
      headers,
      body,
      userAgent: client._options.userAgent,
      timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
    }, options);
    if (!requestRes.ok) {
      return [requestRes, { status: "invalid" }];
    }
    const req = requestRes.value;
    const doResult = await client._do(req, {
      context,
      errorCodes: ["400", "401", "429", "4XX", "5XX"],
      retryConfig: context.retryConfig,
      retryCodes: context.retryCodes
    });
    if (!doResult.ok) {
      return [doResult, { status: "request-error", request: req }];
    }
    const response = doResult.value;
    const [result] = await match(nil(200, voidType()), fail([400, 401, 429, "4XX"]), fail("5XX"))(response, req);
    if (!result.ok) {
      return [result, { status: "complete", request: req, response }];
    }
    return [result, { status: "complete", request: req, response }];
  }

  // node_modules/@gleanwork/api-client/dist/esm/funcs/clientShortcutsList.js
  function clientShortcutsList(client, request, options) {
    return new APIPromise($do33(client, request, options));
  }
  async function $do33(client, request, options) {
    const parsed = safeParse(request, (value) => ListShortcutsPaginatedRequest$outboundSchema.parse(value), "Input validation failed");
    if (!parsed.ok) {
      return [parsed, { status: "invalid" }];
    }
    const payload = parsed.value;
    const body = encodeJSON("body", payload, { explode: true });
    const path = pathToFunc("/rest/api/v1/listshortcuts")();
    const headers = new Headers(compactMap({
      "Content-Type": "application/json",
      Accept: "application/json"
    }));
    const secConfig = await extractSecurity(client._options.apiToken);
    const securityInput = secConfig == null ? {} : { apiToken: secConfig };
    const requestSecurity = resolveGlobalSecurity(securityInput);
    const context = {
      options: client._options,
      baseURL: options?.serverURL ?? client._baseURL ?? "",
      operationID: "listshortcuts",
      oAuth2Scopes: [],
      resolvedSecurity: requestSecurity,
      securitySource: client._options.apiToken,
      retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
      retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
    };
    const requestRes = client._createRequest(context, {
      security: requestSecurity,
      method: "POST",
      baseURL: options?.serverURL,
      path,
      headers,
      body,
      userAgent: client._options.userAgent,
      timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
    }, options);
    if (!requestRes.ok) {
      return [requestRes, { status: "invalid" }];
    }
    const req = requestRes.value;
    const doResult = await client._do(req, {
      context,
      errorCodes: ["400", "401", "429", "4XX", "5XX"],
      retryConfig: context.retryConfig,
      retryCodes: context.retryCodes
    });
    if (!doResult.ok) {
      return [doResult, { status: "request-error", request: req }];
    }
    const response = doResult.value;
    const [result] = await match(json(200, ListShortcutsPaginatedResponse$inboundSchema), fail([400, 401, 429, "4XX"]), fail("5XX"))(response, req);
    if (!result.ok) {
      return [result, { status: "complete", request: req, response }];
    }
    return [result, { status: "complete", request: req, response }];
  }

  // node_modules/@gleanwork/api-client/dist/esm/funcs/clientShortcutsRetrieve.js
  function clientShortcutsRetrieve(client, request, options) {
    return new APIPromise($do34(client, request, options));
  }
  async function $do34(client, request, options) {
    const parsed = safeParse(request, (value) => GetShortcutRequestUnion$outboundSchema.parse(value), "Input validation failed");
    if (!parsed.ok) {
      return [parsed, { status: "invalid" }];
    }
    const payload = parsed.value;
    const body = encodeJSON("body", payload, { explode: true });
    const path = pathToFunc("/rest/api/v1/getshortcut")();
    const headers = new Headers(compactMap({
      "Content-Type": "application/json",
      Accept: "application/json"
    }));
    const secConfig = await extractSecurity(client._options.apiToken);
    const securityInput = secConfig == null ? {} : { apiToken: secConfig };
    const requestSecurity = resolveGlobalSecurity(securityInput);
    const context = {
      options: client._options,
      baseURL: options?.serverURL ?? client._baseURL ?? "",
      operationID: "getshortcut",
      oAuth2Scopes: [],
      resolvedSecurity: requestSecurity,
      securitySource: client._options.apiToken,
      retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
      retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
    };
    const requestRes = client._createRequest(context, {
      security: requestSecurity,
      method: "POST",
      baseURL: options?.serverURL,
      path,
      headers,
      body,
      userAgent: client._options.userAgent,
      timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
    }, options);
    if (!requestRes.ok) {
      return [requestRes, { status: "invalid" }];
    }
    const req = requestRes.value;
    const doResult = await client._do(req, {
      context,
      errorCodes: ["400", "401", "429", "4XX", "5XX"],
      retryConfig: context.retryConfig,
      retryCodes: context.retryCodes
    });
    if (!doResult.ok) {
      return [doResult, { status: "request-error", request: req }];
    }
    const response = doResult.value;
    const [result] = await match(json(200, GetShortcutResponse$inboundSchema), fail([400, 401, 429, "4XX"]), fail("5XX"))(response, req);
    if (!result.ok) {
      return [result, { status: "complete", request: req, response }];
    }
    return [result, { status: "complete", request: req, response }];
  }

  // node_modules/@gleanwork/api-client/dist/esm/funcs/clientShortcutsUpdate.js
  function clientShortcutsUpdate(client, request, options) {
    return new APIPromise($do35(client, request, options));
  }
  async function $do35(client, request, options) {
    const parsed = safeParse(request, (value) => UpdateShortcutRequest$outboundSchema.parse(value), "Input validation failed");
    if (!parsed.ok) {
      return [parsed, { status: "invalid" }];
    }
    const payload = parsed.value;
    const body = encodeJSON("body", payload, { explode: true });
    const path = pathToFunc("/rest/api/v1/updateshortcut")();
    const headers = new Headers(compactMap({
      "Content-Type": "application/json",
      Accept: "application/json"
    }));
    const secConfig = await extractSecurity(client._options.apiToken);
    const securityInput = secConfig == null ? {} : { apiToken: secConfig };
    const requestSecurity = resolveGlobalSecurity(securityInput);
    const context = {
      options: client._options,
      baseURL: options?.serverURL ?? client._baseURL ?? "",
      operationID: "updateshortcut",
      oAuth2Scopes: [],
      resolvedSecurity: requestSecurity,
      securitySource: client._options.apiToken,
      retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
      retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
    };
    const requestRes = client._createRequest(context, {
      security: requestSecurity,
      method: "POST",
      baseURL: options?.serverURL,
      path,
      headers,
      body,
      userAgent: client._options.userAgent,
      timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
    }, options);
    if (!requestRes.ok) {
      return [requestRes, { status: "invalid" }];
    }
    const req = requestRes.value;
    const doResult = await client._do(req, {
      context,
      errorCodes: ["400", "401", "429", "4XX", "5XX"],
      retryConfig: context.retryConfig,
      retryCodes: context.retryCodes
    });
    if (!doResult.ok) {
      return [doResult, { status: "request-error", request: req }];
    }
    const response = doResult.value;
    const [result] = await match(json(200, UpdateShortcutResponse$inboundSchema), fail([400, 401, 429, "4XX"]), fail("5XX"))(response, req);
    if (!result.ok) {
      return [result, { status: "complete", request: req, response }];
    }
    return [result, { status: "complete", request: req, response }];
  }

  // node_modules/@gleanwork/api-client/dist/esm/sdk/clientshortcuts.js
  var ClientShortcuts = class extends ClientSDK {
    /**
     * Create shortcut
     *
     * @remarks
     * Create a user-generated shortcut that contains an alias and destination URL.
     */
    async create(request, options) {
      return unwrapAsync(clientShortcutsCreate(this, request, options));
    }
    /**
     * Delete shortcut
     *
     * @remarks
     * Delete an existing user-generated shortcut.
     */
    async delete(request, options) {
      return unwrapAsync(clientShortcutsDelete(this, request, options));
    }
    /**
     * Read shortcut
     *
     * @remarks
     * Read a particular shortcut's details given its ID.
     */
    async retrieve(request, options) {
      return unwrapAsync(clientShortcutsRetrieve(this, request, options));
    }
    /**
     * List shortcuts
     *
     * @remarks
     * List shortcuts editable/owned by the currently authenticated user.
     */
    async list(request, options) {
      return unwrapAsync(clientShortcutsList(this, request, options));
    }
    /**
     * Update shortcut
     *
     * @remarks
     * Updates the shortcut with the given ID.
     */
    async update(request, options) {
      return unwrapAsync(clientShortcutsUpdate(this, request, options));
    }
  };

  // node_modules/@gleanwork/api-client/dist/esm/funcs/clientCollectionsAddItems.js
  function clientCollectionsAddItems(client, request, options) {
    return new APIPromise($do36(client, request, options));
  }
  async function $do36(client, request, options) {
    const parsed = safeParse(request, (value) => AddCollectionItemsRequest$outboundSchema.parse(value), "Input validation failed");
    if (!parsed.ok) {
      return [parsed, { status: "invalid" }];
    }
    const payload = parsed.value;
    const body = encodeJSON("body", payload, { explode: true });
    const path = pathToFunc("/rest/api/v1/addcollectionitems")();
    const headers = new Headers(compactMap({
      "Content-Type": "application/json",
      Accept: "application/json"
    }));
    const secConfig = await extractSecurity(client._options.apiToken);
    const securityInput = secConfig == null ? {} : { apiToken: secConfig };
    const requestSecurity = resolveGlobalSecurity(securityInput);
    const context = {
      options: client._options,
      baseURL: options?.serverURL ?? client._baseURL ?? "",
      operationID: "addcollectionitems",
      oAuth2Scopes: [],
      resolvedSecurity: requestSecurity,
      securitySource: client._options.apiToken,
      retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
      retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
    };
    const requestRes = client._createRequest(context, {
      security: requestSecurity,
      method: "POST",
      baseURL: options?.serverURL,
      path,
      headers,
      body,
      userAgent: client._options.userAgent,
      timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
    }, options);
    if (!requestRes.ok) {
      return [requestRes, { status: "invalid" }];
    }
    const req = requestRes.value;
    const doResult = await client._do(req, {
      context,
      errorCodes: ["400", "401", "429", "4XX", "5XX"],
      retryConfig: context.retryConfig,
      retryCodes: context.retryCodes
    });
    if (!doResult.ok) {
      return [doResult, { status: "request-error", request: req }];
    }
    const response = doResult.value;
    const [result] = await match(json(200, AddCollectionItemsResponse$inboundSchema), fail([400, 401, 429, "4XX"]), fail("5XX"))(response, req);
    if (!result.ok) {
      return [result, { status: "complete", request: req, response }];
    }
    return [result, { status: "complete", request: req, response }];
  }

  // node_modules/@gleanwork/api-client/dist/esm/models/errors/collectionerror.js
  var CollectionError = class extends GleanBaseError {
    constructor(err, httpMeta) {
      const message = "message" in err && typeof err.message === "string" ? err.message : `API error occurred: ${JSON.stringify(err)}`;
      super(message, httpMeta);
      this.data$ = err;
      this.errorCode = err.errorCode;
      this.name = "CollectionError";
    }
  };
  var CollectionError$inboundSchema2 = objectType({
    errorCode: CollectionErrorErrorCode$inboundSchema,
    request$: instanceOfType(Request),
    response$: instanceOfType(Response),
    body$: stringType()
  }).transform((v) => {
    return new CollectionError(v, {
      request: v.request$,
      response: v.response$,
      body: v.body$
    });
  });
  var CollectionError$outboundSchema2 = instanceOfType(CollectionError).transform((v) => v.data$).pipe(objectType({
    errorCode: CollectionErrorErrorCode$outboundSchema
  }));
  var CollectionError$2;
  (function(CollectionError$3) {
    CollectionError$3.inboundSchema = CollectionError$inboundSchema2;
    CollectionError$3.outboundSchema = CollectionError$outboundSchema2;
  })(CollectionError$2 || (CollectionError$2 = {}));

  // node_modules/@gleanwork/api-client/dist/esm/models/errors/gleandataerror.js
  var GleanDataError = class extends GleanBaseError {
    constructor(err, httpMeta) {
      const message = "message" in err && typeof err.message === "string" ? err.message : `API error occurred: ${JSON.stringify(err)}`;
      super(message, httpMeta);
      this.data$ = err;
      if (err.badGmailToken != null)
        this.badGmailToken = err.badGmailToken;
      if (err.badOutlookToken != null)
        this.badOutlookToken = err.badOutlookToken;
      if (err.invalidOperators != null) {
        this.invalidOperators = err.invalidOperators;
      }
      if (err.errorMessages != null)
        this.errorMessages = err.errorMessages;
      this.name = "GleanDataError";
    }
  };
  var GleanDataError$inboundSchema2 = objectType({
    badGmailToken: booleanType().optional(),
    badOutlookToken: booleanType().optional(),
    invalidOperators: arrayType(InvalidOperatorValueError$inboundSchema).optional(),
    errorMessages: arrayType(ErrorMessage$inboundSchema).optional(),
    request$: instanceOfType(Request),
    response$: instanceOfType(Response),
    body$: stringType()
  }).transform((v) => {
    return new GleanDataError(v, {
      request: v.request$,
      response: v.response$,
      body: v.body$
    });
  });
  var GleanDataError$outboundSchema2 = instanceOfType(GleanDataError).transform((v) => v.data$).pipe(objectType({
    badGmailToken: booleanType().optional(),
    badOutlookToken: booleanType().optional(),
    invalidOperators: arrayType(InvalidOperatorValueError$outboundSchema).optional(),
    errorMessages: arrayType(ErrorMessage$outboundSchema).optional()
  }));
  var GleanDataError$2;
  (function(GleanDataError$3) {
    GleanDataError$3.inboundSchema = GleanDataError$inboundSchema2;
    GleanDataError$3.outboundSchema = GleanDataError$outboundSchema2;
  })(GleanDataError$2 || (GleanDataError$2 = {}));

  // node_modules/@gleanwork/api-client/dist/esm/funcs/clientCollectionsCreate.js
  function clientCollectionsCreate(client, request, options) {
    return new APIPromise($do37(client, request, options));
  }
  async function $do37(client, request, options) {
    const parsed = safeParse(request, (value) => CreateCollectionRequest$outboundSchema.parse(value), "Input validation failed");
    if (!parsed.ok) {
      return [parsed, { status: "invalid" }];
    }
    const payload = parsed.value;
    const body = encodeJSON("body", payload, { explode: true });
    const path = pathToFunc("/rest/api/v1/createcollection")();
    const headers = new Headers(compactMap({
      "Content-Type": "application/json",
      Accept: "application/json"
    }));
    const secConfig = await extractSecurity(client._options.apiToken);
    const securityInput = secConfig == null ? {} : { apiToken: secConfig };
    const requestSecurity = resolveGlobalSecurity(securityInput);
    const context = {
      options: client._options,
      baseURL: options?.serverURL ?? client._baseURL ?? "",
      operationID: "createcollection",
      oAuth2Scopes: [],
      resolvedSecurity: requestSecurity,
      securitySource: client._options.apiToken,
      retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
      retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
    };
    const requestRes = client._createRequest(context, {
      security: requestSecurity,
      method: "POST",
      baseURL: options?.serverURL,
      path,
      headers,
      body,
      userAgent: client._options.userAgent,
      timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
    }, options);
    if (!requestRes.ok) {
      return [requestRes, { status: "invalid" }];
    }
    const req = requestRes.value;
    const doResult = await client._do(req, {
      context,
      errorCodes: ["400", "401", "422", "429", "4XX", "5XX"],
      retryConfig: context.retryConfig,
      retryCodes: context.retryCodes
    });
    if (!doResult.ok) {
      return [doResult, { status: "request-error", request: req }];
    }
    const response = doResult.value;
    const responseFields = {
      HttpMeta: { Response: response, Request: req }
    };
    const [result] = await match(json(200, CreatecollectionResponse$inboundSchema), jsonErr(422, CollectionError$inboundSchema2), fail([400, 401, 429, "4XX"]), fail("5XX"))(response, req, { extraFields: responseFields });
    if (!result.ok) {
      return [result, { status: "complete", request: req, response }];
    }
    return [result, { status: "complete", request: req, response }];
  }

  // node_modules/@gleanwork/api-client/dist/esm/funcs/clientCollectionsDelete.js
  function clientCollectionsDelete(client, request, options) {
    return new APIPromise($do38(client, request, options));
  }
  async function $do38(client, request, options) {
    const parsed = safeParse(request, (value) => DeleteCollectionRequest$outboundSchema.parse(value), "Input validation failed");
    if (!parsed.ok) {
      return [parsed, { status: "invalid" }];
    }
    const payload = parsed.value;
    const body = encodeJSON("body", payload, { explode: true });
    const path = pathToFunc("/rest/api/v1/deletecollection")();
    const headers = new Headers(compactMap({
      "Content-Type": "application/json",
      Accept: "application/json"
    }));
    const secConfig = await extractSecurity(client._options.apiToken);
    const securityInput = secConfig == null ? {} : { apiToken: secConfig };
    const requestSecurity = resolveGlobalSecurity(securityInput);
    const context = {
      options: client._options,
      baseURL: options?.serverURL ?? client._baseURL ?? "",
      operationID: "deletecollection",
      oAuth2Scopes: [],
      resolvedSecurity: requestSecurity,
      securitySource: client._options.apiToken,
      retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
      retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
    };
    const requestRes = client._createRequest(context, {
      security: requestSecurity,
      method: "POST",
      baseURL: options?.serverURL,
      path,
      headers,
      body,
      userAgent: client._options.userAgent,
      timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
    }, options);
    if (!requestRes.ok) {
      return [requestRes, { status: "invalid" }];
    }
    const req = requestRes.value;
    const doResult = await client._do(req, {
      context,
      errorCodes: ["400", "401", "422", "429", "4XX", "5XX"],
      retryConfig: context.retryConfig,
      retryCodes: context.retryCodes
    });
    if (!doResult.ok) {
      return [doResult, { status: "request-error", request: req }];
    }
    const response = doResult.value;
    const responseFields = {
      HttpMeta: { Response: response, Request: req }
    };
    const [result] = await match(nil(200, voidType()), jsonErr(422, CollectionError$inboundSchema2), fail([400, 401, 429, "4XX"]), fail("5XX"))(response, req, { extraFields: responseFields });
    if (!result.ok) {
      return [result, { status: "complete", request: req, response }];
    }
    return [result, { status: "complete", request: req, response }];
  }

  // node_modules/@gleanwork/api-client/dist/esm/funcs/clientCollectionsDeleteItem.js
  function clientCollectionsDeleteItem(client, request, options) {
    return new APIPromise($do39(client, request, options));
  }
  async function $do39(client, request, options) {
    const parsed = safeParse(request, (value) => DeleteCollectionItemRequest$outboundSchema.parse(value), "Input validation failed");
    if (!parsed.ok) {
      return [parsed, { status: "invalid" }];
    }
    const payload = parsed.value;
    const body = encodeJSON("body", payload, { explode: true });
    const path = pathToFunc("/rest/api/v1/deletecollectionitem")();
    const headers = new Headers(compactMap({
      "Content-Type": "application/json",
      Accept: "application/json"
    }));
    const secConfig = await extractSecurity(client._options.apiToken);
    const securityInput = secConfig == null ? {} : { apiToken: secConfig };
    const requestSecurity = resolveGlobalSecurity(securityInput);
    const context = {
      options: client._options,
      baseURL: options?.serverURL ?? client._baseURL ?? "",
      operationID: "deletecollectionitem",
      oAuth2Scopes: [],
      resolvedSecurity: requestSecurity,
      securitySource: client._options.apiToken,
      retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
      retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
    };
    const requestRes = client._createRequest(context, {
      security: requestSecurity,
      method: "POST",
      baseURL: options?.serverURL,
      path,
      headers,
      body,
      userAgent: client._options.userAgent,
      timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
    }, options);
    if (!requestRes.ok) {
      return [requestRes, { status: "invalid" }];
    }
    const req = requestRes.value;
    const doResult = await client._do(req, {
      context,
      errorCodes: ["400", "401", "422", "429", "4XX", "5XX"],
      retryConfig: context.retryConfig,
      retryCodes: context.retryCodes
    });
    if (!doResult.ok) {
      return [doResult, { status: "request-error", request: req }];
    }
    const response = doResult.value;
    const [result] = await match(json(200, DeleteCollectionItemResponse$inboundSchema), fail([400, 401, 422, 429, "4XX"]), fail("5XX"))(response, req);
    if (!result.ok) {
      return [result, { status: "complete", request: req, response }];
    }
    return [result, { status: "complete", request: req, response }];
  }

  // node_modules/@gleanwork/api-client/dist/esm/funcs/clientCollectionsList.js
  function clientCollectionsList(client, request, options) {
    return new APIPromise($do40(client, request, options));
  }
  async function $do40(client, request, options) {
    const parsed = safeParse(request, (value) => ListCollectionsRequest$outboundSchema.parse(value), "Input validation failed");
    if (!parsed.ok) {
      return [parsed, { status: "invalid" }];
    }
    const payload = parsed.value;
    const body = encodeJSON("body", payload, { explode: true });
    const path = pathToFunc("/rest/api/v1/listcollections")();
    const headers = new Headers(compactMap({
      "Content-Type": "application/json",
      Accept: "application/json"
    }));
    const secConfig = await extractSecurity(client._options.apiToken);
    const securityInput = secConfig == null ? {} : { apiToken: secConfig };
    const requestSecurity = resolveGlobalSecurity(securityInput);
    const context = {
      options: client._options,
      baseURL: options?.serverURL ?? client._baseURL ?? "",
      operationID: "listcollections",
      oAuth2Scopes: [],
      resolvedSecurity: requestSecurity,
      securitySource: client._options.apiToken,
      retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
      retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
    };
    const requestRes = client._createRequest(context, {
      security: requestSecurity,
      method: "POST",
      baseURL: options?.serverURL,
      path,
      headers,
      body,
      userAgent: client._options.userAgent,
      timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
    }, options);
    if (!requestRes.ok) {
      return [requestRes, { status: "invalid" }];
    }
    const req = requestRes.value;
    const doResult = await client._do(req, {
      context,
      errorCodes: ["400", "401", "429", "4XX", "5XX"],
      retryConfig: context.retryConfig,
      retryCodes: context.retryCodes
    });
    if (!doResult.ok) {
      return [doResult, { status: "request-error", request: req }];
    }
    const response = doResult.value;
    const [result] = await match(json(200, ListCollectionsResponse$inboundSchema), fail([400, 401, 429, "4XX"]), fail("5XX"))(response, req);
    if (!result.ok) {
      return [result, { status: "complete", request: req, response }];
    }
    return [result, { status: "complete", request: req, response }];
  }

  // node_modules/@gleanwork/api-client/dist/esm/funcs/clientCollectionsRetrieve.js
  function clientCollectionsRetrieve(client, request, options) {
    return new APIPromise($do41(client, request, options));
  }
  async function $do41(client, request, options) {
    const parsed = safeParse(request, (value) => GetCollectionRequest$outboundSchema.parse(value), "Input validation failed");
    if (!parsed.ok) {
      return [parsed, { status: "invalid" }];
    }
    const payload = parsed.value;
    const body = encodeJSON("body", payload, { explode: true });
    const path = pathToFunc("/rest/api/v1/getcollection")();
    const headers = new Headers(compactMap({
      "Content-Type": "application/json",
      Accept: "application/json"
    }));
    const secConfig = await extractSecurity(client._options.apiToken);
    const securityInput = secConfig == null ? {} : { apiToken: secConfig };
    const requestSecurity = resolveGlobalSecurity(securityInput);
    const context = {
      options: client._options,
      baseURL: options?.serverURL ?? client._baseURL ?? "",
      operationID: "getcollection",
      oAuth2Scopes: [],
      resolvedSecurity: requestSecurity,
      securitySource: client._options.apiToken,
      retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
      retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
    };
    const requestRes = client._createRequest(context, {
      security: requestSecurity,
      method: "POST",
      baseURL: options?.serverURL,
      path,
      headers,
      body,
      userAgent: client._options.userAgent,
      timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
    }, options);
    if (!requestRes.ok) {
      return [requestRes, { status: "invalid" }];
    }
    const req = requestRes.value;
    const doResult = await client._do(req, {
      context,
      errorCodes: ["400", "401", "429", "4XX", "5XX"],
      retryConfig: context.retryConfig,
      retryCodes: context.retryCodes
    });
    if (!doResult.ok) {
      return [doResult, { status: "request-error", request: req }];
    }
    const response = doResult.value;
    const [result] = await match(json(200, GetCollectionResponse$inboundSchema), fail([400, 401, 429, "4XX"]), fail("5XX"))(response, req);
    if (!result.ok) {
      return [result, { status: "complete", request: req, response }];
    }
    return [result, { status: "complete", request: req, response }];
  }

  // node_modules/@gleanwork/api-client/dist/esm/funcs/clientCollectionsUpdate.js
  function clientCollectionsUpdate(client, request, options) {
    return new APIPromise($do42(client, request, options));
  }
  async function $do42(client, request, options) {
    const parsed = safeParse(request, (value) => EditCollectionRequest$outboundSchema.parse(value), "Input validation failed");
    if (!parsed.ok) {
      return [parsed, { status: "invalid" }];
    }
    const payload = parsed.value;
    const body = encodeJSON("body", payload, { explode: true });
    const path = pathToFunc("/rest/api/v1/editcollection")();
    const headers = new Headers(compactMap({
      "Content-Type": "application/json",
      Accept: "application/json"
    }));
    const secConfig = await extractSecurity(client._options.apiToken);
    const securityInput = secConfig == null ? {} : { apiToken: secConfig };
    const requestSecurity = resolveGlobalSecurity(securityInput);
    const context = {
      options: client._options,
      baseURL: options?.serverURL ?? client._baseURL ?? "",
      operationID: "editcollection",
      oAuth2Scopes: [],
      resolvedSecurity: requestSecurity,
      securitySource: client._options.apiToken,
      retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
      retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
    };
    const requestRes = client._createRequest(context, {
      security: requestSecurity,
      method: "POST",
      baseURL: options?.serverURL,
      path,
      headers,
      body,
      userAgent: client._options.userAgent,
      timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
    }, options);
    if (!requestRes.ok) {
      return [requestRes, { status: "invalid" }];
    }
    const req = requestRes.value;
    const doResult = await client._do(req, {
      context,
      errorCodes: ["400", "401", "422", "429", "4XX", "5XX"],
      retryConfig: context.retryConfig,
      retryCodes: context.retryCodes
    });
    if (!doResult.ok) {
      return [doResult, { status: "request-error", request: req }];
    }
    const response = doResult.value;
    const responseFields = {
      HttpMeta: { Response: response, Request: req }
    };
    const [result] = await match(json(200, EditCollectionResponse$inboundSchema), jsonErr(422, CollectionError$inboundSchema2), fail([400, 401, 429, "4XX"]), fail("5XX"))(response, req, { extraFields: responseFields });
    if (!result.ok) {
      return [result, { status: "complete", request: req, response }];
    }
    return [result, { status: "complete", request: req, response }];
  }

  // node_modules/@gleanwork/api-client/dist/esm/funcs/clientCollectionsUpdateItem.js
  function clientCollectionsUpdateItem(client, request, options) {
    return new APIPromise($do43(client, request, options));
  }
  async function $do43(client, request, options) {
    const parsed = safeParse(request, (value) => EditCollectionItemRequest$outboundSchema.parse(value), "Input validation failed");
    if (!parsed.ok) {
      return [parsed, { status: "invalid" }];
    }
    const payload = parsed.value;
    const body = encodeJSON("body", payload, { explode: true });
    const path = pathToFunc("/rest/api/v1/editcollectionitem")();
    const headers = new Headers(compactMap({
      "Content-Type": "application/json",
      Accept: "application/json"
    }));
    const secConfig = await extractSecurity(client._options.apiToken);
    const securityInput = secConfig == null ? {} : { apiToken: secConfig };
    const requestSecurity = resolveGlobalSecurity(securityInput);
    const context = {
      options: client._options,
      baseURL: options?.serverURL ?? client._baseURL ?? "",
      operationID: "editcollectionitem",
      oAuth2Scopes: [],
      resolvedSecurity: requestSecurity,
      securitySource: client._options.apiToken,
      retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
      retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
    };
    const requestRes = client._createRequest(context, {
      security: requestSecurity,
      method: "POST",
      baseURL: options?.serverURL,
      path,
      headers,
      body,
      userAgent: client._options.userAgent,
      timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
    }, options);
    if (!requestRes.ok) {
      return [requestRes, { status: "invalid" }];
    }
    const req = requestRes.value;
    const doResult = await client._do(req, {
      context,
      errorCodes: ["400", "401", "429", "4XX", "5XX"],
      retryConfig: context.retryConfig,
      retryCodes: context.retryCodes
    });
    if (!doResult.ok) {
      return [doResult, { status: "request-error", request: req }];
    }
    const response = doResult.value;
    const [result] = await match(json(200, EditCollectionItemResponse$inboundSchema), fail([400, 401, 429, "4XX"]), fail("5XX"))(response, req);
    if (!result.ok) {
      return [result, { status: "complete", request: req, response }];
    }
    return [result, { status: "complete", request: req, response }];
  }

  // node_modules/@gleanwork/api-client/dist/esm/sdk/collections.js
  var Collections = class extends ClientSDK {
    /**
     * Add Collection item
     *
     * @remarks
     * Add items to a Collection.
     */
    async addItems(request, options) {
      return unwrapAsync(clientCollectionsAddItems(this, request, options));
    }
    /**
     * Create Collection
     *
     * @remarks
     * Create a publicly visible (empty) Collection of documents.
     */
    async create(request, options) {
      return unwrapAsync(clientCollectionsCreate(this, request, options));
    }
    /**
     * Delete Collection
     *
     * @remarks
     * Delete a Collection given the Collection's ID.
     */
    async delete(request, options) {
      return unwrapAsync(clientCollectionsDelete(this, request, options));
    }
    /**
     * Delete Collection item
     *
     * @remarks
     * Delete a single item from a Collection.
     */
    async deleteItem(request, options) {
      return unwrapAsync(clientCollectionsDeleteItem(this, request, options));
    }
    /**
     * Update Collection
     *
     * @remarks
     * Update the properties of an existing Collection.
     */
    async update(request, options) {
      return unwrapAsync(clientCollectionsUpdate(this, request, options));
    }
    /**
     * Update Collection item
     *
     * @remarks
     * Update the URL, Glean Document ID, description of an item within a Collection given its ID.
     */
    async updateItem(request, options) {
      return unwrapAsync(clientCollectionsUpdateItem(this, request, options));
    }
    /**
     * Read Collection
     *
     * @remarks
     * Read the details of a Collection given its ID. Does not fetch items in this Collection.
     */
    async retrieve(request, options) {
      return unwrapAsync(clientCollectionsRetrieve(this, request, options));
    }
    /**
     * List Collections
     *
     * @remarks
     * List all existing Collections.
     */
    async list(request, options) {
      return unwrapAsync(clientCollectionsList(this, request, options));
    }
  };

  // node_modules/@gleanwork/api-client/dist/esm/funcs/clientEntitiesList.js
  function clientEntitiesList(client, request, options) {
    return new APIPromise($do44(client, request, options));
  }
  async function $do44(client, request, options) {
    const parsed = safeParse(request, (value) => ListEntitiesRequest$outboundSchema.parse(value), "Input validation failed");
    if (!parsed.ok) {
      return [parsed, { status: "invalid" }];
    }
    const payload = parsed.value;
    const body = encodeJSON("body", payload, { explode: true });
    const path = pathToFunc("/rest/api/v1/listentities")();
    const headers = new Headers(compactMap({
      "Content-Type": "application/json",
      Accept: "application/json"
    }));
    const secConfig = await extractSecurity(client._options.apiToken);
    const securityInput = secConfig == null ? {} : { apiToken: secConfig };
    const requestSecurity = resolveGlobalSecurity(securityInput);
    const context = {
      options: client._options,
      baseURL: options?.serverURL ?? client._baseURL ?? "",
      operationID: "listentities",
      oAuth2Scopes: [],
      resolvedSecurity: requestSecurity,
      securitySource: client._options.apiToken,
      retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
      retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
    };
    const requestRes = client._createRequest(context, {
      security: requestSecurity,
      method: "POST",
      baseURL: options?.serverURL,
      path,
      headers,
      body,
      userAgent: client._options.userAgent,
      timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
    }, options);
    if (!requestRes.ok) {
      return [requestRes, { status: "invalid" }];
    }
    const req = requestRes.value;
    const doResult = await client._do(req, {
      context,
      errorCodes: ["400", "401", "429", "4XX", "5XX"],
      retryConfig: context.retryConfig,
      retryCodes: context.retryCodes
    });
    if (!doResult.ok) {
      return [doResult, { status: "request-error", request: req }];
    }
    const response = doResult.value;
    const [result] = await match(json(200, ListEntitiesResponse$inboundSchema), fail([400, 401, 429, "4XX"]), fail("5XX"))(response, req);
    if (!result.ok) {
      return [result, { status: "complete", request: req, response }];
    }
    return [result, { status: "complete", request: req, response }];
  }

  // node_modules/@gleanwork/api-client/dist/esm/funcs/clientEntitiesReadPeople.js
  function clientEntitiesReadPeople(client, request, options) {
    return new APIPromise($do45(client, request, options));
  }
  async function $do45(client, request, options) {
    const parsed = safeParse(request, (value) => PeopleRequest$outboundSchema.parse(value), "Input validation failed");
    if (!parsed.ok) {
      return [parsed, { status: "invalid" }];
    }
    const payload = parsed.value;
    const body = encodeJSON("body", payload, { explode: true });
    const path = pathToFunc("/rest/api/v1/people")();
    const headers = new Headers(compactMap({
      "Content-Type": "application/json",
      Accept: "application/json"
    }));
    const secConfig = await extractSecurity(client._options.apiToken);
    const securityInput = secConfig == null ? {} : { apiToken: secConfig };
    const requestSecurity = resolveGlobalSecurity(securityInput);
    const context = {
      options: client._options,
      baseURL: options?.serverURL ?? client._baseURL ?? "",
      operationID: "people",
      oAuth2Scopes: [],
      resolvedSecurity: requestSecurity,
      securitySource: client._options.apiToken,
      retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
      retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
    };
    const requestRes = client._createRequest(context, {
      security: requestSecurity,
      method: "POST",
      baseURL: options?.serverURL,
      path,
      headers,
      body,
      userAgent: client._options.userAgent,
      timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
    }, options);
    if (!requestRes.ok) {
      return [requestRes, { status: "invalid" }];
    }
    const req = requestRes.value;
    const doResult = await client._do(req, {
      context,
      errorCodes: ["400", "401", "429", "4XX", "5XX"],
      retryConfig: context.retryConfig,
      retryCodes: context.retryCodes
    });
    if (!doResult.ok) {
      return [doResult, { status: "request-error", request: req }];
    }
    const response = doResult.value;
    const [result] = await match(json(200, PeopleResponse$inboundSchema), fail([400, 401, 429, "4XX"]), fail("5XX"))(response, req);
    if (!result.ok) {
      return [result, { status: "complete", request: req, response }];
    }
    return [result, { status: "complete", request: req, response }];
  }

  // node_modules/@gleanwork/api-client/dist/esm/sdk/entities.js
  var Entities = class extends ClientSDK {
    /**
     * List entities
     *
     * @remarks
     * List some set of details for all entities that fit the given criteria and return in the requested order. Does not support negation in filters, assumes relation type EQUALS. There is a limit of 10000 entities that can be retrieved via this endpoint, except when using FULL_DIRECTORY request type for people entities.
     */
    async list(request, options) {
      return unwrapAsync(clientEntitiesList(this, request, options));
    }
    /**
     * Read people
     *
     * @remarks
     * Read people details for the given IDs.
     */
    async readPeople(request, options) {
      return unwrapAsync(clientEntitiesReadPeople(this, request, options));
    }
  };

  // node_modules/@gleanwork/api-client/dist/esm/funcs/clientGovernanceDataPoliciesCreate.js
  function clientGovernanceDataPoliciesCreate(client, request, options) {
    return new APIPromise($do46(client, request, options));
  }
  async function $do46(client, request, options) {
    const parsed = safeParse(request, (value) => CreateDlpReportRequest$outboundSchema.parse(value), "Input validation failed");
    if (!parsed.ok) {
      return [parsed, { status: "invalid" }];
    }
    const payload = parsed.value;
    const body = encodeJSON("body", payload, { explode: true });
    const path = pathToFunc("/rest/api/v1/governance/data/policies")();
    const headers = new Headers(compactMap({
      "Content-Type": "application/json",
      Accept: "application/json; charset=UTF-8"
    }));
    const secConfig = await extractSecurity(client._options.apiToken);
    const securityInput = secConfig == null ? {} : { apiToken: secConfig };
    const requestSecurity = resolveGlobalSecurity(securityInput);
    const context = {
      options: client._options,
      baseURL: options?.serverURL ?? client._baseURL ?? "",
      operationID: "createpolicy",
      oAuth2Scopes: [],
      resolvedSecurity: requestSecurity,
      securitySource: client._options.apiToken,
      retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
      retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
    };
    const requestRes = client._createRequest(context, {
      security: requestSecurity,
      method: "POST",
      baseURL: options?.serverURL,
      path,
      headers,
      body,
      userAgent: client._options.userAgent,
      timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
    }, options);
    if (!requestRes.ok) {
      return [requestRes, { status: "invalid" }];
    }
    const req = requestRes.value;
    const doResult = await client._do(req, {
      context,
      errorCodes: ["403", "4XX", "500", "5XX"],
      retryConfig: context.retryConfig,
      retryCodes: context.retryCodes
    });
    if (!doResult.ok) {
      return [doResult, { status: "request-error", request: req }];
    }
    const response = doResult.value;
    const [result] = await match(json(200, CreateDlpReportResponse$inboundSchema, {
      ctype: "application/json; charset=UTF-8"
    }), fail([403, "4XX"]), fail([500, "5XX"]))(response, req);
    if (!result.ok) {
      return [result, { status: "complete", request: req, response }];
    }
    return [result, { status: "complete", request: req, response }];
  }

  // node_modules/@gleanwork/api-client/dist/esm/funcs/clientGovernanceDataPoliciesDownload.js
  function clientGovernanceDataPoliciesDownload(client, id, options) {
    return new APIPromise($do47(client, id, options));
  }
  async function $do47(client, id, options) {
    const input = {
      id
    };
    const parsed = safeParse(input, (value) => DownloadpolicycsvRequest$outboundSchema.parse(value), "Input validation failed");
    if (!parsed.ok) {
      return [parsed, { status: "invalid" }];
    }
    const payload = parsed.value;
    const body = null;
    const pathParams = {
      id: encodeSimple("id", payload.id, {
        explode: false,
        charEncoding: "percent"
      })
    };
    const path = pathToFunc("/rest/api/v1/governance/data/policies/{id}/download")(pathParams);
    const headers = new Headers(compactMap({
      Accept: "text/csv; charset=UTF-8"
    }));
    const secConfig = await extractSecurity(client._options.apiToken);
    const securityInput = secConfig == null ? {} : { apiToken: secConfig };
    const requestSecurity = resolveGlobalSecurity(securityInput);
    const context = {
      options: client._options,
      baseURL: options?.serverURL ?? client._baseURL ?? "",
      operationID: "downloadpolicycsv",
      oAuth2Scopes: [],
      resolvedSecurity: requestSecurity,
      securitySource: client._options.apiToken,
      retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
      retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
    };
    const requestRes = client._createRequest(context, {
      security: requestSecurity,
      method: "GET",
      baseURL: options?.serverURL,
      path,
      headers,
      body,
      userAgent: client._options.userAgent,
      timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
    }, options);
    if (!requestRes.ok) {
      return [requestRes, { status: "invalid" }];
    }
    const req = requestRes.value;
    const doResult = await client._do(req, {
      context,
      errorCodes: ["403", "4XX", "500", "5XX"],
      retryConfig: context.retryConfig,
      retryCodes: context.retryCodes
    });
    if (!doResult.ok) {
      return [doResult, { status: "request-error", request: req }];
    }
    const response = doResult.value;
    const [result] = await match(text(200, stringType(), { ctype: "text/csv; charset=UTF-8" }), fail([403, "4XX"]), fail([500, "5XX"]))(response, req);
    if (!result.ok) {
      return [result, { status: "complete", request: req, response }];
    }
    return [result, { status: "complete", request: req, response }];
  }

  // node_modules/@gleanwork/api-client/dist/esm/funcs/clientGovernanceDataPoliciesList.js
  function clientGovernanceDataPoliciesList(client, autoHide, frequency, options) {
    return new APIPromise($do48(client, autoHide, frequency, options));
  }
  async function $do48(client, autoHide, frequency, options) {
    const input = {
      autoHide,
      frequency
    };
    const parsed = safeParse(input, (value) => ListpoliciesRequest$outboundSchema.parse(value), "Input validation failed");
    if (!parsed.ok) {
      return [parsed, { status: "invalid" }];
    }
    const payload = parsed.value;
    const body = null;
    const path = pathToFunc("/rest/api/v1/governance/data/policies")();
    const query = encodeFormQuery({
      "autoHide": payload.autoHide,
      "frequency": payload.frequency
    });
    const headers = new Headers(compactMap({
      Accept: "application/json"
    }));
    const secConfig = await extractSecurity(client._options.apiToken);
    const securityInput = secConfig == null ? {} : { apiToken: secConfig };
    const requestSecurity = resolveGlobalSecurity(securityInput);
    const context = {
      options: client._options,
      baseURL: options?.serverURL ?? client._baseURL ?? "",
      operationID: "listpolicies",
      oAuth2Scopes: [],
      resolvedSecurity: requestSecurity,
      securitySource: client._options.apiToken,
      retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
      retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
    };
    const requestRes = client._createRequest(context, {
      security: requestSecurity,
      method: "GET",
      baseURL: options?.serverURL,
      path,
      headers,
      query,
      body,
      userAgent: client._options.userAgent,
      timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
    }, options);
    if (!requestRes.ok) {
      return [requestRes, { status: "invalid" }];
    }
    const req = requestRes.value;
    const doResult = await client._do(req, {
      context,
      errorCodes: ["403", "4XX", "500", "5XX"],
      retryConfig: context.retryConfig,
      retryCodes: context.retryCodes
    });
    if (!doResult.ok) {
      return [doResult, { status: "request-error", request: req }];
    }
    const response = doResult.value;
    const [result] = await match(json(200, ListDlpReportsResponse$inboundSchema), fail([403, "4XX"]), fail([500, "5XX"]))(response, req);
    if (!result.ok) {
      return [result, { status: "complete", request: req, response }];
    }
    return [result, { status: "complete", request: req, response }];
  }

  // node_modules/@gleanwork/api-client/dist/esm/funcs/clientGovernanceDataPoliciesRetrieve.js
  function clientGovernanceDataPoliciesRetrieve(client, id, version, options) {
    return new APIPromise($do49(client, id, version, options));
  }
  async function $do49(client, id, version, options) {
    const input = {
      id,
      version
    };
    const parsed = safeParse(input, (value) => GetpolicyRequest$outboundSchema.parse(value), "Input validation failed");
    if (!parsed.ok) {
      return [parsed, { status: "invalid" }];
    }
    const payload = parsed.value;
    const body = null;
    const pathParams = {
      id: encodeSimple("id", payload.id, {
        explode: false,
        charEncoding: "percent"
      })
    };
    const path = pathToFunc("/rest/api/v1/governance/data/policies/{id}")(pathParams);
    const query = encodeFormQuery({
      "version": payload.version
    });
    const headers = new Headers(compactMap({
      Accept: "application/json"
    }));
    const secConfig = await extractSecurity(client._options.apiToken);
    const securityInput = secConfig == null ? {} : { apiToken: secConfig };
    const requestSecurity = resolveGlobalSecurity(securityInput);
    const context = {
      options: client._options,
      baseURL: options?.serverURL ?? client._baseURL ?? "",
      operationID: "getpolicy",
      oAuth2Scopes: [],
      resolvedSecurity: requestSecurity,
      securitySource: client._options.apiToken,
      retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
      retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
    };
    const requestRes = client._createRequest(context, {
      security: requestSecurity,
      method: "GET",
      baseURL: options?.serverURL,
      path,
      headers,
      query,
      body,
      userAgent: client._options.userAgent,
      timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
    }, options);
    if (!requestRes.ok) {
      return [requestRes, { status: "invalid" }];
    }
    const req = requestRes.value;
    const doResult = await client._do(req, {
      context,
      errorCodes: ["403", "4XX", "500", "5XX"],
      retryConfig: context.retryConfig,
      retryCodes: context.retryCodes
    });
    if (!doResult.ok) {
      return [doResult, { status: "request-error", request: req }];
    }
    const response = doResult.value;
    const [result] = await match(json(200, GetDlpReportResponse$inboundSchema), fail([403, "4XX"]), fail([500, "5XX"]))(response, req);
    if (!result.ok) {
      return [result, { status: "complete", request: req, response }];
    }
    return [result, { status: "complete", request: req, response }];
  }

  // node_modules/@gleanwork/api-client/dist/esm/funcs/clientGovernanceDataPoliciesUpdate.js
  function clientGovernanceDataPoliciesUpdate(client, updateDlpReportRequest, id, options) {
    return new APIPromise($do50(client, updateDlpReportRequest, id, options));
  }
  async function $do50(client, updateDlpReportRequest, id, options) {
    const input = {
      updateDlpReportRequest,
      id
    };
    const parsed = safeParse(input, (value) => UpdatepolicyRequest$outboundSchema.parse(value), "Input validation failed");
    if (!parsed.ok) {
      return [parsed, { status: "invalid" }];
    }
    const payload = parsed.value;
    const body = encodeJSON("body", payload.UpdateDlpReportRequest, {
      explode: true
    });
    const pathParams = {
      id: encodeSimple("id", payload.id, {
        explode: false,
        charEncoding: "percent"
      })
    };
    const path = pathToFunc("/rest/api/v1/governance/data/policies/{id}")(pathParams);
    const headers = new Headers(compactMap({
      "Content-Type": "application/json",
      Accept: "application/json; charset=UTF-8"
    }));
    const secConfig = await extractSecurity(client._options.apiToken);
    const securityInput = secConfig == null ? {} : { apiToken: secConfig };
    const requestSecurity = resolveGlobalSecurity(securityInput);
    const context = {
      options: client._options,
      baseURL: options?.serverURL ?? client._baseURL ?? "",
      operationID: "updatepolicy",
      oAuth2Scopes: [],
      resolvedSecurity: requestSecurity,
      securitySource: client._options.apiToken,
      retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
      retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
    };
    const requestRes = client._createRequest(context, {
      security: requestSecurity,
      method: "POST",
      baseURL: options?.serverURL,
      path,
      headers,
      body,
      userAgent: client._options.userAgent,
      timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
    }, options);
    if (!requestRes.ok) {
      return [requestRes, { status: "invalid" }];
    }
    const req = requestRes.value;
    const doResult = await client._do(req, {
      context,
      errorCodes: ["403", "4XX", "500", "5XX"],
      retryConfig: context.retryConfig,
      retryCodes: context.retryCodes
    });
    if (!doResult.ok) {
      return [doResult, { status: "request-error", request: req }];
    }
    const response = doResult.value;
    const [result] = await match(json(200, UpdateDlpReportResponse$inboundSchema, {
      ctype: "application/json; charset=UTF-8"
    }), fail([403, "4XX"]), fail([500, "5XX"]))(response, req);
    if (!result.ok) {
      return [result, { status: "complete", request: req, response }];
    }
    return [result, { status: "complete", request: req, response }];
  }

  // node_modules/@gleanwork/api-client/dist/esm/sdk/policies.js
  var Policies = class extends ClientSDK {
    /**
     * Gets specified policy
     *
     * @remarks
     * Fetches the specified policy version, or the latest if no version is provided.
     */
    async retrieve(id, version, options) {
      return unwrapAsync(clientGovernanceDataPoliciesRetrieve(this, id, version, options));
    }
    /**
     * Updates an existing policy
     *
     * @remarks
     * Updates an existing policy.
     */
    async update(updateDlpReportRequest, id, options) {
      return unwrapAsync(clientGovernanceDataPoliciesUpdate(this, updateDlpReportRequest, id, options));
    }
    /**
     * Lists policies
     *
     * @remarks
     * Lists policies with filtering.
     */
    async list(autoHide, frequency, options) {
      return unwrapAsync(clientGovernanceDataPoliciesList(this, autoHide, frequency, options));
    }
    /**
     * Creates new policy
     *
     * @remarks
     * Creates a new policy with specified specifications and returns its id.
     */
    async create(request, options) {
      return unwrapAsync(clientGovernanceDataPoliciesCreate(this, request, options));
    }
    /**
     * Downloads violations CSV for policy
     *
     * @remarks
     * Downloads CSV violations report for a specific policy id. This does not support continuous policies.
     */
    async download(id, options) {
      return unwrapAsync(clientGovernanceDataPoliciesDownload(this, id, options));
    }
  };

  // node_modules/@gleanwork/api-client/dist/esm/funcs/clientGovernanceDataReportsCreate.js
  function clientGovernanceDataReportsCreate(client, request, options) {
    return new APIPromise($do51(client, request, options));
  }
  async function $do51(client, request, options) {
    const parsed = safeParse(request, (value) => UpdateDlpConfigRequest$outboundSchema.parse(value), "Input validation failed");
    if (!parsed.ok) {
      return [parsed, { status: "invalid" }];
    }
    const payload = parsed.value;
    const body = encodeJSON("body", payload, { explode: true });
    const path = pathToFunc("/rest/api/v1/governance/data/reports")();
    const headers = new Headers(compactMap({
      "Content-Type": "application/json",
      Accept: "application/json; charset=UTF-8"
    }));
    const secConfig = await extractSecurity(client._options.apiToken);
    const securityInput = secConfig == null ? {} : { apiToken: secConfig };
    const requestSecurity = resolveGlobalSecurity(securityInput);
    const context = {
      options: client._options,
      baseURL: options?.serverURL ?? client._baseURL ?? "",
      operationID: "createreport",
      oAuth2Scopes: [],
      resolvedSecurity: requestSecurity,
      securitySource: client._options.apiToken,
      retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
      retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
    };
    const requestRes = client._createRequest(context, {
      security: requestSecurity,
      method: "POST",
      baseURL: options?.serverURL,
      path,
      headers,
      body,
      userAgent: client._options.userAgent,
      timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
    }, options);
    if (!requestRes.ok) {
      return [requestRes, { status: "invalid" }];
    }
    const req = requestRes.value;
    const doResult = await client._do(req, {
      context,
      errorCodes: ["403", "4XX", "500", "5XX"],
      retryConfig: context.retryConfig,
      retryCodes: context.retryCodes
    });
    if (!doResult.ok) {
      return [doResult, { status: "request-error", request: req }];
    }
    const response = doResult.value;
    const [result] = await match(json(200, UpdateDlpConfigResponse$inboundSchema, {
      ctype: "application/json; charset=UTF-8"
    }), fail([403, "4XX"]), fail([500, "5XX"]))(response, req);
    if (!result.ok) {
      return [result, { status: "complete", request: req, response }];
    }
    return [result, { status: "complete", request: req, response }];
  }

  // node_modules/@gleanwork/api-client/dist/esm/funcs/clientGovernanceDataReportsDownload.js
  function clientGovernanceDataReportsDownload(client, id, options) {
    return new APIPromise($do52(client, id, options));
  }
  async function $do52(client, id, options) {
    const input = {
      id
    };
    const parsed = safeParse(input, (value) => DownloadreportcsvRequest$outboundSchema.parse(value), "Input validation failed");
    if (!parsed.ok) {
      return [parsed, { status: "invalid" }];
    }
    const payload = parsed.value;
    const body = null;
    const pathParams = {
      id: encodeSimple("id", payload.id, {
        explode: false,
        charEncoding: "percent"
      })
    };
    const path = pathToFunc("/rest/api/v1/governance/data/reports/{id}/download")(pathParams);
    const headers = new Headers(compactMap({
      Accept: "text/csv; charset=UTF-8"
    }));
    const secConfig = await extractSecurity(client._options.apiToken);
    const securityInput = secConfig == null ? {} : { apiToken: secConfig };
    const requestSecurity = resolveGlobalSecurity(securityInput);
    const context = {
      options: client._options,
      baseURL: options?.serverURL ?? client._baseURL ?? "",
      operationID: "downloadreportcsv",
      oAuth2Scopes: [],
      resolvedSecurity: requestSecurity,
      securitySource: client._options.apiToken,
      retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
      retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
    };
    const requestRes = client._createRequest(context, {
      security: requestSecurity,
      method: "GET",
      baseURL: options?.serverURL,
      path,
      headers,
      body,
      userAgent: client._options.userAgent,
      timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
    }, options);
    if (!requestRes.ok) {
      return [requestRes, { status: "invalid" }];
    }
    const req = requestRes.value;
    const doResult = await client._do(req, {
      context,
      errorCodes: ["403", "4XX", "500", "5XX"],
      retryConfig: context.retryConfig,
      retryCodes: context.retryCodes
    });
    if (!doResult.ok) {
      return [doResult, { status: "request-error", request: req }];
    }
    const response = doResult.value;
    const [result] = await match(text(200, stringType(), { ctype: "text/csv; charset=UTF-8" }), fail([403, "4XX"]), fail([500, "5XX"]))(response, req);
    if (!result.ok) {
      return [result, { status: "complete", request: req, response }];
    }
    return [result, { status: "complete", request: req, response }];
  }

  // node_modules/@gleanwork/api-client/dist/esm/funcs/clientGovernanceDataReportsStatus.js
  function clientGovernanceDataReportsStatus(client, id, options) {
    return new APIPromise($do53(client, id, options));
  }
  async function $do53(client, id, options) {
    const input = {
      id
    };
    const parsed = safeParse(input, (value) => GetreportstatusRequest$outboundSchema.parse(value), "Input validation failed");
    if (!parsed.ok) {
      return [parsed, { status: "invalid" }];
    }
    const payload = parsed.value;
    const body = null;
    const pathParams = {
      id: encodeSimple("id", payload.id, {
        explode: false,
        charEncoding: "percent"
      })
    };
    const path = pathToFunc("/rest/api/v1/governance/data/reports/{id}/status")(pathParams);
    const headers = new Headers(compactMap({
      Accept: "application/json; charset=UTF-8"
    }));
    const secConfig = await extractSecurity(client._options.apiToken);
    const securityInput = secConfig == null ? {} : { apiToken: secConfig };
    const requestSecurity = resolveGlobalSecurity(securityInput);
    const context = {
      options: client._options,
      baseURL: options?.serverURL ?? client._baseURL ?? "",
      operationID: "getreportstatus",
      oAuth2Scopes: [],
      resolvedSecurity: requestSecurity,
      securitySource: client._options.apiToken,
      retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
      retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
    };
    const requestRes = client._createRequest(context, {
      security: requestSecurity,
      method: "GET",
      baseURL: options?.serverURL,
      path,
      headers,
      body,
      userAgent: client._options.userAgent,
      timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
    }, options);
    if (!requestRes.ok) {
      return [requestRes, { status: "invalid" }];
    }
    const req = requestRes.value;
    const doResult = await client._do(req, {
      context,
      errorCodes: ["403", "4XX", "500", "5XX"],
      retryConfig: context.retryConfig,
      retryCodes: context.retryCodes
    });
    if (!doResult.ok) {
      return [doResult, { status: "request-error", request: req }];
    }
    const response = doResult.value;
    const [result] = await match(json(200, ReportStatusResponse$inboundSchema, {
      ctype: "application/json; charset=UTF-8"
    }), fail([403, "4XX"]), fail([500, "5XX"]))(response, req);
    if (!result.ok) {
      return [result, { status: "complete", request: req, response }];
    }
    return [result, { status: "complete", request: req, response }];
  }

  // node_modules/@gleanwork/api-client/dist/esm/sdk/reports.js
  var Reports = class extends ClientSDK {
    /**
     * Creates new one-time report
     *
     * @remarks
     * Creates a new one-time report and executes its batch job.
     */
    async create(request, options) {
      return unwrapAsync(clientGovernanceDataReportsCreate(this, request, options));
    }
    /**
     * Downloads violations CSV for report
     *
     * @remarks
     * Downloads CSV violations report for a specific report id.
     */
    async download(id, options) {
      return unwrapAsync(clientGovernanceDataReportsDownload(this, id, options));
    }
    /**
     * Fetches report run status
     *
     * @remarks
     * Fetches the status of the run corresponding to the report-id.
     */
    async status(id, options) {
      return unwrapAsync(clientGovernanceDataReportsStatus(this, id, options));
    }
  };

  // node_modules/@gleanwork/api-client/dist/esm/sdk/data.js
  var Data = class extends ClientSDK {
    get policies() {
      return this._policies ?? (this._policies = new Policies(this._options));
    }
    get reports() {
      return this._reports ?? (this._reports = new Reports(this._options));
    }
  };

  // node_modules/@gleanwork/api-client/dist/esm/funcs/clientGovernanceDocumentsVisibilityoverridesCreate.js
  function clientGovernanceDocumentsVisibilityoverridesCreate(client, request, options) {
    return new APIPromise($do54(client, request, options));
  }
  async function $do54(client, request, options) {
    const parsed = safeParse(request, (value) => UpdateDocumentVisibilityOverridesRequest$outboundSchema.parse(value), "Input validation failed");
    if (!parsed.ok) {
      return [parsed, { status: "invalid" }];
    }
    const payload = parsed.value;
    const body = encodeJSON("body", payload, { explode: true });
    const path = pathToFunc("/rest/api/v1/governance/documents/visibilityoverrides")();
    const headers = new Headers(compactMap({
      "Content-Type": "application/json",
      Accept: "application/json; charset=UTF-8"
    }));
    const secConfig = await extractSecurity(client._options.apiToken);
    const securityInput = secConfig == null ? {} : { apiToken: secConfig };
    const requestSecurity = resolveGlobalSecurity(securityInput);
    const context = {
      options: client._options,
      baseURL: options?.serverURL ?? client._baseURL ?? "",
      operationID: "setdocvisibility",
      oAuth2Scopes: [],
      resolvedSecurity: requestSecurity,
      securitySource: client._options.apiToken,
      retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
      retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
    };
    const requestRes = client._createRequest(context, {
      security: requestSecurity,
      method: "POST",
      baseURL: options?.serverURL,
      path,
      headers,
      body,
      userAgent: client._options.userAgent,
      timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
    }, options);
    if (!requestRes.ok) {
      return [requestRes, { status: "invalid" }];
    }
    const req = requestRes.value;
    const doResult = await client._do(req, {
      context,
      errorCodes: ["403", "4XX", "500", "5XX"],
      retryConfig: context.retryConfig,
      retryCodes: context.retryCodes
    });
    if (!doResult.ok) {
      return [doResult, { status: "request-error", request: req }];
    }
    const response = doResult.value;
    const [result] = await match(json(200, UpdateDocumentVisibilityOverridesResponse$inboundSchema, { ctype: "application/json; charset=UTF-8" }), fail([403, "4XX"]), fail([500, "5XX"]))(response, req);
    if (!result.ok) {
      return [result, { status: "complete", request: req, response }];
    }
    return [result, { status: "complete", request: req, response }];
  }

  // node_modules/@gleanwork/api-client/dist/esm/funcs/clientGovernanceDocumentsVisibilityoverridesList.js
  function clientGovernanceDocumentsVisibilityoverridesList(client, docIds, options) {
    return new APIPromise($do55(client, docIds, options));
  }
  async function $do55(client, docIds, options) {
    const input = {
      docIds
    };
    const parsed = safeParse(input, (value) => GetdocvisibilityRequest$outboundSchema.parse(value), "Input validation failed");
    if (!parsed.ok) {
      return [parsed, { status: "invalid" }];
    }
    const payload = parsed.value;
    const body = null;
    const path = pathToFunc("/rest/api/v1/governance/documents/visibilityoverrides")();
    const query = encodeFormQuery({
      "docIds": payload.docIds
    });
    const headers = new Headers(compactMap({
      Accept: "application/json; charset=UTF-8"
    }));
    const secConfig = await extractSecurity(client._options.apiToken);
    const securityInput = secConfig == null ? {} : { apiToken: secConfig };
    const requestSecurity = resolveGlobalSecurity(securityInput);
    const context = {
      options: client._options,
      baseURL: options?.serverURL ?? client._baseURL ?? "",
      operationID: "getdocvisibility",
      oAuth2Scopes: [],
      resolvedSecurity: requestSecurity,
      securitySource: client._options.apiToken,
      retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
      retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
    };
    const requestRes = client._createRequest(context, {
      security: requestSecurity,
      method: "GET",
      baseURL: options?.serverURL,
      path,
      headers,
      query,
      body,
      userAgent: client._options.userAgent,
      timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
    }, options);
    if (!requestRes.ok) {
      return [requestRes, { status: "invalid" }];
    }
    const req = requestRes.value;
    const doResult = await client._do(req, {
      context,
      errorCodes: ["403", "4XX", "500", "5XX"],
      retryConfig: context.retryConfig,
      retryCodes: context.retryCodes
    });
    if (!doResult.ok) {
      return [doResult, { status: "request-error", request: req }];
    }
    const response = doResult.value;
    const [result] = await match(json(200, GetDocumentVisibilityOverridesResponse$inboundSchema, { ctype: "application/json; charset=UTF-8" }), fail([403, "4XX"]), fail([500, "5XX"]))(response, req);
    if (!result.ok) {
      return [result, { status: "complete", request: req, response }];
    }
    return [result, { status: "complete", request: req, response }];
  }

  // node_modules/@gleanwork/api-client/dist/esm/sdk/visibilityoverrides.js
  var Visibilityoverrides = class extends ClientSDK {
    /**
     * Fetches documents visibility
     *
     * @remarks
     * Fetches the visibility override status of the documents passed.
     */
    async list(docIds, options) {
      return unwrapAsync(clientGovernanceDocumentsVisibilityoverridesList(this, docIds, options));
    }
    /**
     * Hide or unhide docs
     *
     * @remarks
     * Sets the visibility-override state of the documents specified, effectively hiding or un-hiding documents.
     */
    async create(request, options) {
      return unwrapAsync(clientGovernanceDocumentsVisibilityoverridesCreate(this, request, options));
    }
  };

  // node_modules/@gleanwork/api-client/dist/esm/sdk/governancedocuments.js
  var GovernanceDocuments = class extends ClientSDK {
    get visibilityoverrides() {
      return this._visibilityoverrides ?? (this._visibilityoverrides = new Visibilityoverrides(this._options));
    }
  };

  // node_modules/@gleanwork/api-client/dist/esm/sdk/governance.js
  var Governance = class extends ClientSDK {
    get data() {
      return this._data ?? (this._data = new Data(this._options));
    }
    get documents() {
      return this._documents ?? (this._documents = new GovernanceDocuments(this._options));
    }
  };

  // node_modules/@gleanwork/api-client/dist/esm/funcs/clientInsightsRetrieve.js
  function clientInsightsRetrieve(client, request, options) {
    return new APIPromise($do56(client, request, options));
  }
  async function $do56(client, request, options) {
    const parsed = safeParse(request, (value) => InsightsRequest$outboundSchema.parse(value), "Input validation failed");
    if (!parsed.ok) {
      return [parsed, { status: "invalid" }];
    }
    const payload = parsed.value;
    const body = encodeJSON("body", payload, { explode: true });
    const path = pathToFunc("/rest/api/v1/insights")();
    const headers = new Headers(compactMap({
      "Content-Type": "application/json",
      Accept: "application/json"
    }));
    const secConfig = await extractSecurity(client._options.apiToken);
    const securityInput = secConfig == null ? {} : { apiToken: secConfig };
    const requestSecurity = resolveGlobalSecurity(securityInput);
    const context = {
      options: client._options,
      baseURL: options?.serverURL ?? client._baseURL ?? "",
      operationID: "insights",
      oAuth2Scopes: [],
      resolvedSecurity: requestSecurity,
      securitySource: client._options.apiToken,
      retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
      retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
    };
    const requestRes = client._createRequest(context, {
      security: requestSecurity,
      method: "POST",
      baseURL: options?.serverURL,
      path,
      headers,
      body,
      userAgent: client._options.userAgent,
      timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
    }, options);
    if (!requestRes.ok) {
      return [requestRes, { status: "invalid" }];
    }
    const req = requestRes.value;
    const doResult = await client._do(req, {
      context,
      errorCodes: ["400", "401", "429", "4XX", "5XX"],
      retryConfig: context.retryConfig,
      retryCodes: context.retryCodes
    });
    if (!doResult.ok) {
      return [doResult, { status: "request-error", request: req }];
    }
    const response = doResult.value;
    const [result] = await match(json(200, InsightsResponse$inboundSchema), fail([400, 401, 429, "4XX"]), fail("5XX"))(response, req);
    if (!result.ok) {
      return [result, { status: "complete", request: req, response }];
    }
    return [result, { status: "complete", request: req, response }];
  }

  // node_modules/@gleanwork/api-client/dist/esm/sdk/insights.js
  var Insights = class extends ClientSDK {
    /**
     * Get insights
     *
     * @remarks
     * Gets the aggregate usage insights data displayed in the Insights Dashboards.
     */
    async retrieve(request, options) {
      return unwrapAsync(clientInsightsRetrieve(this, request, options));
    }
  };

  // node_modules/@gleanwork/api-client/dist/esm/funcs/clientMessagesRetrieve.js
  function clientMessagesRetrieve(client, request, options) {
    return new APIPromise($do57(client, request, options));
  }
  async function $do57(client, request, options) {
    const parsed = safeParse(request, (value) => MessagesRequest$outboundSchema.parse(value), "Input validation failed");
    if (!parsed.ok) {
      return [parsed, { status: "invalid" }];
    }
    const payload = parsed.value;
    const body = encodeJSON("body", payload, { explode: true });
    const path = pathToFunc("/rest/api/v1/messages")();
    const headers = new Headers(compactMap({
      "Content-Type": "application/json",
      Accept: "application/json"
    }));
    const secConfig = await extractSecurity(client._options.apiToken);
    const securityInput = secConfig == null ? {} : { apiToken: secConfig };
    const requestSecurity = resolveGlobalSecurity(securityInput);
    const context = {
      options: client._options,
      baseURL: options?.serverURL ?? client._baseURL ?? "",
      operationID: "messages",
      oAuth2Scopes: [],
      resolvedSecurity: requestSecurity,
      securitySource: client._options.apiToken,
      retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
      retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
    };
    const requestRes = client._createRequest(context, {
      security: requestSecurity,
      method: "POST",
      baseURL: options?.serverURL,
      path,
      headers,
      body,
      userAgent: client._options.userAgent,
      timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
    }, options);
    if (!requestRes.ok) {
      return [requestRes, { status: "invalid" }];
    }
    const req = requestRes.value;
    const doResult = await client._do(req, {
      context,
      errorCodes: ["400", "401", "429", "4XX", "5XX"],
      retryConfig: context.retryConfig,
      retryCodes: context.retryCodes
    });
    if (!doResult.ok) {
      return [doResult, { status: "request-error", request: req }];
    }
    const response = doResult.value;
    const [result] = await match(json(200, MessagesResponse$inboundSchema), fail([400, 401, 429, "4XX"]), fail("5XX"))(response, req);
    if (!result.ok) {
      return [result, { status: "complete", request: req, response }];
    }
    return [result, { status: "complete", request: req, response }];
  }

  // node_modules/@gleanwork/api-client/dist/esm/sdk/messages.js
  var Messages = class extends ClientSDK {
    /**
     * Read messages
     *
     * @remarks
     * Retrieves list of messages from messaging/chat datasources (e.g. Slack, Teams).
     */
    async retrieve(request, options) {
      return unwrapAsync(clientMessagesRetrieve(this, request, options));
    }
  };

  // node_modules/@gleanwork/api-client/dist/esm/funcs/clientPinsCreate.js
  function clientPinsCreate(client, request, options) {
    return new APIPromise($do58(client, request, options));
  }
  async function $do58(client, request, options) {
    const parsed = safeParse(request, (value) => PinRequest$outboundSchema.parse(value), "Input validation failed");
    if (!parsed.ok) {
      return [parsed, { status: "invalid" }];
    }
    const payload = parsed.value;
    const body = encodeJSON("body", payload, { explode: true });
    const path = pathToFunc("/rest/api/v1/pin")();
    const headers = new Headers(compactMap({
      "Content-Type": "application/json",
      Accept: "application/json"
    }));
    const secConfig = await extractSecurity(client._options.apiToken);
    const securityInput = secConfig == null ? {} : { apiToken: secConfig };
    const requestSecurity = resolveGlobalSecurity(securityInput);
    const context = {
      options: client._options,
      baseURL: options?.serverURL ?? client._baseURL ?? "",
      operationID: "pin",
      oAuth2Scopes: [],
      resolvedSecurity: requestSecurity,
      securitySource: client._options.apiToken,
      retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
      retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
    };
    const requestRes = client._createRequest(context, {
      security: requestSecurity,
      method: "POST",
      baseURL: options?.serverURL,
      path,
      headers,
      body,
      userAgent: client._options.userAgent,
      timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
    }, options);
    if (!requestRes.ok) {
      return [requestRes, { status: "invalid" }];
    }
    const req = requestRes.value;
    const doResult = await client._do(req, {
      context,
      errorCodes: ["400", "401", "429", "4XX", "5XX"],
      retryConfig: context.retryConfig,
      retryCodes: context.retryCodes
    });
    if (!doResult.ok) {
      return [doResult, { status: "request-error", request: req }];
    }
    const response = doResult.value;
    const [result] = await match(json(200, PinDocument$inboundSchema), fail([400, 401, 429, "4XX"]), fail("5XX"))(response, req);
    if (!result.ok) {
      return [result, { status: "complete", request: req, response }];
    }
    return [result, { status: "complete", request: req, response }];
  }

  // node_modules/@gleanwork/api-client/dist/esm/funcs/clientPinsList.js
  function clientPinsList(client, _request, options) {
    return new APIPromise($do59(client, _request, options));
  }
  async function $do59(client, _request, options) {
    const path = pathToFunc("/rest/api/v1/listpins")();
    const headers = new Headers(compactMap({
      "Content-Type": "application/json",
      Accept: "application/json"
    }));
    const secConfig = await extractSecurity(client._options.apiToken);
    const securityInput = secConfig == null ? {} : { apiToken: secConfig };
    const requestSecurity = resolveGlobalSecurity(securityInput);
    const context = {
      options: client._options,
      baseURL: options?.serverURL ?? client._baseURL ?? "",
      operationID: "listpins",
      oAuth2Scopes: [],
      resolvedSecurity: requestSecurity,
      securitySource: client._options.apiToken,
      retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
      retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
    };
    const requestRes = client._createRequest(context, {
      security: requestSecurity,
      method: "POST",
      baseURL: options?.serverURL,
      path,
      headers,
      userAgent: client._options.userAgent,
      timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
    }, options);
    if (!requestRes.ok) {
      return [requestRes, { status: "invalid" }];
    }
    const req = requestRes.value;
    const doResult = await client._do(req, {
      context,
      errorCodes: ["400", "401", "429", "4XX", "5XX"],
      retryConfig: context.retryConfig,
      retryCodes: context.retryCodes
    });
    if (!doResult.ok) {
      return [doResult, { status: "request-error", request: req }];
    }
    const response = doResult.value;
    const [result] = await match(json(200, ListPinsResponse$inboundSchema), fail([400, 401, 429, "4XX"]), fail("5XX"))(response, req);
    if (!result.ok) {
      return [result, { status: "complete", request: req, response }];
    }
    return [result, { status: "complete", request: req, response }];
  }

  // node_modules/@gleanwork/api-client/dist/esm/funcs/clientPinsRemove.js
  function clientPinsRemove(client, request, options) {
    return new APIPromise($do60(client, request, options));
  }
  async function $do60(client, request, options) {
    const parsed = safeParse(request, (value) => Unpin$outboundSchema.parse(value), "Input validation failed");
    if (!parsed.ok) {
      return [parsed, { status: "invalid" }];
    }
    const payload = parsed.value;
    const body = encodeJSON("body", payload, { explode: true });
    const path = pathToFunc("/rest/api/v1/unpin")();
    const headers = new Headers(compactMap({
      "Content-Type": "application/json",
      Accept: "*/*"
    }));
    const secConfig = await extractSecurity(client._options.apiToken);
    const securityInput = secConfig == null ? {} : { apiToken: secConfig };
    const requestSecurity = resolveGlobalSecurity(securityInput);
    const context = {
      options: client._options,
      baseURL: options?.serverURL ?? client._baseURL ?? "",
      operationID: "unpin",
      oAuth2Scopes: [],
      resolvedSecurity: requestSecurity,
      securitySource: client._options.apiToken,
      retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
      retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
    };
    const requestRes = client._createRequest(context, {
      security: requestSecurity,
      method: "POST",
      baseURL: options?.serverURL,
      path,
      headers,
      body,
      userAgent: client._options.userAgent,
      timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
    }, options);
    if (!requestRes.ok) {
      return [requestRes, { status: "invalid" }];
    }
    const req = requestRes.value;
    const doResult = await client._do(req, {
      context,
      errorCodes: ["400", "401", "403", "429", "4XX", "5XX"],
      retryConfig: context.retryConfig,
      retryCodes: context.retryCodes
    });
    if (!doResult.ok) {
      return [doResult, { status: "request-error", request: req }];
    }
    const response = doResult.value;
    const [result] = await match(nil(200, voidType()), fail([400, 401, 403, 429, "4XX"]), fail("5XX"))(response, req);
    if (!result.ok) {
      return [result, { status: "complete", request: req, response }];
    }
    return [result, { status: "complete", request: req, response }];
  }

  // node_modules/@gleanwork/api-client/dist/esm/funcs/clientPinsRetrieve.js
  function clientPinsRetrieve(client, request, options) {
    return new APIPromise($do61(client, request, options));
  }
  async function $do61(client, request, options) {
    const parsed = safeParse(request, (value) => GetPinRequest$outboundSchema.parse(value), "Input validation failed");
    if (!parsed.ok) {
      return [parsed, { status: "invalid" }];
    }
    const payload = parsed.value;
    const body = encodeJSON("body", payload, { explode: true });
    const path = pathToFunc("/rest/api/v1/getpin")();
    const headers = new Headers(compactMap({
      "Content-Type": "application/json",
      Accept: "application/json"
    }));
    const secConfig = await extractSecurity(client._options.apiToken);
    const securityInput = secConfig == null ? {} : { apiToken: secConfig };
    const requestSecurity = resolveGlobalSecurity(securityInput);
    const context = {
      options: client._options,
      baseURL: options?.serverURL ?? client._baseURL ?? "",
      operationID: "getpin",
      oAuth2Scopes: [],
      resolvedSecurity: requestSecurity,
      securitySource: client._options.apiToken,
      retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
      retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
    };
    const requestRes = client._createRequest(context, {
      security: requestSecurity,
      method: "POST",
      baseURL: options?.serverURL,
      path,
      headers,
      body,
      userAgent: client._options.userAgent,
      timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
    }, options);
    if (!requestRes.ok) {
      return [requestRes, { status: "invalid" }];
    }
    const req = requestRes.value;
    const doResult = await client._do(req, {
      context,
      errorCodes: ["400", "401", "429", "4XX", "5XX"],
      retryConfig: context.retryConfig,
      retryCodes: context.retryCodes
    });
    if (!doResult.ok) {
      return [doResult, { status: "request-error", request: req }];
    }
    const response = doResult.value;
    const [result] = await match(json(200, GetPinResponse$inboundSchema), fail([400, 401, 429, "4XX"]), fail("5XX"))(response, req);
    if (!result.ok) {
      return [result, { status: "complete", request: req, response }];
    }
    return [result, { status: "complete", request: req, response }];
  }

  // node_modules/@gleanwork/api-client/dist/esm/funcs/clientPinsUpdate.js
  function clientPinsUpdate(client, request, options) {
    return new APIPromise($do62(client, request, options));
  }
  async function $do62(client, request, options) {
    const parsed = safeParse(request, (value) => EditPinRequest$outboundSchema.parse(value), "Input validation failed");
    if (!parsed.ok) {
      return [parsed, { status: "invalid" }];
    }
    const payload = parsed.value;
    const body = encodeJSON("body", payload, { explode: true });
    const path = pathToFunc("/rest/api/v1/editpin")();
    const headers = new Headers(compactMap({
      "Content-Type": "application/json",
      Accept: "application/json"
    }));
    const secConfig = await extractSecurity(client._options.apiToken);
    const securityInput = secConfig == null ? {} : { apiToken: secConfig };
    const requestSecurity = resolveGlobalSecurity(securityInput);
    const context = {
      options: client._options,
      baseURL: options?.serverURL ?? client._baseURL ?? "",
      operationID: "editpin",
      oAuth2Scopes: [],
      resolvedSecurity: requestSecurity,
      securitySource: client._options.apiToken,
      retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
      retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
    };
    const requestRes = client._createRequest(context, {
      security: requestSecurity,
      method: "POST",
      baseURL: options?.serverURL,
      path,
      headers,
      body,
      userAgent: client._options.userAgent,
      timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
    }, options);
    if (!requestRes.ok) {
      return [requestRes, { status: "invalid" }];
    }
    const req = requestRes.value;
    const doResult = await client._do(req, {
      context,
      errorCodes: ["400", "401", "429", "4XX", "5XX"],
      retryConfig: context.retryConfig,
      retryCodes: context.retryCodes
    });
    if (!doResult.ok) {
      return [doResult, { status: "request-error", request: req }];
    }
    const response = doResult.value;
    const [result] = await match(json(200, PinDocument$inboundSchema), fail([400, 401, 429, "4XX"]), fail("5XX"))(response, req);
    if (!result.ok) {
      return [result, { status: "complete", request: req, response }];
    }
    return [result, { status: "complete", request: req, response }];
  }

  // node_modules/@gleanwork/api-client/dist/esm/sdk/pins.js
  var Pins = class extends ClientSDK {
    /**
     * Update pin
     *
     * @remarks
     * Update an existing user-generated pin.
     */
    async update(request, options) {
      return unwrapAsync(clientPinsUpdate(this, request, options));
    }
    /**
     * Read pin
     *
     * @remarks
     * Read pin details given its ID.
     */
    async retrieve(request, options) {
      return unwrapAsync(clientPinsRetrieve(this, request, options));
    }
    /**
     * List pins
     *
     * @remarks
     * Lists all pins.
     */
    async list(request, options) {
      return unwrapAsync(clientPinsList(this, request, options));
    }
    /**
     * Create pin
     *
     * @remarks
     * Pin a document as a result for a given search query.Pin results that are known to be a good match.
     */
    async create(request, options) {
      return unwrapAsync(clientPinsCreate(this, request, options));
    }
    /**
     * Delete pin
     *
     * @remarks
     * Unpin a previously pinned result.
     */
    async remove(request, options) {
      return unwrapAsync(clientPinsRemove(this, request, options));
    }
  };

  // node_modules/@gleanwork/api-client/dist/esm/funcs/clientSearchAutocomplete.js
  function clientSearchAutocomplete(client, request, options) {
    return new APIPromise($do63(client, request, options));
  }
  async function $do63(client, request, options) {
    const parsed = safeParse(request, (value) => AutocompleteRequest$outboundSchema.parse(value), "Input validation failed");
    if (!parsed.ok) {
      return [parsed, { status: "invalid" }];
    }
    const payload = parsed.value;
    const body = encodeJSON("body", payload, { explode: true });
    const path = pathToFunc("/rest/api/v1/autocomplete")();
    const headers = new Headers(compactMap({
      "Content-Type": "application/json",
      Accept: "application/json"
    }));
    const secConfig = await extractSecurity(client._options.apiToken);
    const securityInput = secConfig == null ? {} : { apiToken: secConfig };
    const requestSecurity = resolveGlobalSecurity(securityInput);
    const context = {
      options: client._options,
      baseURL: options?.serverURL ?? client._baseURL ?? "",
      operationID: "autocomplete",
      oAuth2Scopes: [],
      resolvedSecurity: requestSecurity,
      securitySource: client._options.apiToken,
      retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
      retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
    };
    const requestRes = client._createRequest(context, {
      security: requestSecurity,
      method: "POST",
      baseURL: options?.serverURL,
      path,
      headers,
      body,
      userAgent: client._options.userAgent,
      timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
    }, options);
    if (!requestRes.ok) {
      return [requestRes, { status: "invalid" }];
    }
    const req = requestRes.value;
    const doResult = await client._do(req, {
      context,
      errorCodes: ["400", "401", "429", "4XX", "5XX"],
      retryConfig: context.retryConfig,
      retryCodes: context.retryCodes
    });
    if (!doResult.ok) {
      return [doResult, { status: "request-error", request: req }];
    }
    const response = doResult.value;
    const [result] = await match(json(200, AutocompleteResponse$inboundSchema), fail([400, 401, 429, "4XX"]), fail("5XX"))(response, req);
    if (!result.ok) {
      return [result, { status: "complete", request: req, response }];
    }
    return [result, { status: "complete", request: req, response }];
  }

  // node_modules/@gleanwork/api-client/dist/esm/funcs/clientSearchQuery.js
  function clientSearchQuery(client, request, options) {
    return new APIPromise($do64(client, request, options));
  }
  async function $do64(client, request, options) {
    const parsed = safeParse(request, (value) => SearchRequest$outboundSchema.parse(value), "Input validation failed");
    if (!parsed.ok) {
      return [parsed, { status: "invalid" }];
    }
    const payload = parsed.value;
    const body = encodeJSON("body", payload, { explode: true });
    const path = pathToFunc("/rest/api/v1/search")();
    const headers = new Headers(compactMap({
      "Content-Type": "application/json",
      Accept: "application/json"
    }));
    const secConfig = await extractSecurity(client._options.apiToken);
    const securityInput = secConfig == null ? {} : { apiToken: secConfig };
    const requestSecurity = resolveGlobalSecurity(securityInput);
    const context = {
      options: client._options,
      baseURL: options?.serverURL ?? client._baseURL ?? "",
      operationID: "search",
      oAuth2Scopes: [],
      resolvedSecurity: requestSecurity,
      securitySource: client._options.apiToken,
      retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
      retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
    };
    const requestRes = client._createRequest(context, {
      security: requestSecurity,
      method: "POST",
      baseURL: options?.serverURL,
      path,
      headers,
      body,
      userAgent: client._options.userAgent,
      timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
    }, options);
    if (!requestRes.ok) {
      return [requestRes, { status: "invalid" }];
    }
    const req = requestRes.value;
    const doResult = await client._do(req, {
      context,
      errorCodes: ["400", "401", "403", "408", "422", "429", "4XX", "5XX"],
      retryConfig: context.retryConfig,
      retryCodes: context.retryCodes
    });
    if (!doResult.ok) {
      return [doResult, { status: "request-error", request: req }];
    }
    const response = doResult.value;
    const responseFields = {
      HttpMeta: { Response: response, Request: req }
    };
    const [result] = await match(json(200, SearchResponse$inboundSchema), jsonErr([403, 422], GleanDataError$inboundSchema2), fail([400, 401, 408, 429, "4XX"]), fail("5XX"))(response, req, { extraFields: responseFields });
    if (!result.ok) {
      return [result, { status: "complete", request: req, response }];
    }
    return [result, { status: "complete", request: req, response }];
  }

  // node_modules/@gleanwork/api-client/dist/esm/funcs/clientSearchQueryAsAdmin.js
  function clientSearchQueryAsAdmin(client, request, options) {
    return new APIPromise($do65(client, request, options));
  }
  async function $do65(client, request, options) {
    const parsed = safeParse(request, (value) => SearchRequest$outboundSchema.parse(value), "Input validation failed");
    if (!parsed.ok) {
      return [parsed, { status: "invalid" }];
    }
    const payload = parsed.value;
    const body = encodeJSON("body", payload, { explode: true });
    const path = pathToFunc("/rest/api/v1/adminsearch")();
    const headers = new Headers(compactMap({
      "Content-Type": "application/json",
      Accept: "application/json"
    }));
    const secConfig = await extractSecurity(client._options.apiToken);
    const securityInput = secConfig == null ? {} : { apiToken: secConfig };
    const requestSecurity = resolveGlobalSecurity(securityInput);
    const context = {
      options: client._options,
      baseURL: options?.serverURL ?? client._baseURL ?? "",
      operationID: "adminsearch",
      oAuth2Scopes: [],
      resolvedSecurity: requestSecurity,
      securitySource: client._options.apiToken,
      retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
      retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
    };
    const requestRes = client._createRequest(context, {
      security: requestSecurity,
      method: "POST",
      baseURL: options?.serverURL,
      path,
      headers,
      body,
      userAgent: client._options.userAgent,
      timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
    }, options);
    if (!requestRes.ok) {
      return [requestRes, { status: "invalid" }];
    }
    const req = requestRes.value;
    const doResult = await client._do(req, {
      context,
      errorCodes: ["400", "401", "403", "422", "429", "4XX", "5XX"],
      retryConfig: context.retryConfig,
      retryCodes: context.retryCodes
    });
    if (!doResult.ok) {
      return [doResult, { status: "request-error", request: req }];
    }
    const response = doResult.value;
    const responseFields = {
      HttpMeta: { Response: response, Request: req }
    };
    const [result] = await match(json(200, SearchResponse$inboundSchema), jsonErr([403, 422], GleanDataError$inboundSchema2), fail([400, 401, 429, "4XX"]), fail("5XX"))(response, req, { extraFields: responseFields });
    if (!result.ok) {
      return [result, { status: "complete", request: req, response }];
    }
    return [result, { status: "complete", request: req, response }];
  }

  // node_modules/@gleanwork/api-client/dist/esm/funcs/clientSearchRecommendations.js
  function clientSearchRecommendations(client, request, options) {
    return new APIPromise($do66(client, request, options));
  }
  async function $do66(client, request, options) {
    const parsed = safeParse(request, (value) => RecommendationsRequest$outboundSchema.parse(value), "Input validation failed");
    if (!parsed.ok) {
      return [parsed, { status: "invalid" }];
    }
    const payload = parsed.value;
    const body = encodeJSON("body", payload, { explode: true });
    const path = pathToFunc("/rest/api/v1/recommendations")();
    const headers = new Headers(compactMap({
      "Content-Type": "application/json",
      Accept: "application/json"
    }));
    const secConfig = await extractSecurity(client._options.apiToken);
    const securityInput = secConfig == null ? {} : { apiToken: secConfig };
    const requestSecurity = resolveGlobalSecurity(securityInput);
    const context = {
      options: client._options,
      baseURL: options?.serverURL ?? client._baseURL ?? "",
      operationID: "recommendations",
      oAuth2Scopes: [],
      resolvedSecurity: requestSecurity,
      securitySource: client._options.apiToken,
      retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
      retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
    };
    const requestRes = client._createRequest(context, {
      security: requestSecurity,
      method: "POST",
      baseURL: options?.serverURL,
      path,
      headers,
      body,
      userAgent: client._options.userAgent,
      timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
    }, options);
    if (!requestRes.ok) {
      return [requestRes, { status: "invalid" }];
    }
    const req = requestRes.value;
    const doResult = await client._do(req, {
      context,
      errorCodes: ["400", "401", "403", "429", "4XX", "5XX"],
      retryConfig: context.retryConfig,
      retryCodes: context.retryCodes
    });
    if (!doResult.ok) {
      return [doResult, { status: "request-error", request: req }];
    }
    const response = doResult.value;
    const [result] = await match(json(200, ResultsResponse$inboundSchema.optional()), nil([202, 204], ResultsResponse$inboundSchema.optional()), fail([400, 401, 403, 429, "4XX"]), fail("5XX"))(response, req);
    if (!result.ok) {
      return [result, { status: "complete", request: req, response }];
    }
    return [result, { status: "complete", request: req, response }];
  }

  // node_modules/@gleanwork/api-client/dist/esm/funcs/clientSearchRetrieveFeed.js
  function clientSearchRetrieveFeed(client, request, options) {
    return new APIPromise($do67(client, request, options));
  }
  async function $do67(client, request, options) {
    const parsed = safeParse(request, (value) => FeedRequest$outboundSchema.parse(value), "Input validation failed");
    if (!parsed.ok) {
      return [parsed, { status: "invalid" }];
    }
    const payload = parsed.value;
    const body = encodeJSON("body", payload, { explode: true });
    const path = pathToFunc("/rest/api/v1/feed")();
    const headers = new Headers(compactMap({
      "Content-Type": "application/json",
      Accept: "application/json"
    }));
    const secConfig = await extractSecurity(client._options.apiToken);
    const securityInput = secConfig == null ? {} : { apiToken: secConfig };
    const requestSecurity = resolveGlobalSecurity(securityInput);
    const context = {
      options: client._options,
      baseURL: options?.serverURL ?? client._baseURL ?? "",
      operationID: "feed",
      oAuth2Scopes: [],
      resolvedSecurity: requestSecurity,
      securitySource: client._options.apiToken,
      retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
      retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
    };
    const requestRes = client._createRequest(context, {
      security: requestSecurity,
      method: "POST",
      baseURL: options?.serverURL,
      path,
      headers,
      body,
      userAgent: client._options.userAgent,
      timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
    }, options);
    if (!requestRes.ok) {
      return [requestRes, { status: "invalid" }];
    }
    const req = requestRes.value;
    const doResult = await client._do(req, {
      context,
      errorCodes: ["400", "401", "408", "429", "4XX", "5XX"],
      retryConfig: context.retryConfig,
      retryCodes: context.retryCodes
    });
    if (!doResult.ok) {
      return [doResult, { status: "request-error", request: req }];
    }
    const response = doResult.value;
    const [result] = await match(json(200, FeedResponse$inboundSchema), fail([400, 401, 408, 429, "4XX"]), fail("5XX"))(response, req);
    if (!result.ok) {
      return [result, { status: "complete", request: req, response }];
    }
    return [result, { status: "complete", request: req, response }];
  }

  // node_modules/@gleanwork/api-client/dist/esm/sdk/search.js
  var Search = class extends ClientSDK {
    /**
     * Search the index (admin)
     *
     * @remarks
     * Retrieves results for search query without respect for permissions. This is available only to privileged users.
     */
    async queryAsAdmin(request, options) {
      return unwrapAsync(clientSearchQueryAsAdmin(this, request, options));
    }
    /**
     * Autocomplete
     *
     * @remarks
     * Retrieve query suggestions, operators and documents for the given partially typed query.
     */
    async autocomplete(request, options) {
      return unwrapAsync(clientSearchAutocomplete(this, request, options));
    }
    /**
     * Feed of documents and events
     *
     * @remarks
     * The personalized feed/home includes different types of contents including suggestions, recents, calendar events and many more.
     */
    async retrieveFeed(request, options) {
      return unwrapAsync(clientSearchRetrieveFeed(this, request, options));
    }
    /**
     * Recommend documents
     *
     * @remarks
     * Retrieve recommended documents for the given URL or Glean Document ID.
     */
    async recommendations(request, options) {
      return unwrapAsync(clientSearchRecommendations(this, request, options));
    }
    /**
     * Search
     *
     * @remarks
     * Retrieve results from the index for the given query and filters.
     */
    async query(request, options) {
      return unwrapAsync(clientSearchQuery(this, request, options));
    }
  };

  // node_modules/@gleanwork/api-client/dist/esm/funcs/clientToolsList.js
  function clientToolsList(client, toolNames, options) {
    return new APIPromise($do68(client, toolNames, options));
  }
  async function $do68(client, toolNames, options) {
    const input = {
      toolNames
    };
    const parsed = safeParse(input, (value) => GetRestApiV1ToolsListRequest$outboundSchema.parse(value), "Input validation failed");
    if (!parsed.ok) {
      return [parsed, { status: "invalid" }];
    }
    const payload = parsed.value;
    const body = null;
    const path = pathToFunc("/rest/api/v1/tools/list")();
    const query = encodeFormQuery({
      "toolNames": payload.toolNames
    }, { explode: false });
    const headers = new Headers(compactMap({
      Accept: "application/json"
    }));
    const secConfig = await extractSecurity(client._options.apiToken);
    const securityInput = secConfig == null ? {} : { apiToken: secConfig };
    const requestSecurity = resolveGlobalSecurity(securityInput);
    const context = {
      options: client._options,
      baseURL: options?.serverURL ?? client._baseURL ?? "",
      operationID: "get_/rest/api/v1/tools/list",
      oAuth2Scopes: [],
      resolvedSecurity: requestSecurity,
      securitySource: client._options.apiToken,
      retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
      retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
    };
    const requestRes = client._createRequest(context, {
      security: requestSecurity,
      method: "GET",
      baseURL: options?.serverURL,
      path,
      headers,
      query,
      body,
      userAgent: client._options.userAgent,
      timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
    }, options);
    if (!requestRes.ok) {
      return [requestRes, { status: "invalid" }];
    }
    const req = requestRes.value;
    const doResult = await client._do(req, {
      context,
      errorCodes: ["400", "401", "404", "429", "4XX", "5XX"],
      retryConfig: context.retryConfig,
      retryCodes: context.retryCodes
    });
    if (!doResult.ok) {
      return [doResult, { status: "request-error", request: req }];
    }
    const response = doResult.value;
    const [result] = await match(json(200, ToolsListResponse$inboundSchema), fail([400, 401, 404, 429, "4XX"]), fail("5XX"))(response, req);
    if (!result.ok) {
      return [result, { status: "complete", request: req, response }];
    }
    return [result, { status: "complete", request: req, response }];
  }

  // node_modules/@gleanwork/api-client/dist/esm/funcs/clientToolsRun.js
  function clientToolsRun(client, request, options) {
    return new APIPromise($do69(client, request, options));
  }
  async function $do69(client, request, options) {
    const parsed = safeParse(request, (value) => ToolsCallRequest$outboundSchema.parse(value), "Input validation failed");
    if (!parsed.ok) {
      return [parsed, { status: "invalid" }];
    }
    const payload = parsed.value;
    const body = encodeJSON("body", payload, { explode: true });
    const path = pathToFunc("/rest/api/v1/tools/call")();
    const headers = new Headers(compactMap({
      "Content-Type": "application/json",
      Accept: "application/json"
    }));
    const secConfig = await extractSecurity(client._options.apiToken);
    const securityInput = secConfig == null ? {} : { apiToken: secConfig };
    const requestSecurity = resolveGlobalSecurity(securityInput);
    const context = {
      options: client._options,
      baseURL: options?.serverURL ?? client._baseURL ?? "",
      operationID: "post_/rest/api/v1/tools/call",
      oAuth2Scopes: [],
      resolvedSecurity: requestSecurity,
      securitySource: client._options.apiToken,
      retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
      retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
    };
    const requestRes = client._createRequest(context, {
      security: requestSecurity,
      method: "POST",
      baseURL: options?.serverURL,
      path,
      headers,
      body,
      userAgent: client._options.userAgent,
      timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
    }, options);
    if (!requestRes.ok) {
      return [requestRes, { status: "invalid" }];
    }
    const req = requestRes.value;
    const doResult = await client._do(req, {
      context,
      errorCodes: ["400", "401", "404", "429", "4XX", "5XX"],
      retryConfig: context.retryConfig,
      retryCodes: context.retryCodes
    });
    if (!doResult.ok) {
      return [doResult, { status: "request-error", request: req }];
    }
    const response = doResult.value;
    const [result] = await match(json(200, ToolsCallResponse$inboundSchema), fail([400, 401, 404, 429, "4XX"]), fail("5XX"))(response, req);
    if (!result.ok) {
      return [result, { status: "complete", request: req, response }];
    }
    return [result, { status: "complete", request: req, response }];
  }

  // node_modules/@gleanwork/api-client/dist/esm/sdk/tools.js
  var Tools = class extends ClientSDK {
    /**
     * List available tools
     *
     * @remarks
     * Returns a filtered set of available tools based on optional tool name parameters. If no filters are provided, all available tools are returned.
     */
    async list(toolNames, options) {
      return unwrapAsync(clientToolsList(this, toolNames, options));
    }
    /**
     * Execute the specified tool
     *
     * @remarks
     * Execute the specified tool with provided parameters
     */
    async run(request, options) {
      return unwrapAsync(clientToolsRun(this, request, options));
    }
  };

  // node_modules/@gleanwork/api-client/dist/esm/funcs/clientVerificationAddReminder.js
  function clientVerificationAddReminder(client, request, options) {
    return new APIPromise($do70(client, request, options));
  }
  async function $do70(client, request, options) {
    const parsed = safeParse(request, (value) => ReminderRequest$outboundSchema.parse(value), "Input validation failed");
    if (!parsed.ok) {
      return [parsed, { status: "invalid" }];
    }
    const payload = parsed.value;
    const body = encodeJSON("body", payload, { explode: true });
    const path = pathToFunc("/rest/api/v1/addverificationreminder")();
    const headers = new Headers(compactMap({
      "Content-Type": "application/json",
      Accept: "application/json"
    }));
    const secConfig = await extractSecurity(client._options.apiToken);
    const securityInput = secConfig == null ? {} : { apiToken: secConfig };
    const requestSecurity = resolveGlobalSecurity(securityInput);
    const context = {
      options: client._options,
      baseURL: options?.serverURL ?? client._baseURL ?? "",
      operationID: "addverificationreminder",
      oAuth2Scopes: [],
      resolvedSecurity: requestSecurity,
      securitySource: client._options.apiToken,
      retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
      retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
    };
    const requestRes = client._createRequest(context, {
      security: requestSecurity,
      method: "POST",
      baseURL: options?.serverURL,
      path,
      headers,
      body,
      userAgent: client._options.userAgent,
      timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
    }, options);
    if (!requestRes.ok) {
      return [requestRes, { status: "invalid" }];
    }
    const req = requestRes.value;
    const doResult = await client._do(req, {
      context,
      errorCodes: ["400", "401", "403", "429", "4XX", "5XX"],
      retryConfig: context.retryConfig,
      retryCodes: context.retryCodes
    });
    if (!doResult.ok) {
      return [doResult, { status: "request-error", request: req }];
    }
    const response = doResult.value;
    const [result] = await match(json(200, Verification$inboundSchema), fail([400, 401, 403, 429, "4XX"]), fail("5XX"))(response, req);
    if (!result.ok) {
      return [result, { status: "complete", request: req, response }];
    }
    return [result, { status: "complete", request: req, response }];
  }

  // node_modules/@gleanwork/api-client/dist/esm/funcs/clientVerificationList.js
  function clientVerificationList(client, count, options) {
    return new APIPromise($do71(client, count, options));
  }
  async function $do71(client, count, options) {
    const input = {
      count
    };
    const parsed = safeParse(input, (value) => ListverificationsRequest$outboundSchema.parse(value), "Input validation failed");
    if (!parsed.ok) {
      return [parsed, { status: "invalid" }];
    }
    const payload = parsed.value;
    const body = null;
    const path = pathToFunc("/rest/api/v1/listverifications")();
    const query = encodeFormQuery({
      "count": payload.count
    });
    const headers = new Headers(compactMap({
      Accept: "application/json"
    }));
    const secConfig = await extractSecurity(client._options.apiToken);
    const securityInput = secConfig == null ? {} : { apiToken: secConfig };
    const requestSecurity = resolveGlobalSecurity(securityInput);
    const context = {
      options: client._options,
      baseURL: options?.serverURL ?? client._baseURL ?? "",
      operationID: "listverifications",
      oAuth2Scopes: [],
      resolvedSecurity: requestSecurity,
      securitySource: client._options.apiToken,
      retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
      retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
    };
    const requestRes = client._createRequest(context, {
      security: requestSecurity,
      method: "POST",
      baseURL: options?.serverURL,
      path,
      headers,
      query,
      body,
      userAgent: client._options.userAgent,
      timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
    }, options);
    if (!requestRes.ok) {
      return [requestRes, { status: "invalid" }];
    }
    const req = requestRes.value;
    const doResult = await client._do(req, {
      context,
      errorCodes: ["400", "401", "429", "4XX", "5XX"],
      retryConfig: context.retryConfig,
      retryCodes: context.retryCodes
    });
    if (!doResult.ok) {
      return [doResult, { status: "request-error", request: req }];
    }
    const response = doResult.value;
    const [result] = await match(json(200, VerificationFeed$inboundSchema), fail([400, 401, 429, "4XX"]), fail("5XX"))(response, req);
    if (!result.ok) {
      return [result, { status: "complete", request: req, response }];
    }
    return [result, { status: "complete", request: req, response }];
  }

  // node_modules/@gleanwork/api-client/dist/esm/funcs/clientVerificationVerify.js
  function clientVerificationVerify(client, request, options) {
    return new APIPromise($do72(client, request, options));
  }
  async function $do72(client, request, options) {
    const parsed = safeParse(request, (value) => VerifyRequest$outboundSchema.parse(value), "Input validation failed");
    if (!parsed.ok) {
      return [parsed, { status: "invalid" }];
    }
    const payload = parsed.value;
    const body = encodeJSON("body", payload, { explode: true });
    const path = pathToFunc("/rest/api/v1/verify")();
    const headers = new Headers(compactMap({
      "Content-Type": "application/json",
      Accept: "application/json"
    }));
    const secConfig = await extractSecurity(client._options.apiToken);
    const securityInput = secConfig == null ? {} : { apiToken: secConfig };
    const requestSecurity = resolveGlobalSecurity(securityInput);
    const context = {
      options: client._options,
      baseURL: options?.serverURL ?? client._baseURL ?? "",
      operationID: "verify",
      oAuth2Scopes: [],
      resolvedSecurity: requestSecurity,
      securitySource: client._options.apiToken,
      retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
      retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
    };
    const requestRes = client._createRequest(context, {
      security: requestSecurity,
      method: "POST",
      baseURL: options?.serverURL,
      path,
      headers,
      body,
      userAgent: client._options.userAgent,
      timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
    }, options);
    if (!requestRes.ok) {
      return [requestRes, { status: "invalid" }];
    }
    const req = requestRes.value;
    const doResult = await client._do(req, {
      context,
      errorCodes: ["400", "401", "403", "429", "4XX", "5XX"],
      retryConfig: context.retryConfig,
      retryCodes: context.retryCodes
    });
    if (!doResult.ok) {
      return [doResult, { status: "request-error", request: req }];
    }
    const response = doResult.value;
    const [result] = await match(json(200, Verification$inboundSchema), fail([400, 401, 403, 429, "4XX"]), fail("5XX"))(response, req);
    if (!result.ok) {
      return [result, { status: "complete", request: req, response }];
    }
    return [result, { status: "complete", request: req, response }];
  }

  // node_modules/@gleanwork/api-client/dist/esm/sdk/verification.js
  var Verification = class extends ClientSDK {
    /**
     * Create verification
     *
     * @remarks
     * Creates a verification reminder for the document. Users can create verification reminders from different product surfaces.
     */
    async addReminder(request, options) {
      return unwrapAsync(clientVerificationAddReminder(this, request, options));
    }
    /**
     * List verifications
     *
     * @remarks
     * Returns the information to be rendered in verification dashboard. Includes information for each document owned by user regarding their verifications.
     */
    async list(count, options) {
      return unwrapAsync(clientVerificationList(this, count, options));
    }
    /**
     * Update verification
     *
     * @remarks
     * Verify documents to keep the knowledge up to date within customer corpus.
     */
    async verify(request, options) {
      return unwrapAsync(clientVerificationVerify(this, request, options));
    }
  };

  // node_modules/@gleanwork/api-client/dist/esm/sdk/client.js
  var Client = class extends ClientSDK {
    get activity() {
      return this._activity ?? (this._activity = new Activity(this._options));
    }
    get announcements() {
      return this._announcements ?? (this._announcements = new Announcements(this._options));
    }
    get answers() {
      return this._answers ?? (this._answers = new Answers(this._options));
    }
    get authentication() {
      return this._authentication ?? (this._authentication = new ClientAuthentication(this._options));
    }
    get chat() {
      return this._chat ?? (this._chat = new Chat(this._options));
    }
    get agents() {
      return this._agents ?? (this._agents = new Agents(this._options));
    }
    get collections() {
      return this._collections ?? (this._collections = new Collections(this._options));
    }
    get documents() {
      return this._documents ?? (this._documents = new ClientDocuments(this._options));
    }
    get insights() {
      return this._insights ?? (this._insights = new Insights(this._options));
    }
    get messages() {
      return this._messages ?? (this._messages = new Messages(this._options));
    }
    get pins() {
      return this._pins ?? (this._pins = new Pins(this._options));
    }
    get search() {
      return this._search ?? (this._search = new Search(this._options));
    }
    get entities() {
      return this._entities ?? (this._entities = new Entities(this._options));
    }
    get shortcuts() {
      return this._shortcuts ?? (this._shortcuts = new ClientShortcuts(this._options));
    }
    get verification() {
      return this._verification ?? (this._verification = new Verification(this._options));
    }
    get tools() {
      return this._tools ?? (this._tools = new Tools(this._options));
    }
    get governance() {
      return this._governance ?? (this._governance = new Governance(this._options));
    }
  };

  // node_modules/@gleanwork/api-client/dist/esm/funcs/indexingDatasourceStatus.js
  function indexingDatasourceStatus(client, datasource, options) {
    return new APIPromise($do73(client, datasource, options));
  }
  async function $do73(client, datasource, options) {
    const input = {
      datasource
    };
    const parsed = safeParse(input, (value) => PostApiIndexV1DebugDatasourceStatusRequest$outboundSchema.parse(value), "Input validation failed");
    if (!parsed.ok) {
      return [parsed, { status: "invalid" }];
    }
    const payload = parsed.value;
    const body = null;
    const pathParams = {
      datasource: encodeSimple("datasource", payload.datasource, {
        explode: false,
        charEncoding: "percent"
      })
    };
    const path = pathToFunc("/api/index/v1/debug/{datasource}/status")(pathParams);
    const headers = new Headers(compactMap({
      Accept: "application/json; charset=UTF-8"
    }));
    const secConfig = await extractSecurity(client._options.apiToken);
    const securityInput = secConfig == null ? {} : { apiToken: secConfig };
    const requestSecurity = resolveGlobalSecurity(securityInput);
    const context = {
      options: client._options,
      baseURL: options?.serverURL ?? client._baseURL ?? "",
      operationID: "post_/api/index/v1/debug/{datasource}/status",
      oAuth2Scopes: [],
      resolvedSecurity: requestSecurity,
      securitySource: client._options.apiToken,
      retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
      retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
    };
    const requestRes = client._createRequest(context, {
      security: requestSecurity,
      method: "POST",
      baseURL: options?.serverURL,
      path,
      headers,
      body,
      userAgent: client._options.userAgent,
      timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
    }, options);
    if (!requestRes.ok) {
      return [requestRes, { status: "invalid" }];
    }
    const req = requestRes.value;
    const doResult = await client._do(req, {
      context,
      errorCodes: ["400", "401", "4XX", "5XX"],
      retryConfig: context.retryConfig,
      retryCodes: context.retryCodes
    });
    if (!doResult.ok) {
      return [doResult, { status: "request-error", request: req }];
    }
    const response = doResult.value;
    const [result] = await match(json(200, DebugDatasourceStatusResponse$inboundSchema, {
      ctype: "application/json; charset=UTF-8"
    }), fail([400, 401, "4XX"]), fail("5XX"))(response, req);
    if (!result.ok) {
      return [result, { status: "complete", request: req, response }];
    }
    return [result, { status: "complete", request: req, response }];
  }

  // node_modules/@gleanwork/api-client/dist/esm/sdk/datasource.js
  var Datasource2 = class extends ClientSDK {
    /**
     * Beta: Get datasource status
     *
     * @remarks
     * Gather information about the datasource's overall status. Currently in beta, might undergo breaking changes without prior notice.
     *
     * Tip: Refer to the [Troubleshooting tutorial](https://developers.glean.com/indexing/debugging/datasource-config) for more information.
     */
    async status(datasource, options) {
      return unwrapAsync(indexingDatasourceStatus(this, datasource, options));
    }
  };

  // node_modules/@gleanwork/api-client/dist/esm/funcs/indexingDatasourcesAdd.js
  function indexingDatasourcesAdd(client, request, options) {
    return new APIPromise($do74(client, request, options));
  }
  async function $do74(client, request, options) {
    const parsed = safeParse(request, (value) => CustomDatasourceConfig$outboundSchema.parse(value), "Input validation failed");
    if (!parsed.ok) {
      return [parsed, { status: "invalid" }];
    }
    const payload = parsed.value;
    const body = encodeJSON("body", payload, { explode: true });
    const path = pathToFunc("/api/index/v1/adddatasource")();
    const headers = new Headers(compactMap({
      "Content-Type": "application/json",
      Accept: "*/*"
    }));
    const secConfig = await extractSecurity(client._options.apiToken);
    const securityInput = secConfig == null ? {} : { apiToken: secConfig };
    const requestSecurity = resolveGlobalSecurity(securityInput);
    const context = {
      options: client._options,
      baseURL: options?.serverURL ?? client._baseURL ?? "",
      operationID: "post_/api/index/v1/adddatasource",
      oAuth2Scopes: [],
      resolvedSecurity: requestSecurity,
      securitySource: client._options.apiToken,
      retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
      retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
    };
    const requestRes = client._createRequest(context, {
      security: requestSecurity,
      method: "POST",
      baseURL: options?.serverURL,
      path,
      headers,
      body,
      userAgent: client._options.userAgent,
      timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
    }, options);
    if (!requestRes.ok) {
      return [requestRes, { status: "invalid" }];
    }
    const req = requestRes.value;
    const doResult = await client._do(req, {
      context,
      errorCodes: ["400", "401", "4XX", "5XX"],
      retryConfig: context.retryConfig,
      retryCodes: context.retryCodes
    });
    if (!doResult.ok) {
      return [doResult, { status: "request-error", request: req }];
    }
    const response = doResult.value;
    const [result] = await match(nil(200, voidType()), fail([400, 401, "4XX"]), fail("5XX"))(response, req);
    if (!result.ok) {
      return [result, { status: "complete", request: req, response }];
    }
    return [result, { status: "complete", request: req, response }];
  }

  // node_modules/@gleanwork/api-client/dist/esm/funcs/indexingDatasourcesRetrieveConfig.js
  function indexingDatasourcesRetrieveConfig(client, request, options) {
    return new APIPromise($do75(client, request, options));
  }
  async function $do75(client, request, options) {
    const parsed = safeParse(request, (value) => GetDatasourceConfigRequest$outboundSchema.parse(value), "Input validation failed");
    if (!parsed.ok) {
      return [parsed, { status: "invalid" }];
    }
    const payload = parsed.value;
    const body = encodeJSON("body", payload, { explode: true });
    const path = pathToFunc("/api/index/v1/getdatasourceconfig")();
    const headers = new Headers(compactMap({
      "Content-Type": "application/json",
      Accept: "application/json"
    }));
    const secConfig = await extractSecurity(client._options.apiToken);
    const securityInput = secConfig == null ? {} : { apiToken: secConfig };
    const requestSecurity = resolveGlobalSecurity(securityInput);
    const context = {
      options: client._options,
      baseURL: options?.serverURL ?? client._baseURL ?? "",
      operationID: "post_/api/index/v1/getdatasourceconfig",
      oAuth2Scopes: [],
      resolvedSecurity: requestSecurity,
      securitySource: client._options.apiToken,
      retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
      retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
    };
    const requestRes = client._createRequest(context, {
      security: requestSecurity,
      method: "POST",
      baseURL: options?.serverURL,
      path,
      headers,
      body,
      userAgent: client._options.userAgent,
      timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
    }, options);
    if (!requestRes.ok) {
      return [requestRes, { status: "invalid" }];
    }
    const req = requestRes.value;
    const doResult = await client._do(req, {
      context,
      errorCodes: ["400", "401", "409", "4XX", "5XX"],
      retryConfig: context.retryConfig,
      retryCodes: context.retryCodes
    });
    if (!doResult.ok) {
      return [doResult, { status: "request-error", request: req }];
    }
    const response = doResult.value;
    const [result] = await match(json(200, CustomDatasourceConfig$inboundSchema), fail([400, 401, 409, "4XX"]), fail("5XX"))(response, req);
    if (!result.ok) {
      return [result, { status: "complete", request: req, response }];
    }
    return [result, { status: "complete", request: req, response }];
  }

  // node_modules/@gleanwork/api-client/dist/esm/sdk/datasources.js
  var Datasources = class extends ClientSDK {
    /**
     * Add or update datasource
     *
     * @remarks
     * Add or update a custom datasource and its schema.
     */
    async add(request, options) {
      return unwrapAsync(indexingDatasourcesAdd(this, request, options));
    }
    /**
     * Get datasource config
     *
     * @remarks
     * Fetches the datasource config for the specified custom datasource.
     */
    async retrieveConfig(request, options) {
      return unwrapAsync(indexingDatasourcesRetrieveConfig(this, request, options));
    }
  };

  // node_modules/@gleanwork/api-client/dist/esm/funcs/indexingAuthenticationRotateToken.js
  function indexingAuthenticationRotateToken(client, options) {
    return new APIPromise($do76(client, options));
  }
  async function $do76(client, options) {
    const path = pathToFunc("/api/index/v1/rotatetoken")();
    const headers = new Headers(compactMap({
      Accept: "application/json"
    }));
    const secConfig = await extractSecurity(client._options.apiToken);
    const securityInput = secConfig == null ? {} : { apiToken: secConfig };
    const requestSecurity = resolveGlobalSecurity(securityInput);
    const context = {
      options: client._options,
      baseURL: options?.serverURL ?? client._baseURL ?? "",
      operationID: "post_/api/index/v1/rotatetoken",
      oAuth2Scopes: [],
      resolvedSecurity: requestSecurity,
      securitySource: client._options.apiToken,
      retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
      retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
    };
    const requestRes = client._createRequest(context, {
      security: requestSecurity,
      method: "POST",
      baseURL: options?.serverURL,
      path,
      headers,
      userAgent: client._options.userAgent,
      timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
    }, options);
    if (!requestRes.ok) {
      return [requestRes, { status: "invalid" }];
    }
    const req = requestRes.value;
    const doResult = await client._do(req, {
      context,
      errorCodes: ["400", "401", "4XX", "5XX"],
      retryConfig: context.retryConfig,
      retryCodes: context.retryCodes
    });
    if (!doResult.ok) {
      return [doResult, { status: "request-error", request: req }];
    }
    const response = doResult.value;
    const [result] = await match(json(200, RotateTokenResponse$inboundSchema), fail([400, 401, "4XX"]), fail("5XX"))(response, req);
    if (!result.ok) {
      return [result, { status: "complete", request: req, response }];
    }
    return [result, { status: "complete", request: req, response }];
  }

  // node_modules/@gleanwork/api-client/dist/esm/sdk/indexingauthentication.js
  var IndexingAuthentication = class extends ClientSDK {
    /**
     * Rotate token
     *
     * @remarks
     * Rotates the secret value inside the Indexing API token and returns the new raw secret. All other properties of the token are unchanged. In order to rotate the secret value, include the token as the bearer token in the `/rotatetoken` request. Please refer to [Token rotation](https://developers.glean.com/indexing/authentication/token-rotation) documentation for more information.
     */
    async rotateToken(options) {
      return unwrapAsync(indexingAuthenticationRotateToken(this, options));
    }
  };

  // node_modules/@gleanwork/api-client/dist/esm/funcs/indexingDocumentsAddOrUpdate.js
  function indexingDocumentsAddOrUpdate(client, request, options) {
    return new APIPromise($do77(client, request, options));
  }
  async function $do77(client, request, options) {
    const parsed = safeParse(request, (value) => IndexDocumentRequest$outboundSchema.parse(value), "Input validation failed");
    if (!parsed.ok) {
      return [parsed, { status: "invalid" }];
    }
    const payload = parsed.value;
    const body = encodeJSON("body", payload, { explode: true });
    const path = pathToFunc("/api/index/v1/indexdocument")();
    const headers = new Headers(compactMap({
      "Content-Type": "application/json",
      Accept: "*/*"
    }));
    const secConfig = await extractSecurity(client._options.apiToken);
    const securityInput = secConfig == null ? {} : { apiToken: secConfig };
    const requestSecurity = resolveGlobalSecurity(securityInput);
    const context = {
      options: client._options,
      baseURL: options?.serverURL ?? client._baseURL ?? "",
      operationID: "post_/api/index/v1/indexdocument",
      oAuth2Scopes: [],
      resolvedSecurity: requestSecurity,
      securitySource: client._options.apiToken,
      retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
      retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
    };
    const requestRes = client._createRequest(context, {
      security: requestSecurity,
      method: "POST",
      baseURL: options?.serverURL,
      path,
      headers,
      body,
      userAgent: client._options.userAgent,
      timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
    }, options);
    if (!requestRes.ok) {
      return [requestRes, { status: "invalid" }];
    }
    const req = requestRes.value;
    const doResult = await client._do(req, {
      context,
      errorCodes: ["400", "401", "409", "429", "4XX", "5XX"],
      retryConfig: context.retryConfig,
      retryCodes: context.retryCodes
    });
    if (!doResult.ok) {
      return [doResult, { status: "request-error", request: req }];
    }
    const response = doResult.value;
    const [result] = await match(nil(200, voidType()), fail([400, 401, 409, 429, "4XX"]), fail("5XX"))(response, req);
    if (!result.ok) {
      return [result, { status: "complete", request: req, response }];
    }
    return [result, { status: "complete", request: req, response }];
  }

  // node_modules/@gleanwork/api-client/dist/esm/funcs/indexingDocumentsBulkIndex.js
  function indexingDocumentsBulkIndex(client, request, options) {
    return new APIPromise($do78(client, request, options));
  }
  async function $do78(client, request, options) {
    const parsed = safeParse(request, (value) => BulkIndexDocumentsRequest$outboundSchema.parse(value), "Input validation failed");
    if (!parsed.ok) {
      return [parsed, { status: "invalid" }];
    }
    const payload = parsed.value;
    const body = encodeJSON("body", payload, { explode: true });
    const path = pathToFunc("/api/index/v1/bulkindexdocuments")();
    const headers = new Headers(compactMap({
      "Content-Type": "application/json",
      Accept: "*/*"
    }));
    const secConfig = await extractSecurity(client._options.apiToken);
    const securityInput = secConfig == null ? {} : { apiToken: secConfig };
    const requestSecurity = resolveGlobalSecurity(securityInput);
    const context = {
      options: client._options,
      baseURL: options?.serverURL ?? client._baseURL ?? "",
      operationID: "post_/api/index/v1/bulkindexdocuments",
      oAuth2Scopes: [],
      resolvedSecurity: requestSecurity,
      securitySource: client._options.apiToken,
      retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
      retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
    };
    const requestRes = client._createRequest(context, {
      security: requestSecurity,
      method: "POST",
      baseURL: options?.serverURL,
      path,
      headers,
      body,
      userAgent: client._options.userAgent,
      timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
    }, options);
    if (!requestRes.ok) {
      return [requestRes, { status: "invalid" }];
    }
    const req = requestRes.value;
    const doResult = await client._do(req, {
      context,
      errorCodes: ["400", "401", "409", "4XX", "5XX"],
      retryConfig: context.retryConfig,
      retryCodes: context.retryCodes
    });
    if (!doResult.ok) {
      return [doResult, { status: "request-error", request: req }];
    }
    const response = doResult.value;
    const [result] = await match(nil(200, voidType()), fail([400, 401, 409, "4XX"]), fail("5XX"))(response, req);
    if (!result.ok) {
      return [result, { status: "complete", request: req, response }];
    }
    return [result, { status: "complete", request: req, response }];
  }

  // node_modules/@gleanwork/api-client/dist/esm/funcs/indexingDocumentsCheckAccess.js
  function indexingDocumentsCheckAccess(client, request, options) {
    return new APIPromise($do79(client, request, options));
  }
  async function $do79(client, request, options) {
    const parsed = safeParse(request, (value) => CheckDocumentAccessRequest$outboundSchema.parse(value), "Input validation failed");
    if (!parsed.ok) {
      return [parsed, { status: "invalid" }];
    }
    const payload = parsed.value;
    const body = encodeJSON("body", payload, { explode: true });
    const path = pathToFunc("/api/index/v1/checkdocumentaccess")();
    const headers = new Headers(compactMap({
      "Content-Type": "application/json",
      Accept: "application/json"
    }));
    const secConfig = await extractSecurity(client._options.apiToken);
    const securityInput = secConfig == null ? {} : { apiToken: secConfig };
    const requestSecurity = resolveGlobalSecurity(securityInput);
    const context = {
      options: client._options,
      baseURL: options?.serverURL ?? client._baseURL ?? "",
      operationID: "post_/api/index/v1/checkdocumentaccess",
      oAuth2Scopes: [],
      resolvedSecurity: requestSecurity,
      securitySource: client._options.apiToken,
      retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
      retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
    };
    const requestRes = client._createRequest(context, {
      security: requestSecurity,
      method: "POST",
      baseURL: options?.serverURL,
      path,
      headers,
      body,
      userAgent: client._options.userAgent,
      timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
    }, options);
    if (!requestRes.ok) {
      return [requestRes, { status: "invalid" }];
    }
    const req = requestRes.value;
    const doResult = await client._do(req, {
      context,
      errorCodes: ["400", "401", "429", "4XX", "5XX"],
      retryConfig: context.retryConfig,
      retryCodes: context.retryCodes
    });
    if (!doResult.ok) {
      return [doResult, { status: "request-error", request: req }];
    }
    const response = doResult.value;
    const [result] = await match(json(200, CheckDocumentAccessResponse$inboundSchema), fail([400, 401, 429, "4XX"]), fail("5XX"))(response, req);
    if (!result.ok) {
      return [result, { status: "complete", request: req, response }];
    }
    return [result, { status: "complete", request: req, response }];
  }

  // node_modules/@gleanwork/api-client/dist/esm/funcs/indexingDocumentsCount.js
  function indexingDocumentsCount(client, request, options) {
    return new APIPromise($do80(client, request, options));
  }
  async function $do80(client, request, options) {
    const parsed = safeParse(request, (value) => GetDocumentCountRequest$outboundSchema.parse(value), "Input validation failed");
    if (!parsed.ok) {
      return [parsed, { status: "invalid" }];
    }
    const payload = parsed.value;
    const body = encodeJSON("body", payload, { explode: true });
    const path = pathToFunc("/api/index/v1/getdocumentcount")();
    const headers = new Headers(compactMap({
      "Content-Type": "application/json",
      Accept: "application/json"
    }));
    const secConfig = await extractSecurity(client._options.apiToken);
    const securityInput = secConfig == null ? {} : { apiToken: secConfig };
    const requestSecurity = resolveGlobalSecurity(securityInput);
    const context = {
      options: client._options,
      baseURL: options?.serverURL ?? client._baseURL ?? "",
      operationID: "post_/api/index/v1/getdocumentcount",
      oAuth2Scopes: [],
      resolvedSecurity: requestSecurity,
      securitySource: client._options.apiToken,
      retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
      retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
    };
    const requestRes = client._createRequest(context, {
      security: requestSecurity,
      method: "POST",
      baseURL: options?.serverURL,
      path,
      headers,
      body,
      userAgent: client._options.userAgent,
      timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
    }, options);
    if (!requestRes.ok) {
      return [requestRes, { status: "invalid" }];
    }
    const req = requestRes.value;
    const doResult = await client._do(req, {
      context,
      errorCodes: ["400", "401", "409", "4XX", "5XX"],
      retryConfig: context.retryConfig,
      retryCodes: context.retryCodes
    });
    if (!doResult.ok) {
      return [doResult, { status: "request-error", request: req }];
    }
    const response = doResult.value;
    const [result] = await match(json(200, GetDocumentCountResponse$inboundSchema), fail([400, 401, 409, "4XX"]), fail("5XX"))(response, req);
    if (!result.ok) {
      return [result, { status: "complete", request: req, response }];
    }
    return [result, { status: "complete", request: req, response }];
  }

  // node_modules/@gleanwork/api-client/dist/esm/funcs/indexingDocumentsDebug.js
  function indexingDocumentsDebug(client, debugDocumentRequest, datasource, options) {
    return new APIPromise($do81(client, debugDocumentRequest, datasource, options));
  }
  async function $do81(client, debugDocumentRequest, datasource, options) {
    const input = {
      debugDocumentRequest,
      datasource
    };
    const parsed = safeParse(input, (value) => PostApiIndexV1DebugDatasourceDocumentRequest$outboundSchema.parse(value), "Input validation failed");
    if (!parsed.ok) {
      return [parsed, { status: "invalid" }];
    }
    const payload = parsed.value;
    const body = encodeJSON("body", payload.DebugDocumentRequest, {
      explode: true
    });
    const pathParams = {
      datasource: encodeSimple("datasource", payload.datasource, {
        explode: false,
        charEncoding: "percent"
      })
    };
    const path = pathToFunc("/api/index/v1/debug/{datasource}/document")(pathParams);
    const headers = new Headers(compactMap({
      "Content-Type": "application/json",
      Accept: "application/json; charset=UTF-8"
    }));
    const secConfig = await extractSecurity(client._options.apiToken);
    const securityInput = secConfig == null ? {} : { apiToken: secConfig };
    const requestSecurity = resolveGlobalSecurity(securityInput);
    const context = {
      options: client._options,
      baseURL: options?.serverURL ?? client._baseURL ?? "",
      operationID: "post_/api/index/v1/debug/{datasource}/document",
      oAuth2Scopes: [],
      resolvedSecurity: requestSecurity,
      securitySource: client._options.apiToken,
      retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
      retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
    };
    const requestRes = client._createRequest(context, {
      security: requestSecurity,
      method: "POST",
      baseURL: options?.serverURL,
      path,
      headers,
      body,
      userAgent: client._options.userAgent,
      timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
    }, options);
    if (!requestRes.ok) {
      return [requestRes, { status: "invalid" }];
    }
    const req = requestRes.value;
    const doResult = await client._do(req, {
      context,
      errorCodes: ["400", "401", "4XX", "5XX"],
      retryConfig: context.retryConfig,
      retryCodes: context.retryCodes
    });
    if (!doResult.ok) {
      return [doResult, { status: "request-error", request: req }];
    }
    const response = doResult.value;
    const [result] = await match(json(200, DebugDocumentResponse$inboundSchema, {
      ctype: "application/json; charset=UTF-8"
    }), fail([400, 401, "4XX"]), fail("5XX"))(response, req);
    if (!result.ok) {
      return [result, { status: "complete", request: req, response }];
    }
    return [result, { status: "complete", request: req, response }];
  }

  // node_modules/@gleanwork/api-client/dist/esm/funcs/indexingDocumentsDebugMany.js
  function indexingDocumentsDebugMany(client, debugDocumentsRequest, datasource, options) {
    return new APIPromise($do82(client, debugDocumentsRequest, datasource, options));
  }
  async function $do82(client, debugDocumentsRequest, datasource, options) {
    const input = {
      debugDocumentsRequest,
      datasource
    };
    const parsed = safeParse(input, (value) => PostApiIndexV1DebugDatasourceDocumentsRequest$outboundSchema.parse(value), "Input validation failed");
    if (!parsed.ok) {
      return [parsed, { status: "invalid" }];
    }
    const payload = parsed.value;
    const body = encodeJSON("body", payload.DebugDocumentsRequest, {
      explode: true
    });
    const pathParams = {
      datasource: encodeSimple("datasource", payload.datasource, {
        explode: false,
        charEncoding: "percent"
      })
    };
    const path = pathToFunc("/api/index/v1/debug/{datasource}/documents")(pathParams);
    const headers = new Headers(compactMap({
      "Content-Type": "application/json",
      Accept: "application/json; charset=UTF-8"
    }));
    const secConfig = await extractSecurity(client._options.apiToken);
    const securityInput = secConfig == null ? {} : { apiToken: secConfig };
    const requestSecurity = resolveGlobalSecurity(securityInput);
    const context = {
      options: client._options,
      baseURL: options?.serverURL ?? client._baseURL ?? "",
      operationID: "post_/api/index/v1/debug/{datasource}/documents",
      oAuth2Scopes: [],
      resolvedSecurity: requestSecurity,
      securitySource: client._options.apiToken,
      retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
      retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
    };
    const requestRes = client._createRequest(context, {
      security: requestSecurity,
      method: "POST",
      baseURL: options?.serverURL,
      path,
      headers,
      body,
      userAgent: client._options.userAgent,
      timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
    }, options);
    if (!requestRes.ok) {
      return [requestRes, { status: "invalid" }];
    }
    const req = requestRes.value;
    const doResult = await client._do(req, {
      context,
      errorCodes: ["400", "401", "4XX", "5XX"],
      retryConfig: context.retryConfig,
      retryCodes: context.retryCodes
    });
    if (!doResult.ok) {
      return [doResult, { status: "request-error", request: req }];
    }
    const response = doResult.value;
    const [result] = await match(json(200, DebugDocumentsResponse$inboundSchema, {
      ctype: "application/json; charset=UTF-8"
    }), fail([400, 401, "4XX"]), fail("5XX"))(response, req);
    if (!result.ok) {
      return [result, { status: "complete", request: req, response }];
    }
    return [result, { status: "complete", request: req, response }];
  }

  // node_modules/@gleanwork/api-client/dist/esm/funcs/indexingDocumentsDelete.js
  function indexingDocumentsDelete(client, request, options) {
    return new APIPromise($do83(client, request, options));
  }
  async function $do83(client, request, options) {
    const parsed = safeParse(request, (value) => DeleteDocumentRequest$outboundSchema.parse(value), "Input validation failed");
    if (!parsed.ok) {
      return [parsed, { status: "invalid" }];
    }
    const payload = parsed.value;
    const body = encodeJSON("body", payload, { explode: true });
    const path = pathToFunc("/api/index/v1/deletedocument")();
    const headers = new Headers(compactMap({
      "Content-Type": "application/json",
      Accept: "*/*"
    }));
    const secConfig = await extractSecurity(client._options.apiToken);
    const securityInput = secConfig == null ? {} : { apiToken: secConfig };
    const requestSecurity = resolveGlobalSecurity(securityInput);
    const context = {
      options: client._options,
      baseURL: options?.serverURL ?? client._baseURL ?? "",
      operationID: "post_/api/index/v1/deletedocument",
      oAuth2Scopes: [],
      resolvedSecurity: requestSecurity,
      securitySource: client._options.apiToken,
      retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
      retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
    };
    const requestRes = client._createRequest(context, {
      security: requestSecurity,
      method: "POST",
      baseURL: options?.serverURL,
      path,
      headers,
      body,
      userAgent: client._options.userAgent,
      timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
    }, options);
    if (!requestRes.ok) {
      return [requestRes, { status: "invalid" }];
    }
    const req = requestRes.value;
    const doResult = await client._do(req, {
      context,
      errorCodes: ["400", "401", "409", "4XX", "5XX"],
      retryConfig: context.retryConfig,
      retryCodes: context.retryCodes
    });
    if (!doResult.ok) {
      return [doResult, { status: "request-error", request: req }];
    }
    const response = doResult.value;
    const [result] = await match(nil(200, voidType()), fail([400, 401, 409, "4XX"]), fail("5XX"))(response, req);
    if (!result.ok) {
      return [result, { status: "complete", request: req, response }];
    }
    return [result, { status: "complete", request: req, response }];
  }

  // node_modules/@gleanwork/api-client/dist/esm/funcs/indexingDocumentsIndex.js
  function indexingDocumentsIndex(client, request, options) {
    return new APIPromise($do84(client, request, options));
  }
  async function $do84(client, request, options) {
    const parsed = safeParse(request, (value) => IndexDocumentsRequest$outboundSchema.parse(value), "Input validation failed");
    if (!parsed.ok) {
      return [parsed, { status: "invalid" }];
    }
    const payload = parsed.value;
    const body = encodeJSON("body", payload, { explode: true });
    const path = pathToFunc("/api/index/v1/indexdocuments")();
    const headers = new Headers(compactMap({
      "Content-Type": "application/json",
      Accept: "*/*"
    }));
    const secConfig = await extractSecurity(client._options.apiToken);
    const securityInput = secConfig == null ? {} : { apiToken: secConfig };
    const requestSecurity = resolveGlobalSecurity(securityInput);
    const context = {
      options: client._options,
      baseURL: options?.serverURL ?? client._baseURL ?? "",
      operationID: "post_/api/index/v1/indexdocuments",
      oAuth2Scopes: [],
      resolvedSecurity: requestSecurity,
      securitySource: client._options.apiToken,
      retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
      retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
    };
    const requestRes = client._createRequest(context, {
      security: requestSecurity,
      method: "POST",
      baseURL: options?.serverURL,
      path,
      headers,
      body,
      userAgent: client._options.userAgent,
      timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
    }, options);
    if (!requestRes.ok) {
      return [requestRes, { status: "invalid" }];
    }
    const req = requestRes.value;
    const doResult = await client._do(req, {
      context,
      errorCodes: ["400", "401", "409", "429", "4XX", "5XX"],
      retryConfig: context.retryConfig,
      retryCodes: context.retryCodes
    });
    if (!doResult.ok) {
      return [doResult, { status: "request-error", request: req }];
    }
    const response = doResult.value;
    const [result] = await match(nil(200, voidType()), fail([400, 401, 409, 429, "4XX"]), fail("5XX"))(response, req);
    if (!result.ok) {
      return [result, { status: "complete", request: req, response }];
    }
    return [result, { status: "complete", request: req, response }];
  }

  // node_modules/@gleanwork/api-client/dist/esm/funcs/indexingDocumentsProcessAll.js
  function indexingDocumentsProcessAll(client, request, options) {
    return new APIPromise($do85(client, request, options));
  }
  async function $do85(client, request, options) {
    const parsed = safeParse(request, (value) => ProcessAllDocumentsRequest$outboundSchema.optional().parse(value), "Input validation failed");
    if (!parsed.ok) {
      return [parsed, { status: "invalid" }];
    }
    const payload = parsed.value;
    const body = payload === void 0 ? null : encodeJSON("body", payload, { explode: true });
    const path = pathToFunc("/api/index/v1/processalldocuments")();
    const headers = new Headers(compactMap({
      "Content-Type": "application/json",
      Accept: "*/*"
    }));
    const secConfig = await extractSecurity(client._options.apiToken);
    const securityInput = secConfig == null ? {} : { apiToken: secConfig };
    const requestSecurity = resolveGlobalSecurity(securityInput);
    const context = {
      options: client._options,
      baseURL: options?.serverURL ?? client._baseURL ?? "",
      operationID: "post_/api/index/v1/processalldocuments",
      oAuth2Scopes: [],
      resolvedSecurity: requestSecurity,
      securitySource: client._options.apiToken,
      retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
      retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
    };
    const requestRes = client._createRequest(context, {
      security: requestSecurity,
      method: "POST",
      baseURL: options?.serverURL,
      path,
      headers,
      body,
      userAgent: client._options.userAgent,
      timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
    }, options);
    if (!requestRes.ok) {
      return [requestRes, { status: "invalid" }];
    }
    const req = requestRes.value;
    const doResult = await client._do(req, {
      context,
      errorCodes: ["400", "401", "429", "4XX", "5XX"],
      retryConfig: context.retryConfig,
      retryCodes: context.retryCodes
    });
    if (!doResult.ok) {
      return [doResult, { status: "request-error", request: req }];
    }
    const response = doResult.value;
    const [result] = await match(nil(200, voidType()), fail([400, 401, 429, "4XX"]), fail("5XX"))(response, req);
    if (!result.ok) {
      return [result, { status: "complete", request: req, response }];
    }
    return [result, { status: "complete", request: req, response }];
  }

  // node_modules/@gleanwork/api-client/dist/esm/funcs/indexingDocumentsStatus.js
  function indexingDocumentsStatus(client, request, options) {
    return new APIPromise($do86(client, request, options));
  }
  async function $do86(client, request, options) {
    const parsed = safeParse(request, (value) => GetDocumentStatusRequest$outboundSchema.parse(value), "Input validation failed");
    if (!parsed.ok) {
      return [parsed, { status: "invalid" }];
    }
    const payload = parsed.value;
    const body = encodeJSON("body", payload, { explode: true });
    const path = pathToFunc("/api/index/v1/getdocumentstatus")();
    const headers = new Headers(compactMap({
      "Content-Type": "application/json",
      Accept: "application/json"
    }));
    const secConfig = await extractSecurity(client._options.apiToken);
    const securityInput = secConfig == null ? {} : { apiToken: secConfig };
    const requestSecurity = resolveGlobalSecurity(securityInput);
    const context = {
      options: client._options,
      baseURL: options?.serverURL ?? client._baseURL ?? "",
      operationID: "post_/api/index/v1/getdocumentstatus",
      oAuth2Scopes: [],
      resolvedSecurity: requestSecurity,
      securitySource: client._options.apiToken,
      retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
      retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
    };
    const requestRes = client._createRequest(context, {
      security: requestSecurity,
      method: "POST",
      baseURL: options?.serverURL,
      path,
      headers,
      body,
      userAgent: client._options.userAgent,
      timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
    }, options);
    if (!requestRes.ok) {
      return [requestRes, { status: "invalid" }];
    }
    const req = requestRes.value;
    const doResult = await client._do(req, {
      context,
      errorCodes: ["400", "401", "429", "4XX", "5XX"],
      retryConfig: context.retryConfig,
      retryCodes: context.retryCodes
    });
    if (!doResult.ok) {
      return [doResult, { status: "request-error", request: req }];
    }
    const response = doResult.value;
    const [result] = await match(json(200, GetDocumentStatusResponse$inboundSchema), fail([400, 401, 429, "4XX"]), fail("5XX"))(response, req);
    if (!result.ok) {
      return [result, { status: "complete", request: req, response }];
    }
    return [result, { status: "complete", request: req, response }];
  }

  // node_modules/@gleanwork/api-client/dist/esm/sdk/indexingdocuments.js
  var IndexingDocuments = class extends ClientSDK {
    /**
     * Index document
     *
     * @remarks
     * Adds a document to the index or updates an existing document.
     */
    async addOrUpdate(request, options) {
      return unwrapAsync(indexingDocumentsAddOrUpdate(this, request, options));
    }
    /**
     * Index documents
     *
     * @remarks
     * Adds or updates multiple documents in the index. Please refer to the [bulk indexing](https://developers.glean.com/indexing/documents/bulk-indexing/choosing-indexdocuments-vs-bulkindexdocuments) documentation for an explanation of when to use this endpoint.
     */
    async index(request, options) {
      return unwrapAsync(indexingDocumentsIndex(this, request, options));
    }
    /**
     * Bulk index documents
     *
     * @remarks
     * Replaces the documents in a datasource using paginated batch API calls. Please refer to the [bulk indexing](https://developers.glean.com/indexing/documents/bulk-upload-model) documentation for an explanation of how to use bulk endpoints.
     */
    async bulkIndex(request, options) {
      return unwrapAsync(indexingDocumentsBulkIndex(this, request, options));
    }
    /**
     * Schedules the processing of uploaded documents
     *
     * @remarks
     * Schedules the immediate processing of documents uploaded through the indexing API. By default the uploaded documents will be processed asynchronously but this API can be used to schedule processing of all documents on demand.
     *
     * If a `datasource` parameter is specified, processing is limited to that custom datasource. Without it, processing applies to all documents across all custom datasources.
     * #### Rate Limits
     * This endpoint is rate-limited to one usage every 3 hours. Exceeding this limit results in a 429 response code. Here's how the rate limit works:
     * 1. Calling `/processalldocuments` for datasource `foo` prevents another call for `foo` for 3 hours.
     * 2. Calling `/processalldocuments` for datasource `foo` doesn't affect immediate calls for `bar`.
     * 3. Calling `/processalldocuments` for all datasources prevents any datasource calls for 3 hours.
     * 4. Calling `/processalldocuments` for datasource `foo` doesn't affect immediate calls for all datasources.
     *
     * For more frequent document processing, contact Glean support.
     */
    async processAll(request, options) {
      return unwrapAsync(indexingDocumentsProcessAll(this, request, options));
    }
    /**
     * Delete document
     *
     * @remarks
     * Deletes the specified document from the index. Succeeds if document is not present.
     */
    async delete(request, options) {
      return unwrapAsync(indexingDocumentsDelete(this, request, options));
    }
    /**
     * Beta: Get document information
     *
     * @remarks
     * Gives various information that would help in debugging related to a particular document. Currently in beta, might undergo breaking changes without prior notice.
     *
     * Tip: Refer to the [Troubleshooting tutorial](https://developers.glean.com/indexing/debugging/datasource-config) for more information.
     */
    async debug(debugDocumentRequest, datasource, options) {
      return unwrapAsync(indexingDocumentsDebug(this, debugDocumentRequest, datasource, options));
    }
    /**
     * Beta: Get information of a batch of documents
     *
     * @remarks
     * Gives various information that would help in debugging related to a batch of documents. Currently in beta, might undergo breaking changes without prior notice.
     *
     * Tip: Refer to the [Troubleshooting tutorial](https://developers.glean.com/indexing/debugging/datasource-config) for more information.
     */
    async debugMany(debugDocumentsRequest, datasource, options) {
      return unwrapAsync(indexingDocumentsDebugMany(this, debugDocumentsRequest, datasource, options));
    }
    /**
     * Check document access
     *
     * @remarks
     * Check if a given user has access to access a document in a custom datasource
     *
     * Tip: Refer to the [Troubleshooting tutorial](https://developers.glean.com/indexing/debugging/datasource-config) for more information.
     */
    async checkAccess(request, options) {
      return unwrapAsync(indexingDocumentsCheckAccess(this, request, options));
    }
    /**
     * Get document upload and indexing status
     *
     * @remarks
     * Intended for debugging/validation. Fetches the current upload and indexing status of documents.
     *
     * Tip: Use [/debug/{datasource}/document](https://developers.glean.com/indexing/debugging/datasource-document) for richer information.
     *
     * @deprecated method: This will be removed in a future release, please migrate away from it as soon as possible.
     */
    async status(request, options) {
      return unwrapAsync(indexingDocumentsStatus(this, request, options));
    }
    /**
     * Get document count
     *
     * @remarks
     * Fetches document count for the specified custom datasource.
     *
     * Tip: Use [/debug/{datasource}/status](https://developers.glean.com/indexing/debugging/datasource-status) for richer information.
     *
     * @deprecated method: This will be removed in a future release, please migrate away from it as soon as possible.
     */
    async count(request, options) {
      return unwrapAsync(indexingDocumentsCount(this, request, options));
    }
  };

  // node_modules/@gleanwork/api-client/dist/esm/funcs/indexingShortcutsBulkIndex.js
  function indexingShortcutsBulkIndex(client, request, options) {
    return new APIPromise($do87(client, request, options));
  }
  async function $do87(client, request, options) {
    const parsed = safeParse(request, (value) => BulkIndexShortcutsRequest$outboundSchema.parse(value), "Input validation failed");
    if (!parsed.ok) {
      return [parsed, { status: "invalid" }];
    }
    const payload = parsed.value;
    const body = encodeJSON("body", payload, { explode: true });
    const path = pathToFunc("/api/index/v1/bulkindexshortcuts")();
    const headers = new Headers(compactMap({
      "Content-Type": "application/json",
      Accept: "*/*"
    }));
    const secConfig = await extractSecurity(client._options.apiToken);
    const securityInput = secConfig == null ? {} : { apiToken: secConfig };
    const requestSecurity = resolveGlobalSecurity(securityInput);
    const context = {
      options: client._options,
      baseURL: options?.serverURL ?? client._baseURL ?? "",
      operationID: "post_/api/index/v1/bulkindexshortcuts",
      oAuth2Scopes: [],
      resolvedSecurity: requestSecurity,
      securitySource: client._options.apiToken,
      retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
      retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
    };
    const requestRes = client._createRequest(context, {
      security: requestSecurity,
      method: "POST",
      baseURL: options?.serverURL,
      path,
      headers,
      body,
      userAgent: client._options.userAgent,
      timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
    }, options);
    if (!requestRes.ok) {
      return [requestRes, { status: "invalid" }];
    }
    const req = requestRes.value;
    const doResult = await client._do(req, {
      context,
      errorCodes: ["400", "401", "409", "4XX", "5XX"],
      retryConfig: context.retryConfig,
      retryCodes: context.retryCodes
    });
    if (!doResult.ok) {
      return [doResult, { status: "request-error", request: req }];
    }
    const response = doResult.value;
    const [result] = await match(nil(200, voidType()), fail([400, 401, 409, "4XX"]), fail("5XX"))(response, req);
    if (!result.ok) {
      return [result, { status: "complete", request: req, response }];
    }
    return [result, { status: "complete", request: req, response }];
  }

  // node_modules/@gleanwork/api-client/dist/esm/funcs/indexingShortcutsUpload.js
  function indexingShortcutsUpload(client, request, options) {
    return new APIPromise($do88(client, request, options));
  }
  async function $do88(client, request, options) {
    const parsed = safeParse(request, (value) => UploadShortcutsRequest$outboundSchema.parse(value), "Input validation failed");
    if (!parsed.ok) {
      return [parsed, { status: "invalid" }];
    }
    const payload = parsed.value;
    const body = encodeJSON("body", payload, { explode: true });
    const path = pathToFunc("/api/index/v1/uploadshortcuts")();
    const headers = new Headers(compactMap({
      "Content-Type": "application/json",
      Accept: "*/*"
    }));
    const secConfig = await extractSecurity(client._options.apiToken);
    const securityInput = secConfig == null ? {} : { apiToken: secConfig };
    const requestSecurity = resolveGlobalSecurity(securityInput);
    const context = {
      options: client._options,
      baseURL: options?.serverURL ?? client._baseURL ?? "",
      operationID: "post_/api/index/v1/uploadshortcuts",
      oAuth2Scopes: [],
      resolvedSecurity: requestSecurity,
      securitySource: client._options.apiToken,
      retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
      retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
    };
    const requestRes = client._createRequest(context, {
      security: requestSecurity,
      method: "POST",
      baseURL: options?.serverURL,
      path,
      headers,
      body,
      userAgent: client._options.userAgent,
      timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
    }, options);
    if (!requestRes.ok) {
      return [requestRes, { status: "invalid" }];
    }
    const req = requestRes.value;
    const doResult = await client._do(req, {
      context,
      errorCodes: ["400", "401", "409", "4XX", "5XX"],
      retryConfig: context.retryConfig,
      retryCodes: context.retryCodes
    });
    if (!doResult.ok) {
      return [doResult, { status: "request-error", request: req }];
    }
    const response = doResult.value;
    const [result] = await match(nil(200, voidType()), fail([400, 401, 409, "4XX"]), fail("5XX"))(response, req);
    if (!result.ok) {
      return [result, { status: "complete", request: req, response }];
    }
    return [result, { status: "complete", request: req, response }];
  }

  // node_modules/@gleanwork/api-client/dist/esm/sdk/indexingshortcuts.js
  var IndexingShortcuts = class extends ClientSDK {
    /**
     * Bulk index external shortcuts
     *
     * @remarks
     * Replaces all the currently indexed shortcuts using paginated batch API calls. Note that this endpoint is used for indexing shortcuts not hosted by Glean. If you want to upload shortcuts that would be hosted by Glean, please use the `/uploadshortcuts` endpoint. For information on what you can do with Golinks, which are Glean-hosted shortcuts, please refer to [this](https://help.glean.com/en/articles/5628838-how-go-links-work) page.
     */
    async bulkIndex(request, options) {
      return unwrapAsync(indexingShortcutsBulkIndex(this, request, options));
    }
    /**
     * Upload shortcuts
     *
     * @remarks
     * Creates glean shortcuts for uploaded shortcuts info. Glean would host the shortcuts, and they can be managed in the knowledge tab once uploaded.
     */
    async upload(request, options) {
      return unwrapAsync(indexingShortcutsUpload(this, request, options));
    }
  };

  // node_modules/@gleanwork/api-client/dist/esm/funcs/indexingPeopleBulkIndex.js
  function indexingPeopleBulkIndex(client, request, options) {
    return new APIPromise($do89(client, request, options));
  }
  async function $do89(client, request, options) {
    const parsed = safeParse(request, (value) => BulkIndexEmployeesRequest$outboundSchema.parse(value), "Input validation failed");
    if (!parsed.ok) {
      return [parsed, { status: "invalid" }];
    }
    const payload = parsed.value;
    const body = encodeJSON("body", payload, { explode: true });
    const path = pathToFunc("/api/index/v1/bulkindexemployees")();
    const headers = new Headers(compactMap({
      "Content-Type": "application/json",
      Accept: "*/*"
    }));
    const secConfig = await extractSecurity(client._options.apiToken);
    const securityInput = secConfig == null ? {} : { apiToken: secConfig };
    const requestSecurity = resolveGlobalSecurity(securityInput);
    const context = {
      options: client._options,
      baseURL: options?.serverURL ?? client._baseURL ?? "",
      operationID: "post_/api/index/v1/bulkindexemployees",
      oAuth2Scopes: [],
      resolvedSecurity: requestSecurity,
      securitySource: client._options.apiToken,
      retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
      retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
    };
    const requestRes = client._createRequest(context, {
      security: requestSecurity,
      method: "POST",
      baseURL: options?.serverURL,
      path,
      headers,
      body,
      userAgent: client._options.userAgent,
      timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
    }, options);
    if (!requestRes.ok) {
      return [requestRes, { status: "invalid" }];
    }
    const req = requestRes.value;
    const doResult = await client._do(req, {
      context,
      errorCodes: ["400", "401", "409", "4XX", "5XX"],
      retryConfig: context.retryConfig,
      retryCodes: context.retryCodes
    });
    if (!doResult.ok) {
      return [doResult, { status: "request-error", request: req }];
    }
    const response = doResult.value;
    const [result] = await match(nil(200, voidType()), fail([400, 401, 409, "4XX"]), fail("5XX"))(response, req);
    if (!result.ok) {
      return [result, { status: "complete", request: req, response }];
    }
    return [result, { status: "complete", request: req, response }];
  }

  // node_modules/@gleanwork/api-client/dist/esm/funcs/indexingPeopleBulkIndexTeams.js
  function indexingPeopleBulkIndexTeams(client, request, options) {
    return new APIPromise($do90(client, request, options));
  }
  async function $do90(client, request, options) {
    const parsed = safeParse(request, (value) => BulkIndexTeamsRequest$outboundSchema.parse(value), "Input validation failed");
    if (!parsed.ok) {
      return [parsed, { status: "invalid" }];
    }
    const payload = parsed.value;
    const body = encodeJSON("body", payload, { explode: true });
    const path = pathToFunc("/api/index/v1/bulkindexteams")();
    const headers = new Headers(compactMap({
      "Content-Type": "application/json",
      Accept: "*/*"
    }));
    const secConfig = await extractSecurity(client._options.apiToken);
    const securityInput = secConfig == null ? {} : { apiToken: secConfig };
    const requestSecurity = resolveGlobalSecurity(securityInput);
    const context = {
      options: client._options,
      baseURL: options?.serverURL ?? client._baseURL ?? "",
      operationID: "post_/api/index/v1/bulkindexteams",
      oAuth2Scopes: [],
      resolvedSecurity: requestSecurity,
      securitySource: client._options.apiToken,
      retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
      retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
    };
    const requestRes = client._createRequest(context, {
      security: requestSecurity,
      method: "POST",
      baseURL: options?.serverURL,
      path,
      headers,
      body,
      userAgent: client._options.userAgent,
      timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
    }, options);
    if (!requestRes.ok) {
      return [requestRes, { status: "invalid" }];
    }
    const req = requestRes.value;
    const doResult = await client._do(req, {
      context,
      errorCodes: ["400", "401", "409", "4XX", "5XX"],
      retryConfig: context.retryConfig,
      retryCodes: context.retryCodes
    });
    if (!doResult.ok) {
      return [doResult, { status: "request-error", request: req }];
    }
    const response = doResult.value;
    const [result] = await match(nil(200, voidType()), fail([400, 401, 409, "4XX"]), fail("5XX"))(response, req);
    if (!result.ok) {
      return [result, { status: "complete", request: req, response }];
    }
    return [result, { status: "complete", request: req, response }];
  }

  // node_modules/@gleanwork/api-client/dist/esm/funcs/indexingPeopleCount.js
  function indexingPeopleCount(client, request, options) {
    return new APIPromise($do91(client, request, options));
  }
  async function $do91(client, request, options) {
    const parsed = safeParse(request, (value) => GetUserCountRequest$outboundSchema.parse(value), "Input validation failed");
    if (!parsed.ok) {
      return [parsed, { status: "invalid" }];
    }
    const payload = parsed.value;
    const body = encodeJSON("body", payload, { explode: true });
    const path = pathToFunc("/api/index/v1/getusercount")();
    const headers = new Headers(compactMap({
      "Content-Type": "application/json",
      Accept: "application/json"
    }));
    const secConfig = await extractSecurity(client._options.apiToken);
    const securityInput = secConfig == null ? {} : { apiToken: secConfig };
    const requestSecurity = resolveGlobalSecurity(securityInput);
    const context = {
      options: client._options,
      baseURL: options?.serverURL ?? client._baseURL ?? "",
      operationID: "post_/api/index/v1/getusercount",
      oAuth2Scopes: [],
      resolvedSecurity: requestSecurity,
      securitySource: client._options.apiToken,
      retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
      retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
    };
    const requestRes = client._createRequest(context, {
      security: requestSecurity,
      method: "POST",
      baseURL: options?.serverURL,
      path,
      headers,
      body,
      userAgent: client._options.userAgent,
      timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
    }, options);
    if (!requestRes.ok) {
      return [requestRes, { status: "invalid" }];
    }
    const req = requestRes.value;
    const doResult = await client._do(req, {
      context,
      errorCodes: ["400", "401", "409", "4XX", "5XX"],
      retryConfig: context.retryConfig,
      retryCodes: context.retryCodes
    });
    if (!doResult.ok) {
      return [doResult, { status: "request-error", request: req }];
    }
    const response = doResult.value;
    const [result] = await match(json(200, GetUserCountResponse$inboundSchema), fail([400, 401, 409, "4XX"]), fail("5XX"))(response, req);
    if (!result.ok) {
      return [result, { status: "complete", request: req, response }];
    }
    return [result, { status: "complete", request: req, response }];
  }

  // node_modules/@gleanwork/api-client/dist/esm/funcs/indexingPeopleDebug.js
  function indexingPeopleDebug(client, debugUserRequest, datasource, options) {
    return new APIPromise($do92(client, debugUserRequest, datasource, options));
  }
  async function $do92(client, debugUserRequest, datasource, options) {
    const input = {
      debugUserRequest,
      datasource
    };
    const parsed = safeParse(input, (value) => PostApiIndexV1DebugDatasourceUserRequest$outboundSchema.parse(value), "Input validation failed");
    if (!parsed.ok) {
      return [parsed, { status: "invalid" }];
    }
    const payload = parsed.value;
    const body = encodeJSON("body", payload.DebugUserRequest, { explode: true });
    const pathParams = {
      datasource: encodeSimple("datasource", payload.datasource, {
        explode: false,
        charEncoding: "percent"
      })
    };
    const path = pathToFunc("/api/index/v1/debug/{datasource}/user")(pathParams);
    const headers = new Headers(compactMap({
      "Content-Type": "application/json",
      Accept: "application/json; charset=UTF-8"
    }));
    const secConfig = await extractSecurity(client._options.apiToken);
    const securityInput = secConfig == null ? {} : { apiToken: secConfig };
    const requestSecurity = resolveGlobalSecurity(securityInput);
    const context = {
      options: client._options,
      baseURL: options?.serverURL ?? client._baseURL ?? "",
      operationID: "post_/api/index/v1/debug/{datasource}/user",
      oAuth2Scopes: [],
      resolvedSecurity: requestSecurity,
      securitySource: client._options.apiToken,
      retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
      retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
    };
    const requestRes = client._createRequest(context, {
      security: requestSecurity,
      method: "POST",
      baseURL: options?.serverURL,
      path,
      headers,
      body,
      userAgent: client._options.userAgent,
      timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
    }, options);
    if (!requestRes.ok) {
      return [requestRes, { status: "invalid" }];
    }
    const req = requestRes.value;
    const doResult = await client._do(req, {
      context,
      errorCodes: ["400", "401", "4XX", "5XX"],
      retryConfig: context.retryConfig,
      retryCodes: context.retryCodes
    });
    if (!doResult.ok) {
      return [doResult, { status: "request-error", request: req }];
    }
    const response = doResult.value;
    const [result] = await match(json(200, DebugUserResponse$inboundSchema, {
      ctype: "application/json; charset=UTF-8"
    }), fail([400, 401, "4XX"]), fail("5XX"))(response, req);
    if (!result.ok) {
      return [result, { status: "complete", request: req, response }];
    }
    return [result, { status: "complete", request: req, response }];
  }

  // node_modules/@gleanwork/api-client/dist/esm/funcs/indexingPeopleDelete.js
  function indexingPeopleDelete(client, request, options) {
    return new APIPromise($do93(client, request, options));
  }
  async function $do93(client, request, options) {
    const parsed = safeParse(request, (value) => DeleteEmployeeRequest$outboundSchema.parse(value), "Input validation failed");
    if (!parsed.ok) {
      return [parsed, { status: "invalid" }];
    }
    const payload = parsed.value;
    const body = encodeJSON("body", payload, { explode: true });
    const path = pathToFunc("/api/index/v1/deleteemployee")();
    const headers = new Headers(compactMap({
      "Content-Type": "application/json",
      Accept: "*/*"
    }));
    const secConfig = await extractSecurity(client._options.apiToken);
    const securityInput = secConfig == null ? {} : { apiToken: secConfig };
    const requestSecurity = resolveGlobalSecurity(securityInput);
    const context = {
      options: client._options,
      baseURL: options?.serverURL ?? client._baseURL ?? "",
      operationID: "post_/api/index/v1/deleteemployee",
      oAuth2Scopes: [],
      resolvedSecurity: requestSecurity,
      securitySource: client._options.apiToken,
      retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
      retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
    };
    const requestRes = client._createRequest(context, {
      security: requestSecurity,
      method: "POST",
      baseURL: options?.serverURL,
      path,
      headers,
      body,
      userAgent: client._options.userAgent,
      timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
    }, options);
    if (!requestRes.ok) {
      return [requestRes, { status: "invalid" }];
    }
    const req = requestRes.value;
    const doResult = await client._do(req, {
      context,
      errorCodes: ["400", "401", "409", "4XX", "5XX"],
      retryConfig: context.retryConfig,
      retryCodes: context.retryCodes
    });
    if (!doResult.ok) {
      return [doResult, { status: "request-error", request: req }];
    }
    const response = doResult.value;
    const [result] = await match(nil(200, voidType()), fail([400, 401, 409, "4XX"]), fail("5XX"))(response, req);
    if (!result.ok) {
      return [result, { status: "complete", request: req, response }];
    }
    return [result, { status: "complete", request: req, response }];
  }

  // node_modules/@gleanwork/api-client/dist/esm/funcs/indexingPeopleDeleteTeam.js
  function indexingPeopleDeleteTeam(client, request, options) {
    return new APIPromise($do94(client, request, options));
  }
  async function $do94(client, request, options) {
    const parsed = safeParse(request, (value) => DeleteTeamRequest$outboundSchema.parse(value), "Input validation failed");
    if (!parsed.ok) {
      return [parsed, { status: "invalid" }];
    }
    const payload = parsed.value;
    const body = encodeJSON("body", payload, { explode: true });
    const path = pathToFunc("/api/index/v1/deleteteam")();
    const headers = new Headers(compactMap({
      "Content-Type": "application/json",
      Accept: "*/*"
    }));
    const secConfig = await extractSecurity(client._options.apiToken);
    const securityInput = secConfig == null ? {} : { apiToken: secConfig };
    const requestSecurity = resolveGlobalSecurity(securityInput);
    const context = {
      options: client._options,
      baseURL: options?.serverURL ?? client._baseURL ?? "",
      operationID: "post_/api/index/v1/deleteteam",
      oAuth2Scopes: [],
      resolvedSecurity: requestSecurity,
      securitySource: client._options.apiToken,
      retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
      retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
    };
    const requestRes = client._createRequest(context, {
      security: requestSecurity,
      method: "POST",
      baseURL: options?.serverURL,
      path,
      headers,
      body,
      userAgent: client._options.userAgent,
      timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
    }, options);
    if (!requestRes.ok) {
      return [requestRes, { status: "invalid" }];
    }
    const req = requestRes.value;
    const doResult = await client._do(req, {
      context,
      errorCodes: ["400", "401", "409", "4XX", "5XX"],
      retryConfig: context.retryConfig,
      retryCodes: context.retryCodes
    });
    if (!doResult.ok) {
      return [doResult, { status: "request-error", request: req }];
    }
    const response = doResult.value;
    const [result] = await match(nil(200, voidType()), fail([400, 401, 409, "4XX"]), fail("5XX"))(response, req);
    if (!result.ok) {
      return [result, { status: "complete", request: req, response }];
    }
    return [result, { status: "complete", request: req, response }];
  }

  // node_modules/@gleanwork/api-client/dist/esm/funcs/indexingPeopleIndex.js
  function indexingPeopleIndex(client, request, options) {
    return new APIPromise($do95(client, request, options));
  }
  async function $do95(client, request, options) {
    const parsed = safeParse(request, (value) => IndexEmployeeRequest$outboundSchema.parse(value), "Input validation failed");
    if (!parsed.ok) {
      return [parsed, { status: "invalid" }];
    }
    const payload = parsed.value;
    const body = encodeJSON("body", payload, { explode: true });
    const path = pathToFunc("/api/index/v1/indexemployee")();
    const headers = new Headers(compactMap({
      "Content-Type": "application/json",
      Accept: "*/*"
    }));
    const secConfig = await extractSecurity(client._options.apiToken);
    const securityInput = secConfig == null ? {} : { apiToken: secConfig };
    const requestSecurity = resolveGlobalSecurity(securityInput);
    const context = {
      options: client._options,
      baseURL: options?.serverURL ?? client._baseURL ?? "",
      operationID: "post_/api/index/v1/indexemployee",
      oAuth2Scopes: [],
      resolvedSecurity: requestSecurity,
      securitySource: client._options.apiToken,
      retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
      retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
    };
    const requestRes = client._createRequest(context, {
      security: requestSecurity,
      method: "POST",
      baseURL: options?.serverURL,
      path,
      headers,
      body,
      userAgent: client._options.userAgent,
      timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
    }, options);
    if (!requestRes.ok) {
      return [requestRes, { status: "invalid" }];
    }
    const req = requestRes.value;
    const doResult = await client._do(req, {
      context,
      errorCodes: ["400", "401", "409", "4XX", "5XX"],
      retryConfig: context.retryConfig,
      retryCodes: context.retryCodes
    });
    if (!doResult.ok) {
      return [doResult, { status: "request-error", request: req }];
    }
    const response = doResult.value;
    const [result] = await match(nil(200, voidType()), fail([400, 401, 409, "4XX"]), fail("5XX"))(response, req);
    if (!result.ok) {
      return [result, { status: "complete", request: req, response }];
    }
    return [result, { status: "complete", request: req, response }];
  }

  // node_modules/@gleanwork/api-client/dist/esm/funcs/indexingPeopleIndexTeam.js
  function indexingPeopleIndexTeam(client, request, options) {
    return new APIPromise($do96(client, request, options));
  }
  async function $do96(client, request, options) {
    const parsed = safeParse(request, (value) => IndexTeamRequest$outboundSchema.parse(value), "Input validation failed");
    if (!parsed.ok) {
      return [parsed, { status: "invalid" }];
    }
    const payload = parsed.value;
    const body = encodeJSON("body", payload, { explode: true });
    const path = pathToFunc("/api/index/v1/indexteam")();
    const headers = new Headers(compactMap({
      "Content-Type": "application/json",
      Accept: "*/*"
    }));
    const secConfig = await extractSecurity(client._options.apiToken);
    const securityInput = secConfig == null ? {} : { apiToken: secConfig };
    const requestSecurity = resolveGlobalSecurity(securityInput);
    const context = {
      options: client._options,
      baseURL: options?.serverURL ?? client._baseURL ?? "",
      operationID: "post_/api/index/v1/indexteam",
      oAuth2Scopes: [],
      resolvedSecurity: requestSecurity,
      securitySource: client._options.apiToken,
      retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
      retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
    };
    const requestRes = client._createRequest(context, {
      security: requestSecurity,
      method: "POST",
      baseURL: options?.serverURL,
      path,
      headers,
      body,
      userAgent: client._options.userAgent,
      timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
    }, options);
    if (!requestRes.ok) {
      return [requestRes, { status: "invalid" }];
    }
    const req = requestRes.value;
    const doResult = await client._do(req, {
      context,
      errorCodes: ["400", "401", "409", "4XX", "5XX"],
      retryConfig: context.retryConfig,
      retryCodes: context.retryCodes
    });
    if (!doResult.ok) {
      return [doResult, { status: "request-error", request: req }];
    }
    const response = doResult.value;
    const [result] = await match(nil(200, voidType()), fail([400, 401, 409, "4XX"]), fail("5XX"))(response, req);
    if (!result.ok) {
      return [result, { status: "complete", request: req, response }];
    }
    return [result, { status: "complete", request: req, response }];
  }

  // node_modules/@gleanwork/api-client/dist/esm/funcs/indexingPeopleProcessAllEmployeesAndTeams.js
  function indexingPeopleProcessAllEmployeesAndTeams(client, options) {
    return new APIPromise($do97(client, options));
  }
  async function $do97(client, options) {
    const path = pathToFunc("/api/index/v1/processallemployeesandteams")();
    const headers = new Headers(compactMap({
      Accept: "*/*"
    }));
    const secConfig = await extractSecurity(client._options.apiToken);
    const securityInput = secConfig == null ? {} : { apiToken: secConfig };
    const requestSecurity = resolveGlobalSecurity(securityInput);
    const context = {
      options: client._options,
      baseURL: options?.serverURL ?? client._baseURL ?? "",
      operationID: "post_/api/index/v1/processallemployeesandteams",
      oAuth2Scopes: [],
      resolvedSecurity: requestSecurity,
      securitySource: client._options.apiToken,
      retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
      retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
    };
    const requestRes = client._createRequest(context, {
      security: requestSecurity,
      method: "POST",
      baseURL: options?.serverURL,
      path,
      headers,
      userAgent: client._options.userAgent,
      timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
    }, options);
    if (!requestRes.ok) {
      return [requestRes, { status: "invalid" }];
    }
    const req = requestRes.value;
    const doResult = await client._do(req, {
      context,
      errorCodes: ["400", "401", "429", "4XX", "5XX"],
      retryConfig: context.retryConfig,
      retryCodes: context.retryCodes
    });
    if (!doResult.ok) {
      return [doResult, { status: "request-error", request: req }];
    }
    const response = doResult.value;
    const [result] = await match(nil(200, voidType()), fail([400, 401, 429, "4XX"]), fail("5XX"))(response, req);
    if (!result.ok) {
      return [result, { status: "complete", request: req, response }];
    }
    return [result, { status: "complete", request: req, response }];
  }

  // node_modules/@gleanwork/api-client/dist/esm/sdk/people.js
  var People = class extends ClientSDK {
    /**
     * Beta: Get user information
     *
     * @remarks
     * Gives various information that would help in debugging related to a particular user. Currently in beta, might undergo breaking changes without prior notice.
     *
     * Tip: Refer to the [Troubleshooting tutorial](https://developers.glean.com/indexing/debugging/datasource-config) for more information.
     */
    async debug(debugUserRequest, datasource, options) {
      return unwrapAsync(indexingPeopleDebug(this, debugUserRequest, datasource, options));
    }
    /**
     * Get user count
     *
     * @remarks
     * Fetches user count for the specified custom datasource.
     *
     * Tip: Use [/debug/{datasource}/status](https://developers.glean.com/indexing/debugging/datasource-status) for richer information.
     *
     * @deprecated method: This will be removed in a future release, please migrate away from it as soon as possible.
     */
    async count(request, options) {
      return unwrapAsync(indexingPeopleCount(this, request, options));
    }
    /**
     * Index employee
     *
     * @remarks
     * Adds an employee or updates information about an employee
     */
    async index(request, options) {
      return unwrapAsync(indexingPeopleIndex(this, request, options));
    }
    /**
     * Bulk index employees
     *
     * @remarks
     * Replaces all the currently indexed employees using paginated batch API calls. Please refer to the [bulk indexing](https://developers.glean.com/indexing/documents/bulk-upload-model) documentation for an explanation of how to use bulk endpoints.
     */
    async bulkIndex(request, options) {
      return unwrapAsync(indexingPeopleBulkIndex(this, request, options));
    }
    /**
     * Schedules the processing of uploaded employees and teams
     *
     * @remarks
     * Schedules the immediate processing of employees and teams uploaded through the indexing API. By default all uploaded people data will be processed asynchronously but this API can be used to schedule its processing on demand.
     */
    async processAllEmployeesAndTeams(options) {
      return unwrapAsync(indexingPeopleProcessAllEmployeesAndTeams(this, options));
    }
    /**
     * Delete employee
     *
     * @remarks
     * Delete an employee. Silently succeeds if employee is not present.
     */
    async delete(request, options) {
      return unwrapAsync(indexingPeopleDelete(this, request, options));
    }
    /**
     * Index team
     *
     * @remarks
     * Adds a team or updates information about a team
     */
    async indexTeam(request, options) {
      return unwrapAsync(indexingPeopleIndexTeam(this, request, options));
    }
    /**
     * Delete team
     *
     * @remarks
     * Delete a team based on provided id.
     */
    async deleteTeam(request, options) {
      return unwrapAsync(indexingPeopleDeleteTeam(this, request, options));
    }
    /**
     * Bulk index teams
     *
     * @remarks
     * Replaces all the currently indexed teams using paginated batch API calls. Please refer to the [bulk indexing](https://developers.glean.com/indexing/documents/bulk-upload-model) documentation for an explanation of how to use bulk endpoints.
     */
    async bulkIndexTeams(request, options) {
      return unwrapAsync(indexingPeopleBulkIndexTeams(this, request, options));
    }
  };

  // node_modules/@gleanwork/api-client/dist/esm/funcs/indexingPermissionsAuthorizeBetaUsers.js
  function indexingPermissionsAuthorizeBetaUsers(client, request, options) {
    return new APIPromise($do98(client, request, options));
  }
  async function $do98(client, request, options) {
    const parsed = safeParse(request, (value) => GreenlistUsersRequest$outboundSchema.parse(value), "Input validation failed");
    if (!parsed.ok) {
      return [parsed, { status: "invalid" }];
    }
    const payload = parsed.value;
    const body = encodeJSON("body", payload, { explode: true });
    const path = pathToFunc("/api/index/v1/betausers")();
    const headers = new Headers(compactMap({
      "Content-Type": "application/json",
      Accept: "*/*"
    }));
    const secConfig = await extractSecurity(client._options.apiToken);
    const securityInput = secConfig == null ? {} : { apiToken: secConfig };
    const requestSecurity = resolveGlobalSecurity(securityInput);
    const context = {
      options: client._options,
      baseURL: options?.serverURL ?? client._baseURL ?? "",
      operationID: "post_/api/index/v1/betausers",
      oAuth2Scopes: [],
      resolvedSecurity: requestSecurity,
      securitySource: client._options.apiToken,
      retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
      retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
    };
    const requestRes = client._createRequest(context, {
      security: requestSecurity,
      method: "POST",
      baseURL: options?.serverURL,
      path,
      headers,
      body,
      userAgent: client._options.userAgent,
      timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
    }, options);
    if (!requestRes.ok) {
      return [requestRes, { status: "invalid" }];
    }
    const req = requestRes.value;
    const doResult = await client._do(req, {
      context,
      errorCodes: ["400", "401", "409", "4XX", "5XX"],
      retryConfig: context.retryConfig,
      retryCodes: context.retryCodes
    });
    if (!doResult.ok) {
      return [doResult, { status: "request-error", request: req }];
    }
    const response = doResult.value;
    const [result] = await match(nil(200, voidType()), fail([400, 401, 409, "4XX"]), fail("5XX"))(response, req);
    if (!result.ok) {
      return [result, { status: "complete", request: req, response }];
    }
    return [result, { status: "complete", request: req, response }];
  }

  // node_modules/@gleanwork/api-client/dist/esm/funcs/indexingPermissionsBulkIndexGroups.js
  function indexingPermissionsBulkIndexGroups(client, request, options) {
    return new APIPromise($do99(client, request, options));
  }
  async function $do99(client, request, options) {
    const parsed = safeParse(request, (value) => BulkIndexGroupsRequest$outboundSchema.parse(value), "Input validation failed");
    if (!parsed.ok) {
      return [parsed, { status: "invalid" }];
    }
    const payload = parsed.value;
    const body = encodeJSON("body", payload, { explode: true });
    const path = pathToFunc("/api/index/v1/bulkindexgroups")();
    const headers = new Headers(compactMap({
      "Content-Type": "application/json",
      Accept: "*/*"
    }));
    const secConfig = await extractSecurity(client._options.apiToken);
    const securityInput = secConfig == null ? {} : { apiToken: secConfig };
    const requestSecurity = resolveGlobalSecurity(securityInput);
    const context = {
      options: client._options,
      baseURL: options?.serverURL ?? client._baseURL ?? "",
      operationID: "post_/api/index/v1/bulkindexgroups",
      oAuth2Scopes: [],
      resolvedSecurity: requestSecurity,
      securitySource: client._options.apiToken,
      retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
      retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
    };
    const requestRes = client._createRequest(context, {
      security: requestSecurity,
      method: "POST",
      baseURL: options?.serverURL,
      path,
      headers,
      body,
      userAgent: client._options.userAgent,
      timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
    }, options);
    if (!requestRes.ok) {
      return [requestRes, { status: "invalid" }];
    }
    const req = requestRes.value;
    const doResult = await client._do(req, {
      context,
      errorCodes: ["400", "401", "409", "4XX", "5XX"],
      retryConfig: context.retryConfig,
      retryCodes: context.retryCodes
    });
    if (!doResult.ok) {
      return [doResult, { status: "request-error", request: req }];
    }
    const response = doResult.value;
    const [result] = await match(nil(200, voidType()), fail([400, 401, 409, "4XX"]), fail("5XX"))(response, req);
    if (!result.ok) {
      return [result, { status: "complete", request: req, response }];
    }
    return [result, { status: "complete", request: req, response }];
  }

  // node_modules/@gleanwork/api-client/dist/esm/funcs/indexingPermissionsBulkIndexMemberships.js
  function indexingPermissionsBulkIndexMemberships(client, request, options) {
    return new APIPromise($do100(client, request, options));
  }
  async function $do100(client, request, options) {
    const parsed = safeParse(request, (value) => BulkIndexMembershipsRequest$outboundSchema.parse(value), "Input validation failed");
    if (!parsed.ok) {
      return [parsed, { status: "invalid" }];
    }
    const payload = parsed.value;
    const body = encodeJSON("body", payload, { explode: true });
    const path = pathToFunc("/api/index/v1/bulkindexmemberships")();
    const headers = new Headers(compactMap({
      "Content-Type": "application/json",
      Accept: "*/*"
    }));
    const secConfig = await extractSecurity(client._options.apiToken);
    const securityInput = secConfig == null ? {} : { apiToken: secConfig };
    const requestSecurity = resolveGlobalSecurity(securityInput);
    const context = {
      options: client._options,
      baseURL: options?.serverURL ?? client._baseURL ?? "",
      operationID: "post_/api/index/v1/bulkindexmemberships",
      oAuth2Scopes: [],
      resolvedSecurity: requestSecurity,
      securitySource: client._options.apiToken,
      retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
      retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
    };
    const requestRes = client._createRequest(context, {
      security: requestSecurity,
      method: "POST",
      baseURL: options?.serverURL,
      path,
      headers,
      body,
      userAgent: client._options.userAgent,
      timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
    }, options);
    if (!requestRes.ok) {
      return [requestRes, { status: "invalid" }];
    }
    const req = requestRes.value;
    const doResult = await client._do(req, {
      context,
      errorCodes: ["400", "401", "409", "4XX", "5XX"],
      retryConfig: context.retryConfig,
      retryCodes: context.retryCodes
    });
    if (!doResult.ok) {
      return [doResult, { status: "request-error", request: req }];
    }
    const response = doResult.value;
    const [result] = await match(nil(200, voidType()), fail([400, 401, 409, "4XX"]), fail("5XX"))(response, req);
    if (!result.ok) {
      return [result, { status: "complete", request: req, response }];
    }
    return [result, { status: "complete", request: req, response }];
  }

  // node_modules/@gleanwork/api-client/dist/esm/funcs/indexingPermissionsBulkIndexUsers.js
  function indexingPermissionsBulkIndexUsers(client, request, options) {
    return new APIPromise($do101(client, request, options));
  }
  async function $do101(client, request, options) {
    const parsed = safeParse(request, (value) => BulkIndexUsersRequest$outboundSchema.parse(value), "Input validation failed");
    if (!parsed.ok) {
      return [parsed, { status: "invalid" }];
    }
    const payload = parsed.value;
    const body = encodeJSON("body", payload, { explode: true });
    const path = pathToFunc("/api/index/v1/bulkindexusers")();
    const headers = new Headers(compactMap({
      "Content-Type": "application/json",
      Accept: "*/*"
    }));
    const secConfig = await extractSecurity(client._options.apiToken);
    const securityInput = secConfig == null ? {} : { apiToken: secConfig };
    const requestSecurity = resolveGlobalSecurity(securityInput);
    const context = {
      options: client._options,
      baseURL: options?.serverURL ?? client._baseURL ?? "",
      operationID: "post_/api/index/v1/bulkindexusers",
      oAuth2Scopes: [],
      resolvedSecurity: requestSecurity,
      securitySource: client._options.apiToken,
      retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
      retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
    };
    const requestRes = client._createRequest(context, {
      security: requestSecurity,
      method: "POST",
      baseURL: options?.serverURL,
      path,
      headers,
      body,
      userAgent: client._options.userAgent,
      timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
    }, options);
    if (!requestRes.ok) {
      return [requestRes, { status: "invalid" }];
    }
    const req = requestRes.value;
    const doResult = await client._do(req, {
      context,
      errorCodes: ["400", "401", "409", "4XX", "5XX"],
      retryConfig: context.retryConfig,
      retryCodes: context.retryCodes
    });
    if (!doResult.ok) {
      return [doResult, { status: "request-error", request: req }];
    }
    const response = doResult.value;
    const [result] = await match(nil(200, voidType()), fail([400, 401, 409, "4XX"]), fail("5XX"))(response, req);
    if (!result.ok) {
      return [result, { status: "complete", request: req, response }];
    }
    return [result, { status: "complete", request: req, response }];
  }

  // node_modules/@gleanwork/api-client/dist/esm/funcs/indexingPermissionsDeleteGroup.js
  function indexingPermissionsDeleteGroup(client, request, options) {
    return new APIPromise($do102(client, request, options));
  }
  async function $do102(client, request, options) {
    const parsed = safeParse(request, (value) => DeleteGroupRequest$outboundSchema.parse(value), "Input validation failed");
    if (!parsed.ok) {
      return [parsed, { status: "invalid" }];
    }
    const payload = parsed.value;
    const body = encodeJSON("body", payload, { explode: true });
    const path = pathToFunc("/api/index/v1/deletegroup")();
    const headers = new Headers(compactMap({
      "Content-Type": "application/json",
      Accept: "*/*"
    }));
    const secConfig = await extractSecurity(client._options.apiToken);
    const securityInput = secConfig == null ? {} : { apiToken: secConfig };
    const requestSecurity = resolveGlobalSecurity(securityInput);
    const context = {
      options: client._options,
      baseURL: options?.serverURL ?? client._baseURL ?? "",
      operationID: "post_/api/index/v1/deletegroup",
      oAuth2Scopes: [],
      resolvedSecurity: requestSecurity,
      securitySource: client._options.apiToken,
      retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
      retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
    };
    const requestRes = client._createRequest(context, {
      security: requestSecurity,
      method: "POST",
      baseURL: options?.serverURL,
      path,
      headers,
      body,
      userAgent: client._options.userAgent,
      timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
    }, options);
    if (!requestRes.ok) {
      return [requestRes, { status: "invalid" }];
    }
    const req = requestRes.value;
    const doResult = await client._do(req, {
      context,
      errorCodes: ["400", "401", "409", "4XX", "5XX"],
      retryConfig: context.retryConfig,
      retryCodes: context.retryCodes
    });
    if (!doResult.ok) {
      return [doResult, { status: "request-error", request: req }];
    }
    const response = doResult.value;
    const [result] = await match(nil(200, voidType()), fail([400, 401, 409, "4XX"]), fail("5XX"))(response, req);
    if (!result.ok) {
      return [result, { status: "complete", request: req, response }];
    }
    return [result, { status: "complete", request: req, response }];
  }

  // node_modules/@gleanwork/api-client/dist/esm/funcs/indexingPermissionsDeleteMembership.js
  function indexingPermissionsDeleteMembership(client, request, options) {
    return new APIPromise($do103(client, request, options));
  }
  async function $do103(client, request, options) {
    const parsed = safeParse(request, (value) => DeleteMembershipRequest$outboundSchema.parse(value), "Input validation failed");
    if (!parsed.ok) {
      return [parsed, { status: "invalid" }];
    }
    const payload = parsed.value;
    const body = encodeJSON("body", payload, { explode: true });
    const path = pathToFunc("/api/index/v1/deletemembership")();
    const headers = new Headers(compactMap({
      "Content-Type": "application/json",
      Accept: "*/*"
    }));
    const secConfig = await extractSecurity(client._options.apiToken);
    const securityInput = secConfig == null ? {} : { apiToken: secConfig };
    const requestSecurity = resolveGlobalSecurity(securityInput);
    const context = {
      options: client._options,
      baseURL: options?.serverURL ?? client._baseURL ?? "",
      operationID: "post_/api/index/v1/deletemembership",
      oAuth2Scopes: [],
      resolvedSecurity: requestSecurity,
      securitySource: client._options.apiToken,
      retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
      retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
    };
    const requestRes = client._createRequest(context, {
      security: requestSecurity,
      method: "POST",
      baseURL: options?.serverURL,
      path,
      headers,
      body,
      userAgent: client._options.userAgent,
      timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
    }, options);
    if (!requestRes.ok) {
      return [requestRes, { status: "invalid" }];
    }
    const req = requestRes.value;
    const doResult = await client._do(req, {
      context,
      errorCodes: ["400", "401", "409", "4XX", "5XX"],
      retryConfig: context.retryConfig,
      retryCodes: context.retryCodes
    });
    if (!doResult.ok) {
      return [doResult, { status: "request-error", request: req }];
    }
    const response = doResult.value;
    const [result] = await match(nil(200, voidType()), fail([400, 401, 409, "4XX"]), fail("5XX"))(response, req);
    if (!result.ok) {
      return [result, { status: "complete", request: req, response }];
    }
    return [result, { status: "complete", request: req, response }];
  }

  // node_modules/@gleanwork/api-client/dist/esm/funcs/indexingPermissionsDeleteUser.js
  function indexingPermissionsDeleteUser(client, request, options) {
    return new APIPromise($do104(client, request, options));
  }
  async function $do104(client, request, options) {
    const parsed = safeParse(request, (value) => DeleteUserRequest$outboundSchema.parse(value), "Input validation failed");
    if (!parsed.ok) {
      return [parsed, { status: "invalid" }];
    }
    const payload = parsed.value;
    const body = encodeJSON("body", payload, { explode: true });
    const path = pathToFunc("/api/index/v1/deleteuser")();
    const headers = new Headers(compactMap({
      "Content-Type": "application/json",
      Accept: "*/*"
    }));
    const secConfig = await extractSecurity(client._options.apiToken);
    const securityInput = secConfig == null ? {} : { apiToken: secConfig };
    const requestSecurity = resolveGlobalSecurity(securityInput);
    const context = {
      options: client._options,
      baseURL: options?.serverURL ?? client._baseURL ?? "",
      operationID: "post_/api/index/v1/deleteuser",
      oAuth2Scopes: [],
      resolvedSecurity: requestSecurity,
      securitySource: client._options.apiToken,
      retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
      retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
    };
    const requestRes = client._createRequest(context, {
      security: requestSecurity,
      method: "POST",
      baseURL: options?.serverURL,
      path,
      headers,
      body,
      userAgent: client._options.userAgent,
      timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
    }, options);
    if (!requestRes.ok) {
      return [requestRes, { status: "invalid" }];
    }
    const req = requestRes.value;
    const doResult = await client._do(req, {
      context,
      errorCodes: ["400", "401", "409", "4XX", "5XX"],
      retryConfig: context.retryConfig,
      retryCodes: context.retryCodes
    });
    if (!doResult.ok) {
      return [doResult, { status: "request-error", request: req }];
    }
    const response = doResult.value;
    const [result] = await match(nil(200, voidType()), fail([400, 401, 409, "4XX"]), fail("5XX"))(response, req);
    if (!result.ok) {
      return [result, { status: "complete", request: req, response }];
    }
    return [result, { status: "complete", request: req, response }];
  }

  // node_modules/@gleanwork/api-client/dist/esm/funcs/indexingPermissionsIndexGroup.js
  function indexingPermissionsIndexGroup(client, request, options) {
    return new APIPromise($do105(client, request, options));
  }
  async function $do105(client, request, options) {
    const parsed = safeParse(request, (value) => IndexGroupRequest$outboundSchema.parse(value), "Input validation failed");
    if (!parsed.ok) {
      return [parsed, { status: "invalid" }];
    }
    const payload = parsed.value;
    const body = encodeJSON("body", payload, { explode: true });
    const path = pathToFunc("/api/index/v1/indexgroup")();
    const headers = new Headers(compactMap({
      "Content-Type": "application/json",
      Accept: "*/*"
    }));
    const secConfig = await extractSecurity(client._options.apiToken);
    const securityInput = secConfig == null ? {} : { apiToken: secConfig };
    const requestSecurity = resolveGlobalSecurity(securityInput);
    const context = {
      options: client._options,
      baseURL: options?.serverURL ?? client._baseURL ?? "",
      operationID: "post_/api/index/v1/indexgroup",
      oAuth2Scopes: [],
      resolvedSecurity: requestSecurity,
      securitySource: client._options.apiToken,
      retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
      retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
    };
    const requestRes = client._createRequest(context, {
      security: requestSecurity,
      method: "POST",
      baseURL: options?.serverURL,
      path,
      headers,
      body,
      userAgent: client._options.userAgent,
      timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
    }, options);
    if (!requestRes.ok) {
      return [requestRes, { status: "invalid" }];
    }
    const req = requestRes.value;
    const doResult = await client._do(req, {
      context,
      errorCodes: ["400", "401", "409", "4XX", "5XX"],
      retryConfig: context.retryConfig,
      retryCodes: context.retryCodes
    });
    if (!doResult.ok) {
      return [doResult, { status: "request-error", request: req }];
    }
    const response = doResult.value;
    const [result] = await match(nil(200, voidType()), fail([400, 401, 409, "4XX"]), fail("5XX"))(response, req);
    if (!result.ok) {
      return [result, { status: "complete", request: req, response }];
    }
    return [result, { status: "complete", request: req, response }];
  }

  // node_modules/@gleanwork/api-client/dist/esm/funcs/indexingPermissionsIndexMembership.js
  function indexingPermissionsIndexMembership(client, request, options) {
    return new APIPromise($do106(client, request, options));
  }
  async function $do106(client, request, options) {
    const parsed = safeParse(request, (value) => IndexMembershipRequest$outboundSchema.parse(value), "Input validation failed");
    if (!parsed.ok) {
      return [parsed, { status: "invalid" }];
    }
    const payload = parsed.value;
    const body = encodeJSON("body", payload, { explode: true });
    const path = pathToFunc("/api/index/v1/indexmembership")();
    const headers = new Headers(compactMap({
      "Content-Type": "application/json",
      Accept: "*/*"
    }));
    const secConfig = await extractSecurity(client._options.apiToken);
    const securityInput = secConfig == null ? {} : { apiToken: secConfig };
    const requestSecurity = resolveGlobalSecurity(securityInput);
    const context = {
      options: client._options,
      baseURL: options?.serverURL ?? client._baseURL ?? "",
      operationID: "post_/api/index/v1/indexmembership",
      oAuth2Scopes: [],
      resolvedSecurity: requestSecurity,
      securitySource: client._options.apiToken,
      retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
      retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
    };
    const requestRes = client._createRequest(context, {
      security: requestSecurity,
      method: "POST",
      baseURL: options?.serverURL,
      path,
      headers,
      body,
      userAgent: client._options.userAgent,
      timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
    }, options);
    if (!requestRes.ok) {
      return [requestRes, { status: "invalid" }];
    }
    const req = requestRes.value;
    const doResult = await client._do(req, {
      context,
      errorCodes: ["400", "401", "409", "4XX", "5XX"],
      retryConfig: context.retryConfig,
      retryCodes: context.retryCodes
    });
    if (!doResult.ok) {
      return [doResult, { status: "request-error", request: req }];
    }
    const response = doResult.value;
    const [result] = await match(nil(200, voidType()), fail([400, 401, 409, "4XX"]), fail("5XX"))(response, req);
    if (!result.ok) {
      return [result, { status: "complete", request: req, response }];
    }
    return [result, { status: "complete", request: req, response }];
  }

  // node_modules/@gleanwork/api-client/dist/esm/funcs/indexingPermissionsIndexUser.js
  function indexingPermissionsIndexUser(client, request, options) {
    return new APIPromise($do107(client, request, options));
  }
  async function $do107(client, request, options) {
    const parsed = safeParse(request, (value) => IndexUserRequest$outboundSchema.parse(value), "Input validation failed");
    if (!parsed.ok) {
      return [parsed, { status: "invalid" }];
    }
    const payload = parsed.value;
    const body = encodeJSON("body", payload, { explode: true });
    const path = pathToFunc("/api/index/v1/indexuser")();
    const headers = new Headers(compactMap({
      "Content-Type": "application/json",
      Accept: "*/*"
    }));
    const secConfig = await extractSecurity(client._options.apiToken);
    const securityInput = secConfig == null ? {} : { apiToken: secConfig };
    const requestSecurity = resolveGlobalSecurity(securityInput);
    const context = {
      options: client._options,
      baseURL: options?.serverURL ?? client._baseURL ?? "",
      operationID: "post_/api/index/v1/indexuser",
      oAuth2Scopes: [],
      resolvedSecurity: requestSecurity,
      securitySource: client._options.apiToken,
      retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
      retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
    };
    const requestRes = client._createRequest(context, {
      security: requestSecurity,
      method: "POST",
      baseURL: options?.serverURL,
      path,
      headers,
      body,
      userAgent: client._options.userAgent,
      timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
    }, options);
    if (!requestRes.ok) {
      return [requestRes, { status: "invalid" }];
    }
    const req = requestRes.value;
    const doResult = await client._do(req, {
      context,
      errorCodes: ["400", "401", "409", "4XX", "5XX"],
      retryConfig: context.retryConfig,
      retryCodes: context.retryCodes
    });
    if (!doResult.ok) {
      return [doResult, { status: "request-error", request: req }];
    }
    const response = doResult.value;
    const [result] = await match(nil(200, voidType()), fail([400, 401, 409, "4XX"]), fail("5XX"))(response, req);
    if (!result.ok) {
      return [result, { status: "complete", request: req, response }];
    }
    return [result, { status: "complete", request: req, response }];
  }

  // node_modules/@gleanwork/api-client/dist/esm/funcs/indexingPermissionsProcessMemberships.js
  function indexingPermissionsProcessMemberships(client, request, options) {
    return new APIPromise($do108(client, request, options));
  }
  async function $do108(client, request, options) {
    const parsed = safeParse(request, (value) => ProcessAllMembershipsRequest$outboundSchema.optional().parse(value), "Input validation failed");
    if (!parsed.ok) {
      return [parsed, { status: "invalid" }];
    }
    const payload = parsed.value;
    const body = payload === void 0 ? null : encodeJSON("body", payload, { explode: true });
    const path = pathToFunc("/api/index/v1/processallmemberships")();
    const headers = new Headers(compactMap({
      "Content-Type": "application/json",
      Accept: "*/*"
    }));
    const secConfig = await extractSecurity(client._options.apiToken);
    const securityInput = secConfig == null ? {} : { apiToken: secConfig };
    const requestSecurity = resolveGlobalSecurity(securityInput);
    const context = {
      options: client._options,
      baseURL: options?.serverURL ?? client._baseURL ?? "",
      operationID: "post_/api/index/v1/processallmemberships",
      oAuth2Scopes: [],
      resolvedSecurity: requestSecurity,
      securitySource: client._options.apiToken,
      retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
      retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
    };
    const requestRes = client._createRequest(context, {
      security: requestSecurity,
      method: "POST",
      baseURL: options?.serverURL,
      path,
      headers,
      body,
      userAgent: client._options.userAgent,
      timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
    }, options);
    if (!requestRes.ok) {
      return [requestRes, { status: "invalid" }];
    }
    const req = requestRes.value;
    const doResult = await client._do(req, {
      context,
      errorCodes: ["400", "401", "4XX", "5XX"],
      retryConfig: context.retryConfig,
      retryCodes: context.retryCodes
    });
    if (!doResult.ok) {
      return [doResult, { status: "request-error", request: req }];
    }
    const response = doResult.value;
    const [result] = await match(nil(200, voidType()), fail([400, 401, "4XX"]), fail("5XX"))(response, req);
    if (!result.ok) {
      return [result, { status: "complete", request: req, response }];
    }
    return [result, { status: "complete", request: req, response }];
  }

  // node_modules/@gleanwork/api-client/dist/esm/funcs/indexingPermissionsUpdatePermissions.js
  function indexingPermissionsUpdatePermissions(client, request, options) {
    return new APIPromise($do109(client, request, options));
  }
  async function $do109(client, request, options) {
    const parsed = safeParse(request, (value) => UpdatePermissionsRequest$outboundSchema.parse(value), "Input validation failed");
    if (!parsed.ok) {
      return [parsed, { status: "invalid" }];
    }
    const payload = parsed.value;
    const body = encodeJSON("body", payload, { explode: true });
    const path = pathToFunc("/api/index/v1/updatepermissions")();
    const headers = new Headers(compactMap({
      "Content-Type": "application/json",
      Accept: "*/*"
    }));
    const secConfig = await extractSecurity(client._options.apiToken);
    const securityInput = secConfig == null ? {} : { apiToken: secConfig };
    const requestSecurity = resolveGlobalSecurity(securityInput);
    const context = {
      options: client._options,
      baseURL: options?.serverURL ?? client._baseURL ?? "",
      operationID: "post_/api/index/v1/updatepermissions",
      oAuth2Scopes: [],
      resolvedSecurity: requestSecurity,
      securitySource: client._options.apiToken,
      retryConfig: options?.retries || client._options.retryConfig || { strategy: "none" },
      retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"]
    };
    const requestRes = client._createRequest(context, {
      security: requestSecurity,
      method: "POST",
      baseURL: options?.serverURL,
      path,
      headers,
      body,
      userAgent: client._options.userAgent,
      timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1
    }, options);
    if (!requestRes.ok) {
      return [requestRes, { status: "invalid" }];
    }
    const req = requestRes.value;
    const doResult = await client._do(req, {
      context,
      errorCodes: ["400", "401", "409", "429", "4XX", "5XX"],
      retryConfig: context.retryConfig,
      retryCodes: context.retryCodes
    });
    if (!doResult.ok) {
      return [doResult, { status: "request-error", request: req }];
    }
    const response = doResult.value;
    const [result] = await match(nil(200, voidType()), fail([400, 401, 409, 429, "4XX"]), fail("5XX"))(response, req);
    if (!result.ok) {
      return [result, { status: "complete", request: req, response }];
    }
    return [result, { status: "complete", request: req, response }];
  }

  // node_modules/@gleanwork/api-client/dist/esm/sdk/permissions.js
  var Permissions = class extends ClientSDK {
    /**
     * Update document permissions
     *
     * @remarks
     * Updates the permissions for a given document without modifying document content.
     */
    async updatePermissions(request, options) {
      return unwrapAsync(indexingPermissionsUpdatePermissions(this, request, options));
    }
    /**
     * Index user
     *
     * @remarks
     * Adds a datasource user or updates an existing user.
     */
    async indexUser(request, options) {
      return unwrapAsync(indexingPermissionsIndexUser(this, request, options));
    }
    /**
     * Bulk index users
     *
     * @remarks
     * Replaces the users in a datasource using paginated batch API calls. Please refer to the [bulk indexing](https://developers.glean.com/indexing/documents/bulk-upload-model) documentation for an explanation of how to use bulk endpoints.
     */
    async bulkIndexUsers(request, options) {
      return unwrapAsync(indexingPermissionsBulkIndexUsers(this, request, options));
    }
    /**
     * Index group
     *
     * @remarks
     * Add or update a group in the datasource.
     */
    async indexGroup(request, options) {
      return unwrapAsync(indexingPermissionsIndexGroup(this, request, options));
    }
    /**
     * Bulk index groups
     *
     * @remarks
     * Replaces the groups in a datasource using paginated batch API calls. Please refer to the [bulk indexing](https://developers.glean.com/indexing/documents/bulk-upload-model) documentation for an explanation of how to use bulk endpoints.
     */
    async bulkIndexGroups(request, options) {
      return unwrapAsync(indexingPermissionsBulkIndexGroups(this, request, options));
    }
    /**
     * Index membership
     *
     * @remarks
     * Add the memberships of a group in the datasource.
     */
    async indexMembership(request, options) {
      return unwrapAsync(indexingPermissionsIndexMembership(this, request, options));
    }
    /**
     * Bulk index memberships for a group
     *
     * @remarks
     * Replaces the memberships for a group in a datasource using paginated batch API calls. Please refer to the [bulk indexing](https://developers.glean.com/indexing/documents/bulk-upload-model) documentation for an explanation of how to use bulk endpoints.
     */
    async bulkIndexMemberships(request, options) {
      return unwrapAsync(indexingPermissionsBulkIndexMemberships(this, request, options));
    }
    /**
     * Schedules the processing of group memberships
     *
     * @remarks
     * Schedules the immediate processing of all group memberships uploaded through the indexing API. By default the uploaded group memberships will be processed asynchronously but this API can be used to schedule processing of all memberships on demand.
     */
    async processMemberships(request, options) {
      return unwrapAsync(indexingPermissionsProcessMemberships(this, request, options));
    }
    /**
     * Delete user
     *
     * @remarks
     * Delete the user from the datasource. Silently succeeds if user is not present.
     */
    async deleteUser(request, options) {
      return unwrapAsync(indexingPermissionsDeleteUser(this, request, options));
    }
    /**
     * Delete group
     *
     * @remarks
     * Delete group from the datasource. Silently succeeds if group is not present.
     */
    async deleteGroup(request, options) {
      return unwrapAsync(indexingPermissionsDeleteGroup(this, request, options));
    }
    /**
     * Delete membership
     *
     * @remarks
     * Delete membership to a group in the specified datasource. Silently succeeds if membership is not present.
     */
    async deleteMembership(request, options) {
      return unwrapAsync(indexingPermissionsDeleteMembership(this, request, options));
    }
    /**
     * Beta users
     *
     * @remarks
     * Allow the datasource be visible to the specified beta users. The default behaviour is datasource being visible to all users if it is enabled and not visible to any user if it is not enabled.
     */
    async authorizeBetaUsers(request, options) {
      return unwrapAsync(indexingPermissionsAuthorizeBetaUsers(this, request, options));
    }
  };

  // node_modules/@gleanwork/api-client/dist/esm/sdk/indexing.js
  var Indexing = class extends ClientSDK {
    get documents() {
      return this._documents ?? (this._documents = new IndexingDocuments(this._options));
    }
    get permissions() {
      return this._permissions ?? (this._permissions = new Permissions(this._options));
    }
    get datasource() {
      return this._datasource ?? (this._datasource = new Datasource2(this._options));
    }
    get people() {
      return this._people ?? (this._people = new People(this._options));
    }
    get datasources() {
      return this._datasources ?? (this._datasources = new Datasources(this._options));
    }
    get authentication() {
      return this._authentication ?? (this._authentication = new IndexingAuthentication(this._options));
    }
    get shortcuts() {
      return this._shortcuts ?? (this._shortcuts = new IndexingShortcuts(this._options));
    }
  };

  // node_modules/@gleanwork/api-client/dist/esm/sdk/sdk.js
  var Glean = class extends ClientSDK {
    get client() {
      return this._client ?? (this._client = new Client(this._options));
    }
    get indexing() {
      return this._indexing ?? (this._indexing = new Indexing(this._options));
    }
  };

  // <stdin>
  globalThis.__deps__ = globalThis.__deps__ || {};
  globalThis.__deps__._gleanwork_api_client = esm_exports;
})();
